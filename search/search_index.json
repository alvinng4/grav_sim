{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"grav_sim","text":"<p>N-body gravity simulation library with C and Python API</p> <ul> <li>Source code: https://github.com/alvinng4/grav_sim</li> <li>Project Homepage and documentations: https://alvinng4.github.io/grav_sim/</li> </ul> <p>Target Audience:</p> <ul> <li>Physics students</li> <li>Anyone interested in N-body simulations</li> </ul> <p>Features:</p> <ul> <li>Ten integrators including WHFast and IAS15</li> <li>Barnes-Hut algorithm with linear octree</li> <li>Particle-Mesh method for cosmological structure formation</li> <li>Multiple sample projects</li> </ul>"},{"location":"#5-steps-to-n-body-simulation","title":"5 steps to N-body simulation","text":"<p>A short course to teach beginners how to write fast and clean N-body gravity simulations code in Python.</p> <p>Homepage: https://alvinng4.github.io/grav_sim/5_steps_to_n_body_simulation/</p> <p>Contents</p> <ul> <li>Step 1: Initial setup</li> <li>Step 2: Gravity</li> <li>Step 3: Your first N-body program</li> <li>Step 4: Higher-order algorithms</li> <li>Step 5: Adaptive time-stepping</li> <li>Extra: Plotting and animation</li> <li>Conclusion and Final Project</li> </ul> <p> </p>"},{"location":"#sample-projects","title":"Sample projects","text":""},{"location":"#evolving-the-solar-system-for-1-million-years","title":"Evolving the solar system for 1 million years","text":""},{"location":"#asteroid-belt-animation","title":"Asteroid belt animation","text":""},{"location":"#formation-of-kirkwood-gaps","title":"Formation of Kirkwood gaps","text":""},{"location":"#galaxy-collision","title":"Galaxy collision","text":""},{"location":"#cosmological-structure-formation","title":"Cosmological structure formation","text":""},{"location":"#feedback-and-bugs","title":"Feedback and Bugs","text":"<p>If you found any bugs or want to leave some feedback, please feel free to let me know by opening an issue or sending an email to alvinng324(at)gmail.com.</p>"},{"location":"5_steps_to_n_body_simulation/","title":"5 steps to N-body simulation","text":"<p>This is a series of tutorials inspired by the course \"CFD Python: 12 steps to Navier-Stokes\". The goal is to teach beginners how to write fast and clean N-body gravity simulations code in Python.</p> <p>Although basic knowledge in Python and Calculus is assumed, everything is explained in detail so  beginners should be able to follow along. After completing this tutorial, you would be able to write your own N-body simulation code in Python. At the end of the tutorial, you are encouraged to make your own project related to N-body simulation.</p>"},{"location":"5_steps_to_n_body_simulation/#how-to-use-this-tutorial","title":"How to use this tutorial?","text":"<p>The source code for the python scripts and the markdown files are available on</p> <ul> <li>https://github.com/alvinng4/grav_sim/tree/main/5_steps_to_n_body_simulation</li> </ul> <p>but I strongly recommend reading this tutorial on our website: </p> <ul> <li>https://alvinng4.github.io/grav_sim/5_steps_to_n_body_simulation/</li> </ul> <p>Snippets of the code will be shown as we progress, but you don't have to copy them one by one as the full code is always available at the end of each step. However, I do recommend you to translate it into your own code in order to have a better understanding.</p> <p>Contents</p> <ul> <li>Step 1: Initial setup</li> <li>Step 2: Gravity</li> <li>Step 3: Your first N-body program</li> <li>Step 4: Higher-order algorithms</li> <li>Step 5: Adaptive time-stepping</li> <li>Extra: Plotting and animation</li> <li>Conclusion and Final Project</li> </ul>"},{"location":"5_steps_to_n_body_simulation/#references","title":"References","text":"<ol> <li>Lorena Barba and Gilbert Forsyth. CFD Python: the 12 steps to Navier-Stokes equations. Journal of Open Source Education, 2(16):21, 2019. doi:10.21105/jose.00021.</li> <li>Javier Roa, Adrian S. Hamers, Maxwell X. Cai, and Nathan W. C. Leigh. Moving Planets Around: An Introduction to N-Body Simulations Applied to Exoplanetary Systems. MIT Press, 2020.</li> <li>Richard L. Burden and J. Douglas Faires. Numerical Analysis. Cengage Learning, nineth edition, 2011.</li> </ol>"},{"location":"5_steps_to_n_body_simulation/conclusion/","title":"Conclusion and Final Project","text":"<p>Congratulations on finishing the tutorial! Now that you have obtained the basic knowledge in N-body simulation, it is time for you to make your own project! (If you are interested)</p> <p>There are so many things you can do with N-body simulation. Below are some possible ideas, but you can also come up with your own project.</p> <ul> <li> <p>Game: You can make a simple game using N-body simulation. (In fact,     I made a game called OrbitSim     when I first started learning Python and N-body simulation.)</p> <p></p> </li> <li> <p>Rewrite the code: You can rewrite the code in C / C++ or your     favorite language and compare the performance. You can also try     to use Numba or Cython to speed up your code in Python. Maybe     write your own N-body simulation library?</p> </li> <li> <p>Large-scale simulation: So far, we have only focused on systems     with a few objects. What about large-scale systems with thousands     or millions of objects? Turns out it is not so easy because the      computation of gravity scales as \\(\\mathcal{O}(N^2)\\). Have a look     at Barnes-Hut algorithm to see how to speed up the simulation.     In fact, we have documentations about it on this website as well.     You may try to implement it in some low-level language like C or C++.</p> <p></p> </li> <li> <p>Reproducing observations: If you are not interested in     writing low-level simulation code, you can still do some interesting projects     using our <code>grav_sim</code> project written in C. One example is reproducing the     Kirkwood gaps in our solar system.</p> <p></p> </li> </ul> <p>Good luck and have fun!</p>"},{"location":"5_steps_to_n_body_simulation/extra/","title":"Extra","text":"<p>This is an extra component to 5 steps to n-body simulation. I figured some of you may be interested in the visuals, so in this section, I will show you how to make 3D plots and produce animations using the <code>matplotlib</code> library.</p>"},{"location":"5_steps_to_n_body_simulation/extra/#plotting-in-3d","title":"Plotting in 3D","text":"<p>It would be nice to plot the trajectory in 3D. To do this, we will need two functions, one to set the 3D axes limits in equal aspect ratio, and one to plot the trajectory in 3D.</p> Code (Click to expand) common.py<pre><code>def set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre> <p>To make the plot look better, I added a few dwarf planets like Pluto. The initial condition is already available in the <code>get_initial_conditions</code> function (input <code>solar_system_plus</code>). In step 4 or step 5, change <code>plot_2d_trajectory</code> to <code>plot_3d_trajectory</code>, and you should see a 3D plot:</p> <p></p>"},{"location":"5_steps_to_n_body_simulation/extra/#animations","title":"Animations","text":"<p>Animations generally consists of two steps:</p> <ol> <li>Generating the frames</li> <li>Combining the frames into a video</li> </ol> <p>If you know how to make a plot, you already know how to generate frames. First, let us copy <code>step5.py</code> to <code>extra.py</code> and modify it slightly to include <code>solar_system_plus</code>.</p> Code (Click to expand) extra.py<pre><code>OPTION = 2\n\n# Default units is AU, days, and M_sun\n\n# Solar system\nif OPTION == 0:\n    INITIAL_CONDITION = \"solar_system\"\n    TF = 200.0 * 365.24  # 200 years to days\n    TOLERANCE = 1e-8\n    OUTPUT_INTERVAL = 0.01 * 365.24  # 0.01 year to days\n    INITIAL_DT = 1.0\n\n# Pyth-3-body\nelif OPTION == 1:\n    INITIAL_CONDITION = \"pyth-3-body\"\n    TF = 70.0\n    TOLERANCE = 1e-13\n    OUTPUT_INTERVAL = 0.001\n    INITIAL_DT = 0.01\n\nelif OPTION == 2:\n    INITIAL_CONDITION = \"solar_system_plus\"\n    TF = 250.0 * 365.24  # 200 years to days\n    TOLERANCE = 1e-8\n    OUTPUT_INTERVAL = 0.5 * 365.24  # 0.5 year to days\n    INITIAL_DT = 1.0\n\nelse:\n    raise ValueError(\n        \"Invalid option. Choose 0 for solar system, 1 for Pyth-3-body, or 2 for solar system plus.\"\n    )\n</code></pre> <p>Output interval</p> <p>Be careful with the output interval. In this section, we are converting all solution output into frames. A few hundred frames should be enough.</p> <p>We need a place to store the frames. Lets store it at <code>5_steps_to_n_body_simulation/figures/frames</code> (or anywhere you like).</p> extra.py<pre><code>from pathlib import Path\n\nFRAMES_DIR = Path(__file__).parent.parent / \"figures\" / \"frames\"\nFRAMES_DIR.mkdir(parents=True, exist_ok=True)\n</code></pre> <p>For simplicity, let us draw the frames in the <code>main</code> function. Note that we need to set the min and max values for the axes. extra.py<pre><code>    print(\"Drawing frames...\")\n    x_min, x_max = np.min(sol_x[:, :, 0]), np.max(sol_x[:, :, 0])\n    y_min, y_max = np.min(sol_x[:, :, 1]), np.max(sol_x[:, :, 1])\n    z_min, z_max = np.min(sol_x[:, :, 2]), np.max(sol_x[:, :, 2])\n    xyz_min = np.min([x_min, y_min, z_min])\n    xyz_max = np.max([x_max, y_max, z_max])\n\n    for n in range(output_count):\n        print(f\"Progress: {n + 1} / {output_count}\", end=\"\\r\")\n\n        # Draw the trajectory\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n        ax.set_xlabel(\"$x$ (AU)\")\n        ax.set_ylabel(\"$y$ (AU)\")\n        ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n        for i in range(sol_x.shape[1]):\n            traj = ax.plot(\n                sol_x[:n, i, 0],\n                sol_x[:n, i, 1],\n                sol_x[:n, i, 2],\n                color=colors[i],\n            )\n            # Plot the last position with marker\n            ax.scatter(\n                sol_x[n, i, 0],\n                sol_x[n, i, 1],\n                sol_x[n, i, 2],\n                marker=\"o\",\n                color=traj[0].get_color(),\n                label=labels[i],\n            )\n\n        ax.set_xlim3d(xyz_min, xyz_max)\n        ax.set_ylim3d(xyz_min, xyz_max)\n        ax.set_zlim3d(xyz_min, xyz_max)\n\n        # Set equal aspect ratio to prevent distortion\n        ax.set_aspect(\"equal\")\n\n        if legend:\n            ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n            fig.subplots_adjust(right=0.7)\n            fig.tight_layout()\n\n        plt.savefig(FRAMES_DIR / f\"frames_{n:05d}.png\")\n        plt.close(\"all\")\n    print(\"\\nDone!\")\n</code></pre></p> <p>Now, we can combine the frames into a gif file using the <code>PIL</code> library. (If you want a mp4 file instead, you can use the <code>ffmpeg</code> library.) You can install <code>PIL</code> using </p> <pre><code>pip install pillow\n</code></pre> <p>The code is given below. The logic is simple: we open the first frame and append the rest of  the frames to it. After the animation is done, we delete all frames by using <code>Path.unlink()</code>.</p> <p>Generator function</p> <p>We used a generator function <code>frames_generator</code>. If you use a list instead, you may run out of memory very quickly.</p> extra.py<pre><code>    print(\"Combining frames to gif...\")\n\n    def frames_generator():\n        for i in range(output_count):\n            yield PIL.Image.open(FRAMES_DIR / f\"frames_{i:05d}.png\")\n\n    fps = 30\n    frames = frames_generator()\n    next(frames).save(\n        FRAMES_DIR / \"animation.gif\",\n        save_all=True,\n        append_images=frames,\n        loop=0,\n        duration=(1000 // fps),\n    )\n\n    for i in range(output_count):\n        (FRAMES_DIR / f\"frames_{i:05d}.png\").unlink()\n\n    print(f\"Output completed! Please check {FRAMES_DIR / 'animation.gif'}\")\n    print()\n</code></pre> <p>You should see the animation:</p>"},{"location":"5_steps_to_n_body_simulation/extra/#conclusion","title":"Conclusion","text":"<p>In this section, we learned how to make 3D plots and animations using the <code>matplotlib</code> library.</p>"},{"location":"5_steps_to_n_body_simulation/extra/#full-scripts","title":"Full scripts","text":"<p>The full scripts are available at <code>5_steps_to_n_body_simulation/python/</code>, or https://github.com/alvinng4/grav_sim/blob/main/5_steps_to_n_body_simulation/python/</p> extra.py (Click to expand) 5_steps_to_n_body_simulation/python/extra.py<pre><code>import math\nimport timeit\nfrom pathlib import Path\n\nimport numpy as np\nimport PIL\nimport matplotlib.pyplot as plt\n\nimport common\n\nOPTION = 2\nFRAMES_DIR = Path(__file__).parent.parent / \"figures\" / \"frames\"\nFRAMES_DIR.mkdir(parents=True, exist_ok=True)\n\n# Default units is AU, days, and M_sun\n\n# Solar system\nif OPTION == 0:\n    INITIAL_CONDITION = \"solar_system\"\n    TF = 200.0 * 365.24  # 200 years to days\n    TOLERANCE = 1e-8\n    OUTPUT_INTERVAL = 0.01 * 365.24  # 0.01 year to days\n    INITIAL_DT = 1.0\n\n# Pyth-3-body\nelif OPTION == 1:\n    INITIAL_CONDITION = \"pyth-3-body\"\n    TF = 70.0\n    TOLERANCE = 1e-13\n    OUTPUT_INTERVAL = 0.001\n    INITIAL_DT = 0.01\n\nelif OPTION == 2:\n    INITIAL_CONDITION = \"solar_system_plus\"\n    TF = 250.0 * 365.24  # 200 years to days\n    TOLERANCE = 1e-8\n    OUTPUT_INTERVAL = 0.5 * 365.24  # 0.5 year to days\n    INITIAL_DT = 1.0\n\nelse:\n    raise ValueError(\n        \"Invalid option. Choose 0 for solar system, 1 for Pyth-3-body, or 2 for solar system plus.\"\n    )\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n\n    # RKF4(5) coefficients\n    # fmt: off\n    coeff = np.array((\n        [1.0 / 4.0, 0.0, 0.0, 0.0, 0.0],\n        [3.0 / 32.0, 9.0 / 32.0, 0.0, 0.0, 0.0],\n        [1932.0 / 2197.0, -7200.0 / 2197.0, 7296.0 / 2197.0, 0.0, 0.0],\n        [439.0 / 216.0, -8.0, 3680.0 / 513.0, -845.0 / 4104.0, 0.0],\n        [-8.0 / 27.0, 2.0, -3544.0 / 2565.0, 1859.0 / 4104.0, -11.0 / 40.0],\n    ))\n    # fmt: on\n    weights = np.array(\n        [25.0 / 216.0, 0.0, 1408.0 / 2565.0, 2197.0 / 4104.0, -1.0 / 5.0, 0.0]\n    )\n    weights_test = np.array(\n        [\n            16.0 / 135.0,\n            0.0,\n            6656.0 / 12825.0,\n            28561.0 / 56430.0,\n            -9.0 / 50.0,\n            2.0 / 55.0,\n        ]\n    )\n    min_power = 4\n    num_stages = len(weights)\n\n    # Initialize memory and arrays\n    a = np.zeros((system.num_particles, 3))\n    temp_system = common.System(\n        num_particles=system.num_particles,\n        x=np.zeros((system.num_particles, 3)),\n        v=np.zeros((system.num_particles, 3)),\n        m=system.m,\n        G=system.G,\n    )\n    x_1 = np.zeros((system.num_particles, 3))\n    v_1 = np.zeros((system.num_particles, 3))\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n    error_estimation_delta_x = np.zeros((system.num_particles, 3))\n    error_estimation_delta_v = np.zeros((system.num_particles, 3))\n    tolerance_scale_x = np.zeros((system.num_particles, 3))\n    tolerance_scale_v = np.zeros((system.num_particles, 3))\n\n    # Safety factors for step-size control\n    safety_fac_max = 6.0\n    safety_fac_min = 0.33\n    safety_fac = math.pow(0.38, 1.0 / (1.0 + float(min_power)))\n\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_dt = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    sol_dt[0] = INITIAL_DT\n    output_count = 1\n\n    # Launch simulation\n    common.print_simulation_info_adaptive_step_size(\n        system, TF, TOLERANCE, INITIAL_DT, OUTPUT_INTERVAL, sol_size\n    )\n    next_output_time = output_count * OUTPUT_INTERVAL\n    start = timeit.default_timer()\n    dt = INITIAL_DT\n    current_time = 0.0\n    while current_time &lt; TF:\n        # Initial stage\n        common.acceleration(a, system)\n        xk[0] = system.v\n        vk[0] = a\n\n        # Compute the stages\n        for stage in range(1, num_stages):\n            # Empty temp_x and temp_v\n            temp_system.x.fill(0.0)\n            temp_system.v.fill(0.0)\n\n            for i in range(stage):\n                temp_system.x[:] += coeff[stage - 1, i] * xk[i]\n                temp_system.v[:] += coeff[stage - 1, i] * vk[i]\n\n            temp_system.x[:] = system.x + dt * temp_system.x\n            temp_system.v[:] = system.v + dt * temp_system.v\n\n            # Compute the acceleration\n            xk[stage] = temp_system.v\n            common.acceleration(vk[stage], temp_system)\n\n        # Calculate x_1, v_1 and also delta x, delta v for error estimation\n        x_1[:] = system.x\n        v_1[:] = system.v\n        error_estimation_delta_x.fill(0.0)\n        error_estimation_delta_v.fill(0.0)\n        for stage in range(num_stages):\n            x_1[:] += dt * weights[stage] * xk[stage]\n            v_1[:] += dt * weights[stage] * vk[stage]\n            error_estimation_delta_x[:] += (\n                dt * (weights[stage] - weights_test[stage]) * xk[stage]\n            )\n            error_estimation_delta_v[:] += (\n                dt * (weights[stage] - weights_test[stage]) * vk[stage]\n            )\n\n        # Error estimation\n        tolerance_scale_x[:] = (\n            TOLERANCE + np.maximum(np.abs(system.x), np.abs(x_1)) * TOLERANCE\n        )\n        tolerance_scale_v[:] = (\n            TOLERANCE + np.maximum(np.abs(system.v), np.abs(v_1)) * TOLERANCE\n        )\n\n        total = np.sum(\n            np.square(error_estimation_delta_x / tolerance_scale_x)\n        ) + np.sum(np.square(error_estimation_delta_v / tolerance_scale_v))\n        error = math.sqrt(total / (system.num_particles * 3.0 * 2.0))\n\n        # Advance step\n        if error &lt;= 1.0 or dt &lt;= TF * 1e-12:\n            current_time += dt\n            system.x[:] = x_1\n            system.v[:] = v_1\n\n            if current_time &gt;= next_output_time:\n                sol_x[output_count] = system.x\n                sol_v[output_count] = system.v\n                sol_t[output_count] = current_time\n                sol_dt[output_count] = dt\n\n                output_count += 1\n                next_output_time = output_count * OUTPUT_INTERVAL\n\n                print(f\"Current time: {current_time:.2f} days\", end=\"\\r\")\n\n        # Calculate dt for next step\n        if error &lt; 1e-12:\n            error = 1e-12  # Prevent error from being too small\n\n        dt_new = dt * safety_fac / math.pow(error, 1.0 / (1.0 + float(min_power)))\n        if dt_new &gt; safety_fac_max * dt:\n            dt *= safety_fac_max\n        elif dt_new &lt; safety_fac_min * dt:\n            dt *= safety_fac_min\n        else:\n            dt = dt_new\n\n        if dt_new &lt; TF * 1e-12:\n            dt = TF * 1e-12\n\n        # Correct overshooting\n        if current_time &lt; TF and current_time + dt &gt; TF:\n            dt = TF - current_time\n\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n    sol_dt = sol_dt[:output_count]\n\n    end = timeit.default_timer()\n\n    print()\n    print(f\"Done! Runtime: {end - start:.3g} seconds, Solution size: {output_count}\")\n\n    print(\"Drawing frames...\")\n    x_min, x_max = np.min(sol_x[:, :, 0]), np.max(sol_x[:, :, 0])\n    y_min, y_max = np.min(sol_x[:, :, 1]), np.max(sol_x[:, :, 1])\n    z_min, z_max = np.min(sol_x[:, :, 2]), np.max(sol_x[:, :, 2])\n    xyz_min = np.min([x_min, y_min, z_min])\n    xyz_max = np.max([x_max, y_max, z_max])\n\n    for n in range(output_count):\n        print(f\"Progress: {n + 1} / {output_count}\", end=\"\\r\")\n\n        # Draw the trajectory\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection=\"3d\")\n        ax.set_xlabel(\"$x$ (AU)\")\n        ax.set_ylabel(\"$y$ (AU)\")\n        ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n        for i in range(sol_x.shape[1]):\n            traj = ax.plot(\n                sol_x[:n, i, 0],\n                sol_x[:n, i, 1],\n                sol_x[:n, i, 2],\n                color=colors[i],\n            )\n            # Plot the last position with marker\n            ax.scatter(\n                sol_x[n, i, 0],\n                sol_x[n, i, 1],\n                sol_x[n, i, 2],\n                marker=\"o\",\n                color=traj[0].get_color(),\n                label=labels[i],\n            )\n\n        ax.set_xlim3d(xyz_min, xyz_max)  # type: ignore\n        ax.set_ylim3d(xyz_min, xyz_max)  # type: ignore\n        ax.set_zlim3d(xyz_min, xyz_max)  # type: ignore\n\n        # Set equal aspect ratio to prevent distortion\n        ax.set_aspect(\"equal\")\n\n        if legend:\n            ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n            fig.subplots_adjust(right=0.7)\n            fig.tight_layout()\n\n        plt.savefig(FRAMES_DIR / f\"frames_{n:05d}.png\")\n        plt.close(\"all\")\n    print(\"\\nDone!\")\n\n    print(\"Combining frames to gif...\")\n\n    def frames_generator():\n        for i in range(output_count):\n            yield PIL.Image.open(FRAMES_DIR / f\"frames_{i:05d}.png\")\n\n    fps = 30\n    frames = frames_generator()\n    next(frames).save(\n        FRAMES_DIR / \"animation.gif\",\n        save_all=True,\n        append_images=frames,\n        loop=0,\n        duration=(1000 // fps),\n    )\n\n    for i in range(output_count):\n        (FRAMES_DIR / f\"frames_{i:05d}.png\").unlink()\n\n    print(f\"Output completed! Please check {FRAMES_DIR / 'animation.gif'}\")\n    print()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> common.py (Click to expand) 5_steps_to_n_body_simulation/python/common.py<pre><code>from typing import Tuple, List, Optional\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##### Step 1 #####\nclass System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n\ndef get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_PLUS_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n\n\ndef plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show()\n\n\n##### Step 2 #####\ndef acceleration(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\n##### Step 3 #####\ndef euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n\n\ndef print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n\n\n##### Step 4 #####\ndef compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n\n\ndef plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time\")\n    plt.show()\n\n\ndef euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n\n\ndef rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    # dx = 0.0\n    # dv = 0.0\n    # for stage in range(num_stages):\n    #     dx += weights[stage] * xk[stage]\n    #     dv += weights[stage] * vk[stage]\n\n    dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\n    dv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n\n\ndef leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n\n##### Step 5 #####\ndef print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n\n\n##### Extra #####\ndef set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step1/","title":"Step 1","text":""},{"location":"5_steps_to_n_body_simulation/step1/#how-to-use-this-tutorial","title":"How to use this tutorial?","text":"<p>The source code for the python scripts and the markdown files are available on</p> <ul> <li>https://github.com/alvinng4/grav_sim/tree/main/5_steps_to_n_body_simulation</li> </ul> <p>but I strongly recommend reading this tutorial on our website: </p> <ul> <li>https://alvinng4.github.io/grav_sim/5_steps_to_n_body_simulation/</li> </ul> <p>Snippets of the code will be shown as we progress, but you don't have to copy them one by one as the full code is always available at the end of each step. However, I do recommend you to translate it into your own code in order to have a better understanding.</p>"},{"location":"5_steps_to_n_body_simulation/step1/#step-1-initial-setup","title":"Step 1: Initial setup","text":"<p>Welcome to the first step of 5 steps to N-body simulation!  This is a series of tutorials with the goal of teaching beginners how to write fast and clean N-body gravity simulations code in Python. In this step, we will set up the required python environment and implement some basic functions to be used in the following steps.</p> <p>First of all, make sure you have Python 3 installed (to be safe, I recommend Python 3.9 or later). You can check the installation by running the following command in your terminal: <pre><code>python --version\n</code></pre></p> <p>Two packages are required for this tutorial: <code>numpy</code> and <code>matplotlib</code>. They are popular packages in Python for scientific computing and data visualization. You can install them using <code>pip</code>: <pre><code>pip install numpy matplotlib\n</code></pre></p> <p>Now we are ready to start coding. First, let us create two files:</p> <ul> <li><code>common.py</code>: This file will contain the common functions and classes   used in all steps.</li> <li><code>step1.py</code>: This file will contain the code for this step.</li> </ul> <p>We first focus on <code>common.py</code>. Import the required packages: common.py<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n</code></pre></p>"},{"location":"5_steps_to_n_body_simulation/step1/#system","title":"System","text":"<p>To keep the code clean and organized, we will create a class called <code>System</code> to represent the N-body system. It has the following attributes:</p> <ul> <li><code>num_particles (float)</code>: Number of particles N in the system.</li> <li><code>x (np.ndarray)</code>: Positions of the particles in 3D space (shape: (N, 3)).</li> <li><code>v (np.ndarray)</code>: Velocities of the particles in 3D space (shape: (N, 3)).</li> <li><code>m (np.ndarray)</code>: Masses of the particles (shape: (N,)).</li> <li><code>G (float)</code>: Gravitational constant.</li> </ul> common.py<pre><code>class System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n</code></pre> <p>We will also implement a method to set the center of mass position and velocity to zero. This is to prevent drifting of the system during the simulation, and to set the center of mass of the system to the origin. To do this, we subtract the center of mass position and velocity from the particles,</p> \\[     \\mathbf{r}_{\\mathrm{com}} = \\frac{1}{M} \\sum_{i=1}^{N} m_i \\mathbf{r}_i,     \\quad      \\mathbf{v}_{\\mathrm{com}} = \\frac{1}{M} \\sum_{i=1}^{N} m_i \\mathbf{v}_i. \\] <p>where \\(M\\) is the total mass of the system, \\(m_i\\), \\(\\mathbf{r}_i\\), and \\(\\mathbf{v}_i\\) are the mass, position, and velocity of the i-th particle respectively. If you don't care about the  performance, you may just use a for loop to iterate over all particles. By the way, <code>x_cm</code> is a 3D vector, <code>m[i]</code> is a scalar, and <code>self.x[i]</code> is a 3D vector. common.py<pre><code>class System:\n    ...\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        x_cm = np.zeros(3)\n        v_cm = np.zeros(3)\n        M = 0.0\n        for i in range(self.num_particles):\n            x_cm += self.m[i] * self.x[i]\n            v_cm += self.m[i] * self.v[i]\n            M += self.m[i]\n\n        x_cm /= M\n        v_cm /= M\n        self.x -= x_cm\n        self.v -= v_cm\n</code></pre></p> <p>Optimization</p> <p>Python loops are very slow.  Here, we introduce a more efficient approach using <code>numpy</code>'s broadcasting feature. First, we compute \\(m_i \\mathbf{r}_i\\) as <pre><code>self.m[:, np.newaxis] * self.x\n</code></pre> where <code>np.newaxis</code> is used to \"broadcast\" the mass array along axis 1 (column).</p> \\[     \\begin{bmatrix}         m_{1} \\\\         m_{2} \\\\         \\vdots \\\\         m_{N}     \\end{bmatrix}     \\to     \\begin{bmatrix}         m_{1} \\dots \\\\         m_{2} \\dots \\\\         \\vdots  \\\\         m_{N} \\dots     \\end{bmatrix} \\] <p>The shape of <code>self.m[:, np.newaxis]</code> is now <code>(N, 1)</code> and the shape of <code>self.x</code> is <code>(N, 3)</code>. The multiplication is then done element-wise as</p> \\[     \\begin{bmatrix}         m_{1} r_{1,1} &amp; m_{1} r_{1,2} &amp; m_{1} r_{1,3} \\\\         m_{2} r_{2,1} &amp; m_{2} r_{2,2} &amp; m_{2} r_{2,3} \\\\         \\vdots &amp; \\vdots &amp; \\vdots \\\\         m_{N} r_{N,1} &amp; m_{N} r_{N,2} &amp; m_{N} r_{N,3}     \\end{bmatrix} \\] <p>Then, to get \\(\\sum_{i = 1}^N m_i \\mathbf{r}_i\\) we perform the summation along the axis 0 (row) with length <code>N</code> by <pre><code>np.sum(self.m[:, np.newaxis] * self.x, axis=0)\n</code></pre> A even faster way is to use <code>np.einsum</code>.  <pre><code>np.einsum(\"i,ij-&gt;j\", self.m, self.x)\n</code></pre> Why <code>i,ij-&gt;j</code>? Denote the axis 0 and 1 as \\(i\\) and \\(j\\) respectively.</p> <ul> <li><code>m</code> is a 1D vector broadcasted along axis 1: \\(i\\)</li> <li><code>x</code> is a 2D vector: \\(ij\\)</li> <li>Final sum is done along axis 0: \\(ij \\to j\\)</li> </ul> <p>Finally, the total mass \\(M\\) can be simply computed as <pre><code>M = np.sum(self.m)\n</code></pre> Putting it all together, we have the following code: common.py<pre><code>class System:\n    ...\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n</code></pre></p>"},{"location":"5_steps_to_n_body_simulation/step1/#initial-conditions-solar-system","title":"Initial conditions (Solar System)","text":"<p>With the <code>System</code> class ready, we can now implement a function to get the initial conditions. Since it is tedious to prepare the initial conditions, I have prepared the data for you. Simply input the name of the system and it will return the initial conditions and information for plotting.</p> <p>Data Sources</p> <p>The Solar System initial conditions at 1/Jan/2024 are generated using the  JPL Horizons System<sup>1</sup>. Gravitational constant and masses of the solar system objects are calculated using  the data from R.S. Park, et. al.<sup>2</sup>.</p> <p>Tip</p> <p>In our tutorial, we will stick with the following units:</p> <ul> <li>Length: AU (Astronomical Unit), i.e. the distance from the Earth to the Sun.</li> <li>Mass: \\(M_\\odot\\) (Solar mass)</li> <li>Time: days</li> </ul> <p>They are convenient units for solar system simulations. If you want to use different units, make sure to convert all data to the same units and be consistent.</p> Code (Click to expand) common.py<pre><code>def get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_POS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_POS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step1/#plotting-initial-conditions","title":"Plotting initial conditions","text":"<p>Finally, we will implement a function to plot the initial conditions of the solar system. We will use the <code>matplotlib</code> package to plot the positions of the particles in 2D. Colors and labels are optional, but they make the plot look nicer. If <code>plt.show()</code> does not work in your environment, you may need to change it to <code>plt.savefig(file_name)</code> to save the plot.</p> common.py<pre><code>def plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show() # Here, you may need to change to plt.savefig(file_name) if \n               # plt.show() does not work in your environment. \n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step1/#test-the-code","title":"Test the code","text":"<p>Now we could try to run the code with <code>step1.py</code>. step1.py<pre><code>import common\n\nINITIAL_CONDITION = \"solar_system\"\n\n\ndef main():\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n    print(\"Number of particles:\", system.num_particles)\n    print(\"Initial positions (AU):\\n\", system.x)\n    print(\"Initial velocities (AU/day):\\n\", system.v)\n    print(\"Masses (M_sun):\\n\", system.m)\n    print(\"Gravitational constant (AU^3 / day^2 / M_sun):\", system.G)\n\n    # Plot the initial conditions\n    common.plot_initial_conditions(\n        system=system,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> <p>As you run the code, you should see the following output: <pre><code>Number of particles: 9\nInitial positions (AU):\n [[-7.96712825e-03 -2.90611166e-03  2.10213120e-04]\n [-2.82597500e-01  1.97456095e-01  4.17742433e-02]\n [-7.23209543e-01 -7.94829045e-02  4.04286220e-02]\n [-1.73818374e-01  9.66324671e-01  1.55297876e-04]\n [-3.01325412e-01 -1.45402922e+00 -2.30054066e-02]\n [ 3.48520330e+00  3.55213702e+00 -9.27104467e-02]\n [ 8.98810505e+00 -3.71906474e+00 -2.93193870e-01]\n [ 1.22630250e+01  1.52973880e+01 -1.02054995e-01]\n [ 2.98350154e+01 -1.79381284e+00 -6.50640206e-01]]\nInitial velocities (AU/day):\n [[ 4.87524241e-06 -7.05716139e-06 -4.57929038e-08]\n [-2.23216589e-02 -2.15720711e-02  2.85519283e-04]\n [ 2.03406835e-03 -2.02082863e-02 -3.94564043e-04]\n [-1.72300122e-02 -2.96772137e-03  6.38154172e-07]\n [ 1.42483227e-02 -1.57923621e-03 -3.82372338e-04]\n [-5.47097051e-03  5.64248731e-03  9.89618477e-05]\n [ 1.82201399e-03  5.14347040e-03 -1.61723649e-04]\n [-3.09761521e-03  2.27678190e-03  4.86042739e-05]\n [ 1.67653809e-04  3.15209870e-03 -6.87750693e-05]]\nMasses (M_sun):\n [1.00000000e+00 1.66012083e-07 2.44783829e-06 3.00348962e-06\n 3.22715608e-07 9.54791910e-04 2.85885670e-04 4.36624961e-05\n 5.15138377e-05]\nGravitational constant (AU^3 / day^2 / M_sun): 0.00029591220828411956\n</code></pre> You should also see the following plot:</p> <p></p>"},{"location":"5_steps_to_n_body_simulation/step1/#full-scripts","title":"Full scripts","text":"<p>The full scripts are available at <code>5_steps_to_n_body_simulation/python/</code>, or https://github.com/alvinng4/grav_sim/blob/main/5_steps_to_n_body_simulation/python/</p> step1.py (Click to expand) 5_steps_to_n_body_simulation/python/step1.py<pre><code>import common\n\nINITIAL_CONDITION = \"solar_system\"\n\n\ndef main():\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n    print(\"Number of particles:\", system.num_particles)\n    print(\"Initial positions (AU):\\n\", system.x)\n    print(\"Initial velocities (AU/day):\\n\", system.v)\n    print(\"Masses (M_sun):\\n\", system.m)\n    print(\"Gravitational constant (AU^3 / day^2 / M_sun):\", system.G)\n\n    # Plot the initial conditions\n    common.plot_initial_conditions(\n        system=system,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> common.py (Click to expand) 5_steps_to_n_body_simulation/python/common.py<pre><code>from typing import Tuple, List, Optional\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##### Step 1 #####\nclass System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n\ndef get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_PLUS_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n\n\ndef plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show()\n\n\n##### Step 2 #####\ndef acceleration(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\n##### Step 3 #####\ndef euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n\n\ndef print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n\n\n##### Step 4 #####\ndef compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n\n\ndef plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time\")\n    plt.show()\n\n\ndef euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n\n\ndef rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    # dx = 0.0\n    # dv = 0.0\n    # for stage in range(num_stages):\n    #     dx += weights[stage] * xk[stage]\n    #     dv += weights[stage] * vk[stage]\n\n    dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\n    dv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n\n\ndef leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n\n##### Step 5 #####\ndef print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n\n\n##### Extra #####\ndef set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre> <ol> <li> <p>Jet Propulsion Laboratory. Horizons system. 2024. Accessed: April 2024. URL: https://ssd.jpl.nasa.gov/horizons/.\u00a0\u21a9</p> </li> <li> <p>Ryan S. Park, William M. Folkner, James G. Williams, and Dale H. Boggs. The jpl planetary and lunar ephemerides de440 and de441. The Astronomical Journal, 161(3):105, feb 2021. doi:10.3847/1538-3881/abd414.\u00a0\u21a9</p> </li> </ol>"},{"location":"5_steps_to_n_body_simulation/step2/","title":"Step 2: Gravity","text":"<p>Welcome to step 2. This is the most important step \u2014 computing the gravitational acceleration. Turns out this is also the most expensive part in N-body simulation,  so we will spend some time on optimization.</p>"},{"location":"5_steps_to_n_body_simulation/step2/#newtons-law-of-gravitation","title":"Newton's law of gravitation","text":"<p>I believe most of you are familiar with Newton's law of gravitation</p> \\[     \\mathbf{F}_{ij} = m_{i} \\mathbf{a}_{ij} = \\frac{G m_i m_j}{r_{ij}^2} \\hat{r}_{ij}, \\] <p>where \\(\\mathbf{F}_{ij}\\) is the force on particle \\(i\\) due to particle \\(j\\), and \\(\\hat{r}_{ij}\\) is the unit vector pointing from particle \\(i\\) to particle \\(j\\). That is,</p> \\[     \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i, \\quad     \\hat{r}_{ij} = \\mathbf{r}_{ij} / r_{ij}. \\] <p>In practice, we are only interested in the acceleration. To compute the acceleration of particle \\(i \\in \\{1, \\dots, N\\}\\), we have</p> \\[     \\mathbf{a}_{i} = \\sum_{j \\neq i} \\frac{G m_j}{r_{ij}^3} \\mathbf{r}_{ij}, \\] <p>which can be easily done as this only involve simple vector operations.</p>"},{"location":"5_steps_to_n_body_simulation/step2/#implementation-1","title":"Implementation 1","text":"<p>Below shows our first naive implementation of the acceleration function. The outer loop \\(i\\) iterates over all particles, and the inner loop \\(j\\) iterates over all particles again to compute the acceleration between all pairs of particles. However, this implementation is very slow.</p> <pre><code>def acceleration_1(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    num_particles = system.num_particles\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Calculations\n    for i in range(num_particles):\n        for j in range(num_particles):\n            if i == j:\n                continue\n\n            R = x[j] - x[i]\n            a[i] += G * m[j] * R / (np.linalg.norm(R) ** 3)\n</code></pre> <p>Where is the return statement?</p> <p>Actually, there is no need to return the acceleration array <code>a</code> because we are modifying the memory in-place.</p>"},{"location":"5_steps_to_n_body_simulation/step2/#implementation-2","title":"Implementation 2","text":"<p>To optimize the code, we utilize the fact that the distance between particles \\(i\\) and \\(j\\) is the same:</p> \\[     \\mathbf{r}_{ij} = - \\mathbf{r}_{ji} \\implies r_{ij} = r_{ji}. \\] <p>Note</p> <p>In our notation, the lowercase, non-bold \\(r_{ij}\\) is the vector norm, which is always positive.</p> <p>This allows us to effectively reduce half of the distance calculations. (Calculating the distance is quite expensive as it involves the computation of <code>sqrt</code>.) The outer loop \\(i\\) still iterates over all particles, but the inner loop \\(j\\) only iterates from \\(i + 1\\) to \\(N\\). (Why? because all combinations of \\(i\\)  and \\(j \\leq i\\) has already been computed in the previous iterations. Therefore, we only need to care about \\(j &gt; i\\).)</p> <p>Tip</p> <p>If you want to rewrite this in C, this is the implementation you should use.</p> <pre><code>def acceleration_2(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    num_particles = system.num_particles\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Calculations\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            R = x[j] - x[i]\n            temp_value = G * R / (np.linalg.norm(R) ** 3)\n            a[i] += temp_value * m[j]\n            a[j] -= temp_value * m[i]\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step2/#implementation-3-advanced","title":"Implementation 3* (Advanced)","text":"<p>The above implementation is still quite slow because we are using Python loops to iterate over the particles. NumPy is (partly) implemented in C, which makes it much faster than Python operations. If we were able to avoid  Python loops completely, we can achieve a significant speedup. This can be done by vectorizing the code. Note that this would be quite difficult for beginners, but learning this could help you understand a lot about NumPy arrays.</p> <ol> <li> <p>We first compute a displacement matrix \\(\\mathbf{R}\\), where \\(\\mathbf{R}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i\\).     Therefore, it is a 3D array of shape \\((N, N, 3)\\), and the diagonal elements are all zero.     This is computed by broadcasting first \\(\\mathbf{r}\\) along the axis 0 (row) and      the second \\(\\mathbf{r}\\) along the axis 1 (column): <code>r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]</code></p> \\[     \\mathbf{R} =         \\begin{bmatrix}             \\mathbf{r}_1 - \\mathbf{r}_1 &amp; \\mathbf{r}_2 - \\mathbf{r}_1 &amp; \\cdots &amp; \\mathbf{r}_N - \\mathbf{r}_1 \\\\             \\mathbf{r}_1 - \\mathbf{r}_2 &amp; \\mathbf{r}_2 - \\mathbf{r}_2 &amp; \\cdots &amp; \\mathbf{r}_N - \\mathbf{r}_2 \\\\             \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\             \\mathbf{r}_1 - \\mathbf{r}_N &amp; \\mathbf{r}_2 - \\mathbf{r}_N &amp; \\cdots &amp; \\mathbf{r}_N - \\mathbf{r}_N         \\end{bmatrix} \\] </li> <li> <p>We compute the distance matrix \\(\\mathbf{R}_{\\mathrm{norm}}\\), which is a 2D array of      shape \\((N, N)\\). It is computed by taking the norm along the last axis with length 3     (<code>r_norm = np.linalg.norm(r_ij, axis=2)</code>).</p> </li> <li> <p>We compute \\(1 / \\mathbf{R}_\\text{norm}^3\\) (element-wise).     Because the diagonal elements are all zero, the division will produce     undefined values along the diagonal. Therefore, we want to silence the warnings from NumPy     and set the diagonal elements to zero.</p> <pre><code># Compute 1 / r^3\nwith np.errstate(divide='ignore', invalid='ignore'):\n    inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n# Set diagonal elements to 0 to avoid self-interaction\nnp.fill_diagonal(inv_r_cubed, 0.0)\n</code></pre> </li> <li> <p>We compute the acceleration by </p> </li> </ol> \\[     \\mathbf{a}_{i} = \\sum_{j \\neq i} \\frac{G m_j}{r_{ij}^3} \\mathbf{r}_{ij}, \\] <p>The last step can be done by using NumPy's broadcasting feature. The resulting acceleration array will be of shape \\((N, 3)\\). <pre><code>a[:] = G * np.sum(\n    r_ij * inv_r_cubed[:, :, np.newaxis] * m[:, np.newaxis, np.newaxis], axis=0\n)\n</code></pre></p> <p>This line of code is a bit complicated. Let us break it down:</p> <ul> <li>G is a constant, so it can be factored out of the summation.</li> <li>Ignore the last dimension with length 3 for now. We have <pre><code>a[:, 0] = G * np.sum(\n    r_ij[:, :, 0] * inv_r_cubed[:, :] * m[:, np.newaxis], axis=0\n)\n</code></pre> We are summing over the axis 0 (row), so the mass vector \\(\\mathbf{m}\\) needs to be broadcasted along the axis 1 (column) to \\(\\mathbf{M}\\) with the shape of \\((N, N)\\). We have</li> </ul> \\[     \\mathbf{M} =      \\begin{bmatrix}         m_1 &amp; m_2 &amp; \\cdots &amp; m_N \\\\         m_1 &amp; m_2 &amp; \\cdots &amp; m_N \\\\         \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\         m_1 &amp; m_2 &amp; \\cdots &amp; m_N     \\end{bmatrix}. \\] <p>The element-wise multiplication of \\(\\mathbf{M}\\) with \\(\\mathbf{R}\\) divided by \\(\\mathbf{R}_\\text{norm}^3\\) gives</p> \\[     \\begin{bmatrix}         0                              &amp; m_2 \\mathbf{x}_{12} / x_{12}^3 &amp; \\cdots &amp; m_N \\mathbf{x}_{1N} / x_{1N}^3 \\\\         m_1 \\mathbf{x}_{21} / x_{21}^3 &amp; 0                              &amp; \\cdots &amp; m_N \\mathbf{x}_{2N} / x_{2N}^3 \\\\         \\vdots                         &amp; \\vdots                         &amp; \\ddots &amp; \\vdots \\\\         m_1 \\mathbf{x}_{N1} / x_{N1}^3 &amp; m_2 \\mathbf{x}_{N2} / x_{N2}^3 &amp; \\cdots &amp; 0     \\end{bmatrix} \\] <p>We are summing along the axis 0 (row). For particle \\(i\\), we have</p> \\[     \\mathbf{a}_{i, 0} = G \\left[m_1 \\frac{\\mathbf{x}_{i1}}{x_{i1}^3} + m_2 \\frac{\\mathbf{x}_{i2}}{x_{i2}^3}     + \\cdots + 0 + \\cdots + m_N \\frac{\\mathbf{x}_{iN}}{x_{iN}^3} \\right]     = \\sum_{j \\neq i} \\frac{G m_j}{x_{ij}^3} \\mathbf{x}_{ij} \\] <p>This is exactly what we want! Now, to also include the last dimension with length 3, we simple add <code>np.newaxis</code> to the last axis. This gives us the vectorized version of the full acceleration function. Later, we will see in the benchmark that this is much faster than the previous implementations.</p> <pre><code>def acceleration_3(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide='ignore', invalid='ignore'):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.sum(\n        r_ij * inv_r_cubed[:, :, np.newaxis] * m[:, np.newaxis, np.newaxis], axis=0\n    )\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step2/#implementation-4-advanced","title":"Implementation 4* (Advanced)","text":"<p>In the last implementation, we are using <code>np.sum</code> and broadcasting to compute the acceleration. In NumPy, there is a faster method <code>np.einsum</code>. Therefore, in this implementation, we will replace the <code>np.sum</code> with <code>np.einsum</code>.</p> <p>In our original implementation, notice how the broadcasting is done: <pre><code>a[:] = G * np.sum(\n    r_ij * inv_r_cubed[:, :, np.newaxis] * m[:, np.newaxis, np.newaxis], axis=0\n)\n</code></pre></p> <p>Denote the axis 0, 1, and 2 as \\(i\\), \\(j\\), and \\(k\\) respectively.</p> <ul> <li><code>r_ij</code> is a 3D array multiplied without broadcasting \\(\\implies ijk\\).</li> <li><code>inv_r_cubed</code> is a 2D array multiplied with broadcasting along axis 2 \\(\\implies ij\\).</li> <li><code>m</code> is a 1D array multiplied with broadcasting along axis 1 and 2 \\(\\implies i\\).</li> </ul> <p>The final sum is done along axis 0 \\(\\implies ijk \\to jk\\).</p> <p>Using <code>np.einsum</code>, we can specify the indices to be summed over. The following line of code is equivalent to the original implementation:  <pre><code>a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n</code></pre></p> <p>Full implementation: <pre><code>def acceleration_4(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide='ignore', invalid='ignore'):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n</code></pre></p>"},{"location":"5_steps_to_n_body_simulation/step2/#benchmark","title":"Benchmark","text":"<p>To benchmark the performance, we will use the <code>timeit</code> module and  repeat each function 10000 times. We will take the mean with standard error = \\(\\sigma / \\sqrt{N_\\text{repeats}}\\).</p> step2.py<pre><code>import math\nimport timeit\n\nimport numpy as np\n\nimport common\n\nINITIAL_CONDITION = \"solar_system\"\nNUM_REPEATS = 10000\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, _, _, _ = common.get_initial_conditions(INITIAL_CONDITION)\n\n    ### Benchmark ###\n    print(\"Benchmarking with 10000 repetitions\")\n    print()\n\n    # Allocate memory\n    a = np.zeros((system.num_particles, 3))\n\n    # Acceleration 1\n    run_time_1 = np.zeros(NUM_REPEATS)\n    for i in range(NUM_REPEATS):\n        start = timeit.default_timer()\n        acceleration_1(a, system)\n        end = timeit.default_timer()\n        run_time_1[i] = end - start\n    print(\n        f\"acceleration_1: {run_time_1.mean():.6f} +- {run_time_1.std(ddof=1) / math.sqrt(NUM_REPEATS):.3g} seconds\"\n    )\n\n\n    ... # (Repeat for acceleration_2, 3, and 4)\n</code></pre> <p>Finally, we do a error check by comparing the results from the first naive implementation.  <pre><code>def main() -&gt; None:\n    ...\n    # Check for relative errors\n    ### Error check ###\n    acceleration_1(a, system)\n    a_1 = a.copy()\n    acceleration_2(a, system)\n    a_2 = a.copy()\n    acceleration_3(a, system)\n    a_3 = a.copy()\n    acceleration_4(a, system)\n    a_4 = a.copy()\n\n    rel_error_2 = np.sum(np.abs(a_1 - a_2)) / np.sum(a_1)\n    rel_error_3 = np.sum(np.abs(a_1 - a_3)) / np.sum(a_1)\n    rel_error_4 = np.sum(np.abs(a_1 - a_4)) / np.sum(a_1)\n\n    print()\n    print(\"Error check: (relative difference from acceleration_1)\")\n    print(f\"acceleration_2: {rel_error_2:.3g}\")\n    print(f\"acceleration_3: {rel_error_3:.3g}\")\n    print(f\"acceleration_4: {rel_error_4:.3g}\")\n</code></pre></p> <p>The results are as follows: <pre><code>Benchmarking with 10000 repetitions\n\nacceleration_1: 0.000203 +- 8.08e-08 seconds\nacceleration_2: 0.000164 +- 1.25e-06 seconds\nacceleration_3: 0.000013 +- 2.21e-08 seconds\nacceleration_4: 0.000012 +- 1.38e-08 seconds\n\nError check: (relative difference from acceleration_1)\nacceleration_2: 0\nacceleration_3: 1.31e-15\nacceleration_4: 1.31e-15\n</code></pre> The vectorized implementation is about 10 - 20 times faster than the naive implementation! As for the error check, the small relative difference is likely due to rounding errors, which could be ignored. (For 64-bit floating point numbers, the machine epsilon is about \\(10^{-16}\\).) By the way, since <code>acceleration_4</code> is the fastest, we put it into <code>common.py</code>.</p> <p>Performance in C</p> <p>By the way, if you are interested in the performance in C, below is a benchmark using our <code>grav_sim</code> package: <pre><code>Test 0:    Method: Pairwise\n    Number of times: 10000000\n    Avg time: 2.06e-07 (+- 1.30e-10) s\n</code></pre> This is about 58 times faster than the vectorized NumPy implementation. But beware that this may not be totally accurate as the run time for each run is too short.</p>"},{"location":"5_steps_to_n_body_simulation/step2/#full-scripts","title":"Full scripts","text":"<p>The full scripts are available at <code>5_steps_to_n_body_simulation/python/</code>, or https://github.com/alvinng4/grav_sim/blob/main/5_steps_to_n_body_simulation/python/</p> step2.py (Click to expand) 5_steps_to_n_body_simulation/python/step2.py<pre><code>import math\nimport timeit\n\nimport numpy as np\n\nimport common\n\nINITIAL_CONDITION = \"solar_system\"\nNUM_REPEATS = 10000\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, _, _, _ = common.get_initial_conditions(INITIAL_CONDITION)\n\n    ### Benchmark ###\n    print(\"Benchmarking with 10000 repetitions\")\n    print()\n\n    # Allocate memory\n    a = np.zeros((system.num_particles, 3))\n\n    # Acceleration 1\n    run_time_1 = np.zeros(NUM_REPEATS)\n    for i in range(NUM_REPEATS):\n        start = timeit.default_timer()\n        acceleration_1(a, system)\n        end = timeit.default_timer()\n        run_time_1[i] = end - start\n    print(\n        f\"acceleration_1: {run_time_1.mean():.6f} +- {run_time_1.std(ddof=1) / math.sqrt(NUM_REPEATS):.3g} seconds\"\n    )\n\n    # Acceleration 2\n    run_time_2 = np.zeros(NUM_REPEATS)\n    for i in range(NUM_REPEATS):\n        start = timeit.default_timer()\n        acceleration_2(a, system)\n        end = timeit.default_timer()\n        run_time_2[i] = end - start\n    print(\n        f\"acceleration_2: {run_time_2.mean():.6f} +- {run_time_2.std(ddof=1) / math.sqrt(NUM_REPEATS):.3g} seconds\"\n    )\n\n    # Acceleration 3\n    run_time_3 = np.zeros(NUM_REPEATS)\n    for i in range(NUM_REPEATS):\n        start = timeit.default_timer()\n        acceleration_3(a, system)\n        end = timeit.default_timer()\n        run_time_3[i] = end - start\n    print(\n        f\"acceleration_3: {run_time_3.mean():.6f} +- {run_time_3.std(ddof=1) / math.sqrt(NUM_REPEATS):.3g} seconds\"\n    )\n\n    # Acceleration 4\n    run_time_4 = np.zeros(NUM_REPEATS)\n    for i in range(NUM_REPEATS):\n        start = timeit.default_timer()\n        acceleration_4(a, system)\n        end = timeit.default_timer()\n        run_time_4[i] = end - start\n    print(\n        f\"acceleration_4: {run_time_4.mean():.6f} +- {run_time_4.std(ddof=1) / math.sqrt(NUM_REPEATS):.3g} seconds\"\n    )\n\n    ### Error check ###\n    acceleration_1(a, system)\n    a_1 = a.copy()\n    acceleration_2(a, system)\n    a_2 = a.copy()\n    acceleration_3(a, system)\n    a_3 = a.copy()\n    acceleration_4(a, system)\n    a_4 = a.copy()\n\n    rel_error_2 = np.sum(np.abs(a_1 - a_2)) / np.sum(a_1)\n    rel_error_3 = np.sum(np.abs(a_1 - a_3)) / np.sum(a_1)\n    rel_error_4 = np.sum(np.abs(a_1 - a_4)) / np.sum(a_1)\n\n    print()\n    print(\"Error check: (relative difference from acceleration_1)\")\n    print(f\"acceleration_2: {rel_error_2:.3g}\")\n    print(f\"acceleration_3: {rel_error_3:.3g}\")\n    print(f\"acceleration_4: {rel_error_4:.3g}\")\n\n\ndef acceleration_1(\n    a: np.ndarray,\n    system: common.System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    num_particles = system.num_particles\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Calculations\n    for i in range(num_particles):\n        for j in range(num_particles):\n            if i == j:\n                continue\n\n            R = x[j] - x[i]\n            a[i] += G * m[j] * R / (np.linalg.norm(R) ** 3)\n\n\ndef acceleration_2(\n    a: np.ndarray,\n    system: common.System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    num_particles = system.num_particles\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Calculations\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            R = x[j] - x[i]\n            temp_value = G * R / (np.linalg.norm(R) ** 3)\n            a[i] += temp_value * m[j]\n            a[j] -= temp_value * m[i]\n\n\ndef acceleration_3(\n    a: np.ndarray,\n    system: common.System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.sum(\n        r_ij * inv_r_cubed[:, :, np.newaxis] * m[:, np.newaxis, np.newaxis], axis=0\n    )\n\n\ndef acceleration_4(\n    a: np.ndarray,\n    system: common.System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> common.py (Click to expand) 5_steps_to_n_body_simulation/python/common.py<pre><code>from typing import Tuple, List, Optional\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##### Step 1 #####\nclass System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n\ndef get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_PLUS_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n\n\ndef plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show()\n\n\n##### Step 2 #####\ndef acceleration(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\n##### Step 3 #####\ndef euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n\n\ndef print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n\n\n##### Step 4 #####\ndef compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n\n\ndef plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time\")\n    plt.show()\n\n\ndef euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n\n\ndef rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    # dx = 0.0\n    # dv = 0.0\n    # for stage in range(num_stages):\n    #     dx += weights[stage] * xk[stage]\n    #     dv += weights[stage] * vk[stage]\n\n    dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\n    dv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n\n\ndef leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n\n##### Step 5 #####\ndef print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n\n\n##### Extra #####\ndef set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step3/","title":"Step 3: Your first N-body program","text":"<p>In this step, we will write our first N-body program. We have set up the initial conditions in step 1 and  the acceleration function in step 2. Now, we will need to solve the equations of motion for the particles. For Newtonian mechanics, we have the following coupled equations:</p> \\[     \\frac{\\mathrm{d}\\textbf{r}}{\\mathrm{d}t}      = \\textbf{v}, \\quad     \\frac{\\mathrm{d}\\textbf{v}}{\\mathrm{d}t}      = \\textbf{a}(\\textbf{r}) \\left( = \\frac{\\textbf{F}(\\textbf{r})}{m} \\right). \\] <p>They are ordinary differential equations (ODEs). To solve them, we will need a ODE solver. </p>"},{"location":"5_steps_to_n_body_simulation/step3/#euler-method","title":"Euler method","text":"<p>The simplest ODE solver is the Euler method, where the update is approximated as</p> \\[     \\Delta \\mathbf{r} = \\mathbf{v} \\Delta t, \\quad      \\Delta \\mathbf{v} = \\mathbf{a}(\\mathbf{r}) \\Delta t, \\] <p>where \\(\\Delta t\\) is the time step. By Taylor expansion, we can see that this is a first-order approximation,</p> \\[     x(t + \\Delta t) = x(t) + x'(t) \\Delta t + \\mathcal{O}(\\Delta t^2), \\] <p>where \\(\\mathcal{O}(\\Delta t^2)\\) is the local truncation error if \\(\\Delta t \\to 0\\).  Because the total number of steps scales with \\(1/\\Delta t\\), the global error is </p> \\[     \\text{global error} =     \\text{number of steps} \\times \\text{error per step}     \\propto \\frac{1}{\\Delta t} \\mathcal{O}(\\Delta t^2) = \\mathcal{O}(\\Delta t). \\] <p>If you are not familiar with the big-O notation, you can think of it as the error is being bounded by a polynomial in the order  of \\(\\Delta t\\).</p> <p>Implementing the Euler integrator is very easy. With</p> \\[     \\mathbf{r}_{n + 1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t, \\quad     \\mathbf{v}_{n + 1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{r}_{n}) \\Delta t, \\] <p>we have the following code:</p> common.py<pre><code>def euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n</code></pre> <p>Now, we will build all the components we need for our N-body program.</p>"},{"location":"5_steps_to_n_body_simulation/step3/#solution-output","title":"Solution output","text":"<p>We will need a way to store the solution. A naive way is to store the system at every time step or every few time steps. However, this is a terrible idea because the output size will depends on your choice of time step. A better way is to store the solution at regular intervals. In our simulation, we will use a output interval of 0.1 years. For a simulation of 200 years, we will have 2000 time steps.</p> <p>Tip</p> <p>For the Solar system, we only have 9 particles and it takes very little memory to store. So, you don't need to worry too much about the solution size.  Just be careful and don't set the output interval too small.</p> <p>Before the simulation, we will need to set up the output array and store the initial conditions. step3.py<pre><code>OUTPUT_INTERVAL = 0.1 * 365.24  # years to days\n\ndef main() -&gt; None:\n    ...\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    output_count = 1\n</code></pre></p> <p>Also, we need to calculate the output time. step3.py<pre><code>def main() -&gt; None:\n    ...\n    for i in range(NUM_STEPS):\n        ...\n        if current_time &gt;= next_output_time:\n            sol_x[output_count] = system.x\n            sol_v[output_count] = system.v\n            sol_t[output_count] = current_time\n\n            output_count += 1\n            next_output_time = output_count * OUTPUT_INTERVAL\n</code></pre></p> <p>Finally, we resize the arrays to the actual size. step3.py<pre><code>def main() -&gt; None:\n    ...\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n</code></pre></p>"},{"location":"5_steps_to_n_body_simulation/step3/#putting-it-all-together","title":"Putting it all together","text":"<p>Let's put everything together. We first need to setup the simulation parameters. step3.py<pre><code># Default units is AU, days, and M_sun\nTF = 200.0 * 365.24  # years to days\nDT = 1.0 \nOUTPUT_INTERVAL = 0.1 * 365.24  # years to days\nNUM_STEPS = int(TF / DT)\n</code></pre></p> <p>Before running the simulation, it is a good idea to print the simulation information. common.py<pre><code>def print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n</code></pre></p> <p>Finally, we have the main function that runs the main simulation loop. I have added a timer to measure the runtime, and a print statement to show the simulation progress every time we save a solution. The <code>\\r</code> at the end of the print statement should overwrite the previous line, but you can remove the print statement if it is spamming your terminal. step3.py<pre><code>def main() -&gt; None:\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n\n    # Initialize memory\n    a = np.zeros((system.num_particles, 3))\n\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    output_count = 1\n\n    # Launch simulation\n    common.print_simulation_info_fixed_step_size(\n        system, TF, DT, NUM_STEPS, OUTPUT_INTERVAL, sol_size\n    )\n    next_output_time = output_count * OUTPUT_INTERVAL\n    start = timeit.default_timer()\n    for i in range(NUM_STEPS):\n        common.euler(a, system, DT)\n\n        current_time = i * DT\n        if current_time &gt;= next_output_time:\n            sol_x[output_count] = system.x\n            sol_v[output_count] = system.v\n            sol_t[output_count] = current_time\n\n            output_count += 1\n            next_output_time = output_count * OUTPUT_INTERVAL\n\n            print(f\"Current time: {current_time:.2f} days\", end=\"\\r\")\n\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n\n    end = timeit.default_timer()\n\n    print()\n    print(f\"Done! Runtime: {end - start:.3g} seconds, Solution size: {output_count}\")\n</code></pre></p> <p>You should see the following output:</p> <pre><code>----------------------------------------------------------\nSimulation Info:\nnum_particles: 9\nG: 0.00029591220828411956\ntf: 73048.0 days (Actual tf = dt * num_steps = 73048.0 days)\ndt: 1.0 days\nNum_steps: 73048\n\nOutput interval: 36.524 days\nEstimated solution size: 2001\n----------------------------------------------------------\nCurrent time: 73012.00 days\nDone! Runtime: 1.1 seconds, Solution size: 2000\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step3/#plotting-the-trajectory","title":"Plotting the trajectory","text":"<p>To visualize the trajectory, we have the following function. Notice that we  have one <code>ax.plot</code> and one <code>ax.scatter</code> calls. The first one is to plot the  trajectory, and the second one is to plot the final position with a circle marker.</p> common.py<pre><code>def plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n</code></pre> <p>Then, we add the function call to the end of the main function. step3.py<pre><code>    common.plot_trajectory(\n        sol_x=sol_x,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n</code></pre></p> <p>You should see the following plot:</p> <p></p> <p>Congrats!  You have just written your first N-body simulation program! However, we can see that the results are not very accurate, especially for those inner planets. (Mercury has drifted to a orbit beyond Saturn within 200 years!)</p> <p>In the next step, we will implement some higher-order integrators to improve the accuracy.</p>"},{"location":"5_steps_to_n_body_simulation/step3/#full-scripts","title":"Full scripts","text":"<p>The full scripts are available at <code>5_steps_to_n_body_simulation/python/</code>, or https://github.com/alvinng4/grav_sim/blob/main/5_steps_to_n_body_simulation/python/</p> step3.py (Click to expand) 5_steps_to_n_body_simulation/python/step3.py<pre><code>import timeit\n\nimport numpy as np\n\nimport common\n\nINITIAL_CONDITION = \"solar_system\"\n\n# Default units is AU, days, and M_sun\nTF = 200.0 * 365.24  # years to days\nDT = 1.0\nOUTPUT_INTERVAL = 0.1 * 365.24  # years to days\nNUM_STEPS = int(TF / DT)\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n\n    # Initialize memory\n    a = np.zeros((system.num_particles, 3))\n\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    output_count = 1\n\n    # Launch simulation\n    common.print_simulation_info_fixed_step_size(\n        system, TF, DT, NUM_STEPS, OUTPUT_INTERVAL, sol_size\n    )\n    next_output_time = output_count * OUTPUT_INTERVAL\n    start = timeit.default_timer()\n    for i in range(NUM_STEPS):\n        common.euler(a, system, DT)\n\n        current_time = i * DT\n        if current_time &gt;= next_output_time:\n            sol_x[output_count] = system.x\n            sol_v[output_count] = system.v\n            sol_t[output_count] = current_time\n\n            output_count += 1\n            next_output_time = output_count * OUTPUT_INTERVAL\n\n            print(f\"Current time: {current_time:.2f} days\", end=\"\\r\")\n\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n\n    end = timeit.default_timer()\n\n    print()\n    print(f\"Done! Runtime: {end - start:.3g} seconds, Solution size: {output_count}\")\n    common.plot_trajectory(\n        sol_x=sol_x,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> common.py (Click to expand) 5_steps_to_n_body_simulation/python/common.py<pre><code>from typing import Tuple, List, Optional\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##### Step 1 #####\nclass System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n\ndef get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_PLUS_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n\n\ndef plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show()\n\n\n##### Step 2 #####\ndef acceleration(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\n##### Step 3 #####\ndef euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n\n\ndef print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n\n\n##### Step 4 #####\ndef compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n\n\ndef plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time\")\n    plt.show()\n\n\ndef euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n\n\ndef rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    # dx = 0.0\n    # dv = 0.0\n    # for stage in range(num_stages):\n    #     dx += weights[stage] * xk[stage]\n    #     dv += weights[stage] * vk[stage]\n\n    dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\n    dv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n\n\ndef leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n\n##### Step 5 #####\ndef print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n\n\n##### Extra #####\ndef set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step4/","title":"Step 4: Higher-order algorithms","text":"<p>In the last step, we implemented a simple Euler method to integrate the solar system for 200 years. The poor accuracy is expected, because we used a simple first order algorithm with global error \\(\\mathcal{O}(\\Delta t)\\). In this step, we will implement 3 new algorithms to improve our simulation.</p>"},{"location":"5_steps_to_n_body_simulation/step4/#relative-energy-error","title":"Relative energy error","text":"<p>Before implementing new algorithms, we need a way to measure the accuracy of the simulation. By conservation of energy, we can assume that better algorithms will have a better conservation on the total energy of the system. Computing the total energy is trivial. All we need is the solution array.</p> \\[     \\text{Total Energy}      = \\overset{\\text{KE}}{\\overbrace{\\sum_{i=1}^{N} \\frac{1}{2} m_i v_i^2}}      - \\overset{\\text{PE}}{\\overbrace{\\sum_{i=1}^{N} \\sum_{j = i + 1}^{N} \\frac{G m_i m_j}{r_{ij}}}}. \\] <p>Then, we can compute the relative energy error as</p> \\[     \\text{Relative Energy Error} = \\frac{|\\text{Energy} - \\text{Initial Energy}|}{\\text{Initial Energy}}. \\] <p>This gives the following code:</p> common.py<pre><code>def compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n</code></pre> <p>Tip</p> <p>If you found it too slow, you are encouraged to vectorize it, just like what we did in step 2</p> <p>Now, we can plot the relative energy error with the following code, where y-axis is in log scale.</p> common.py<pre><code>def plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time step\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time Step\")\n    plt.show()\n</code></pre> <p>We copy <code>step3.py</code> to <code>step4.py</code> and add the following code to the end of the <code>main</code> function:</p> step4.py<pre><code>def main() -&gt; None:\n    ...\n    # Compute and plot relative energy error\n    rel_energy_error = compute_rel_energy_error(sol_x, sol_v, system)\n    print(f\"Relative energy error: {rel_energy_error[-1]:.3g}\")\n    plot_rel_energy_error(rel_energy_error, sol_t / 365.24)\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step4/#euler-method","title":"Euler method","text":"<p>Let us run the simulation again. We have the following plots:</p> <p> </p> <p>The final relative energy error \\(\\sim 10^{-1}\\), which is not very good.</p>"},{"location":"5_steps_to_n_body_simulation/step4/#euler-cromer-method","title":"Euler-Cromer method","text":"<p>Now, we begin implementing our first new algorithm. The Euler-Cromer method, also known as semi-implicit Euler method, is a simple modification of the Euler method,</p> \\[     \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{r}_n) \\Delta t, \\] \\[     \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_{n+1} \\Delta t. \\] <p>Notice that the position update is done using the updated velocity \\(\\mathbf{v}_{n+1}\\) instead of \\(\\mathbf{v}_n\\). Therefore, it is an first order semi-implicit method. Although the global error is still \\(\\mathcal{O}(\\Delta t)\\), it is a symplectic method, which implies that the energy error over time is bounded. This is a very useful property for long time-scale simulations. We have the following code:</p> common.py<pre><code>def euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n</code></pre> <p>Running the simulation again, we have the following plots:</p> <p> </p> <p>The trajectory looks a lot better than the Euler method! Also, the relative energy error is bounded at \\(\\sim 10^{-4}\\). This provides long term stability for the simulation.</p> <p>Energy conservation \\(\\iff\\) Higher accuracy?</p> <p>Although it seems like energy conservation implies higher accuracy, this is not neccessarily true. Recall that the global error for Euler-Cromer method is still \\(\\mathcal{O}(\\Delta t)\\), even though its energy error is bounded over time.  Therefore, we can only state the opposite direction: Higher accuracy \\(\\implies\\) Energy conservation.</p>"},{"location":"5_steps_to_n_body_simulation/step4/#runge-kutta-method","title":"Runge-Kutta method","text":"<p>The Runge-Kutta method is a family of ODE solvers. First, let us look at a  second order variation called the midpoint method. </p> <ul> <li> <p>In the Euler method, we are using the slope evaluated at the beginning of the interval to update the position and velocity.</p> </li> <li> <p>In the Euler-Cromer method, for the position update, we are using the slope evaluated at the end instead.</p> </li> </ul> <p>What about using the slope evaluated at the center of the interval? We can approximate the position and velocity at the midpoint using one Euler step, then perform the updates using the midpoint values. This gives us the following updates:</p> \\[     x_{n+1} = x_n + f\\left(t_n + \\frac{1}{2} \\Delta t, x + \\frac{1}{2} f(t_n) \\Delta t \\right) \\Delta t. \\] <p>Using a more general notation, we can write the midpoint method as</p> \\[ \\begin{aligned}     k_1 &amp;= f(t_n, x_n), \\\\     k_2 &amp;= f\\left(t_n + \\frac{1}{2} \\Delta t, x_n + \\frac{1}{2} k_1 \\Delta t \\right), \\\\     x_{n+1} &amp;= x_n + k_2 \\Delta t + \\mathcal{O}(\\Delta t^3). \\end{aligned} \\] <p>A simple taylor expansion will shows that the local truncation error is indeed \\(\\mathcal{O}(\\Delta t^3)\\), which means that it is a second order method. A more commonly used Runge-Kutta method is the 4th order Runge-Kutta method (RK4), which provides a good balance between accuracy and computational cost. It is given by</p> \\[ \\begin{aligned}     k_1 &amp;= f(t_n, x_n), \\\\     k_2 &amp;= f\\left(t_n + \\frac{1}{2} \\Delta t, x_n + \\frac{1}{2} k_1 \\Delta t \\right), \\\\     k_3 &amp;= f\\left(t_n + \\frac{1}{2} \\Delta t, x_n + \\frac{1}{2} k_2 \\Delta t \\right), \\\\     k_4 &amp;= f(t_n + \\Delta t, x_n + k_3 \\Delta t), \\\\     x_{n+1} &amp;= x_n + \\frac{1}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\Delta t + \\mathcal{O}(\\Delta t^5). \\end{aligned} \\] <p>In our code, we can write out the computation of each term explicitly. However, I prefer a more general approach by defining the <code>coeff</code> and <code>weights</code> arrays instead. The <code>coeff</code> array is given as</p> \\[     \\text{coeff} = \\begin{bmatrix}         1/2, 1/2, 1     \\end{bmatrix} \\] <p>for the computation of \\(k_2\\), \\(k_3\\) and \\(k_4\\). The <code>weights</code> array is given as</p> \\[     \\text{weights} = \\begin{bmatrix}         1/6, 1/3, 1/3, 1/6     \\end{bmatrix} \\] <p>for the final update. The code is given as follows:</p> common.py<pre><code>def rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    dx = 0.0\n    dv = 0.0\n    for stage in range(num_stages):\n        dx += weights[stage] * xk[stage]\n        dv += weights[stage] * vk[stage]\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n</code></pre> <p>Tip</p> <p>The final loop can be vectorized to improve performance: <pre><code>dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\ndv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n</code></pre></p> <p>Let's run the simulation again. We only show the relative energy error  plot:</p> <p></p> <p>The final error is in the order of \\(10^{-6}\\), which is quite nice. However, the error is growing over time, so this may not be a good choice for long term simulations.</p>"},{"location":"5_steps_to_n_body_simulation/step4/#leapfrog-method","title":"Leapfrog method","text":"<p>Our final algorithm is the leapfrog method, which is a second-order symplectic method. Similar to the Euler-Cromer method, it conserves energy over time. We will implement the  Kick-Drift-Kick (KDK) variant, which is given by a velocity kick for half time step,</p> \\[     \\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_n) \\Delta t, \\] <p>a position drift for a full time step,</p> \\[     \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_{n+1/2} \\Delta t, \\] <p>and a final velocity kick for half time step,</p> \\[     \\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_{n+1}) \\Delta t. \\] <p>Tip</p> <p>For optimization, you can combine the final velocity kick from the last time step with the first velocity kick. However, you need to be careful because now the velocity and position is not synchronized. There is also a synchronized version of the leapfrog method called the velocity Verlet method.</p> <p>The implementation is simple:</p> <pre><code>def leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n</code></pre> <p>Running the simulation again, we have the relative energy error plot:</p> <p></p> <p>The relative energy error is bounded at \\(\\sim 10^{-6}\\), which is better than the Euler-Cromer method!</p>"},{"location":"5_steps_to_n_body_simulation/step4/#which-algorithm-should-i-choose","title":"Which algorithm should I choose?","text":"<p>To choose between RK4 and LeapFrog, below are some factors that you may consider:</p> <ul> <li>Time scale: If you are simulating a long time scale, LeapFrog should be better as it conserves energy.</li> <li>Accuracy: If accuracy matters to you, then RK4 is a better choice since it is higher order.</li> <li>Computational cost:     RK4 is very expensive as it requires 4 acceleration evaluations per step.     In contrast, LeapFrog only requires 1 acceleration evaluation although it is second order.</li> <li> <p>Experiment:     If you are not sure which one to choose, you can always experiment and compare the results.     Below is a relative energy error plot I made for the solar system simulation using both RK4      and LeapFrog. I chose two very small dt while ensuring that the runtime is the same for both methods.     In terms of the results, seems like RK4 is better in this case, but note that I used some techniques     to remove the rounding error. (See Reducing round off error)</p> <p></p> </li> </ul>"},{"location":"5_steps_to_n_body_simulation/step4/#summary","title":"Summary","text":"<p>In this step, we have implemented 3 new algorithms: Euler-Cromer, RK4 and Leapfrog. RK4 and Leapfrog are both very popular algorithms for N-body simulations. All algorithms we implemented so far are fixed time step methods, which may not be very flexible for chaotic systems with close encounters. It is also a headache to tune the time step. In the next step, we will implement an adaptive time-stepping method which uses a tolerance parameter to control the time step instead.</p>"},{"location":"5_steps_to_n_body_simulation/step4/#full-scripts","title":"Full scripts","text":"<p>The full scripts are available at <code>5_steps_to_n_body_simulation/python/</code>, or https://github.com/alvinng4/grav_sim/blob/main/5_steps_to_n_body_simulation/python/</p> step4.py (Click to expand) 5_steps_to_n_body_simulation/python/step4.py<pre><code>import timeit\n\nimport numpy as np\n\nimport common\n\nINTEGRATOR = common.leapfrog\nINITIAL_CONDITION = \"solar_system\"\n\n# Default units is AU, days, and M_sun\nTF = 200.0 * 365.24  # years to days\nDT = 1.0\nOUTPUT_INTERVAL = 0.1 * 365.24  # years to days\nNUM_STEPS = int(TF / DT)\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n\n    # Initialize memory\n    a = np.zeros((system.num_particles, 3))\n\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    output_count = 1\n\n    # Launch simulation\n    common.print_simulation_info_fixed_step_size(\n        system, TF, DT, NUM_STEPS, OUTPUT_INTERVAL, sol_size\n    )\n    next_output_time = output_count * OUTPUT_INTERVAL\n    start = timeit.default_timer()\n    for i in range(NUM_STEPS):\n        INTEGRATOR(a, system, DT)\n\n        current_time = i * DT\n        if current_time &gt;= next_output_time:\n            sol_x[output_count] = system.x\n            sol_v[output_count] = system.v\n            sol_t[output_count] = current_time\n\n            output_count += 1\n            next_output_time = output_count * OUTPUT_INTERVAL\n\n            print(f\"Current time: {current_time:.2f} days\", end=\"\\r\")\n\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n\n    end = timeit.default_timer()\n\n    print()\n    print(f\"Done! Runtime: {end - start:.3g} seconds, Solution size: {output_count}\")\n    common.plot_trajectory(\n        sol_x=sol_x,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n\n    # Compute and plot relative energy error\n    rel_energy_error = common.compute_rel_energy_error(sol_x, sol_v, system)\n    print(f\"Relative energy error: {rel_energy_error[-1]:.3g}\")\n    common.plot_rel_energy_error(rel_energy_error, sol_t / 365.24)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> common.py (Click to expand) 5_steps_to_n_body_simulation/python/common.py<pre><code>from typing import Tuple, List, Optional\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##### Step 1 #####\nclass System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n\ndef get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_PLUS_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n\n\ndef plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show()\n\n\n##### Step 2 #####\ndef acceleration(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\n##### Step 3 #####\ndef euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n\n\ndef print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n\n\n##### Step 4 #####\ndef compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n\n\ndef plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time\")\n    plt.show()\n\n\ndef euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n\n\ndef rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    # dx = 0.0\n    # dv = 0.0\n    # for stage in range(num_stages):\n    #     dx += weights[stage] * xk[stage]\n    #     dv += weights[stage] * vk[stage]\n\n    dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\n    dv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n\n\ndef leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n\n##### Step 5 #####\ndef print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n\n\n##### Extra #####\ndef set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step5/","title":"Step 5: Adaptive time-stepping","text":"<p>In this step, we will implement an adaptive time-stepping integrator  Runge-Kutta-Fehlberg (RKF) method, which belongs to the same family  to the RK4 method we implemented in the previous step.</p>"},{"location":"5_steps_to_n_body_simulation/step5/#rkf45-method","title":"RKF4(5) method","text":"<p>To achieve adaptive time-stepping, we need some way to determine the  error of each time step in order to adjust the time step accordingly. For RKF4(5), we have a fourth-order method that is used for the actual update</p> \\[     x_{n + 1}      = x_n     + \\left( \\frac{25}{216} k_1      + \\frac{1408}{2565} k_3     + \\frac{2197}{4104} k_4     - \\frac{1}{5} k_5 \\right) \\Delta t, \\] <p>and a fifth-order method to determine the error</p> \\[     \\tilde{x}_{n + 1}      = x_n     + \\left( \\frac{16}{135} k_1      + \\frac{6656}{12825} k_3     + \\frac{28561}{56430} k_4     - \\frac{9}{50} k_5     + \\frac{2}{55} k_6 \\right) \\Delta t. \\] <p>The difference between these two methods can gives us an error estimation. Since the \\(k\\) between both methods mostly overlaps, we  are able to obtain an error estimation with a very small additional cost. They are given as follows:</p> \\[     \\begin{aligned}         k_1 &amp;= f(t_n, x_n), \\\\         k_2 &amp;= f\\left(t_n + \\frac{1}{4} \\Delta t, x_n + \\frac{1}{4} k_1 \\Delta t\\right), \\\\         k_3 &amp;= f\\left(t_n + \\frac{3}{8} \\Delta t, x_n + \\left(\\frac{3}{32} k_1 + \\frac{9}{32} k_2 \\right) \\Delta t \\right), \\\\         k_4 &amp;= f\\left(t_n + \\frac{12}{13} \\Delta t, x_n + \\left(\\frac{1932}{2197} k_1 - \\frac{7200}{2197} k_2 + \\frac{7296}{2197} k_3\\right) \\Delta t\\right), \\\\         k_5 &amp;= f\\left(t_n + \\Delta t, x_n + \\left(\\frac{439}{216} k_1 - 8 k_2 + \\frac{3680}{513} k_3 - \\frac{845}{4104} k_4\\right) \\Delta t\\right), \\\\         k_6 &amp;= f\\left(t_n + \\frac{1}{2} \\Delta t, x_n + \\left(- \\frac{8}{27} k_1 + 2 k_2 - \\frac{3544}{2565} k_3 + \\frac{1859}{4104} k_4 - \\frac{11}{40} k_5\\right) \\Delta t\\right).     \\end{aligned} \\] <p>This gives the following code:</p> <pre><code>    # RKF4(5) coefficients\n    coeff = np.array((\n        [1.0 / 4.0, 0.0, 0.0, 0.0, 0.0],\n        [3.0 / 32.0, 9.0 / 32.0, 0.0, 0.0, 0.0],\n        [1932.0 / 2197.0, -7200.0 / 2197.0, 7296.0 / 2197.0, 0.0, 0.0],\n        [439.0 / 216.0, -8.0, 3680.0 / 513.0, -845.0 / 4104.0, 0.0],\n        [-8.0 / 27.0, 2.0, -3544.0 / 2565.0, 1859.0 / 4104.0, -11.0 / 40.0],\n    ))\n    weights = np.array(\n        [25.0 / 216.0, 0.0, 1408.0 / 2565.0, 2197.0 / 4104.0, -1.0 / 5.0, 0.0]\n    )\n    weights_test = np.array(\n        [\n            16.0 / 135.0,\n            0.0,\n            6656.0 / 12825.0,\n            28561.0 / 56430.0,\n            -9.0 / 50.0,\n            2.0 / 55.0,\n        ]\n    )\n    min_power = 4\n    num_stages = len(weights)\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step5/#error-estimation","title":"Error estimation","text":"<p>First, let us define a tolerance parameter \\(\\varepsilon\\). This is a user-defined parameter to control the time step (Smaller \\(\\varepsilon\\) means smaller time step). Now, we define a \\(\\Delta x'\\) as the difference between the two RK methods (we call it <code>error_estimation_delta</code> in our code)</p> \\[     \\Delta x' = \\Delta x - \\Delta \\tilde{x}. \\] <pre><code># Calculate x_1, v_1 and also delta x, delta v for error estimation\nx_1[:] = system.x\nv_1[:] = system.v\nerror_estimation_delta_x.fill(0.0)\nerror_estimation_delta_v.fill(0.0)\nfor stage in range(num_stages):\n    x_1[:] += dt * weights[stage] * xk[stage]\n    v_1[:] += dt * weights[stage] * vk[stage]\n    error_estimation_delta_x[:] += (\n        dt * (weights[stage] - weights_test[stage]) * xk[stage]\n    )\n    error_estimation_delta_v[:] += (\n        dt * (weights[stage] - weights_test[stage]) * vk[stage]\n    )\n</code></pre> <p>Then, we compute \\(\\mathbf{s}\\) as follows (we call it <code>tolerance_scale</code> in our code):</p> \\[     \\mathbf{s}_{i} = \\varepsilon + \\varepsilon \\times     \\begin{bmatrix}         \\max(|x_{n, i}|, |x_{n +1, i}|) \\\\         \\max(|y_{n, i}|, |y_{n +1, i}|) \\\\         \\max(|z_{n, i}|, |z_{n +1, i}|)     \\end{bmatrix},     \\quad i = 1, \\ldots, N. \\] <pre><code># Error estimation\ntolerance_scale_x[:] = (\n    TOLERANCE + np.maximum(np.abs(system.x), np.abs(x_1)) * TOLERANCE\n)\ntolerance_scale_v[:] = (\n    TOLERANCE + np.maximum(np.abs(system.v), np.abs(v_1)) * TOLERANCE\n)\n</code></pre> <p>Finally, we compute the error by taking the \"norm\":</p> \\[     \\text{error} = \\sqrt{\\overline{\\left( \\frac{\\Delta x'}{\\mathbf{s}} \\right)^2}}. \\] <p>The bar over means that we take the average over all elements (In case I am not clear, just look at the code below).</p> <pre><code>total = np.average(\n    np.square(error_estimation_delta_x / tolerance_scale_x)\n) + np.average(np.square(error_estimation_delta_v / tolerance_scale_v))\nerror = math.sqrt(total / 2.0)\n</code></pre> <p>The new step is accepted if the error is less than or equal to 1.0. Otherwise, we will reject the step and try again with a smaller time step.</p>"},{"location":"5_steps_to_n_body_simulation/step5/#time-step-estimation","title":"Time step estimation","text":"<p>With the error, we can now estimate the new time step. We will use the following formula:</p> \\[     \\Delta t_{n + 1} = 0.38^{1 / (1 + q)} \\times \\Delta t_n     \\times \\text{error}^{-1 / (1 + q)}, \\] <p>where \\(q\\) is the lowest power of the two methods (4 in our case). We also need to make sure that the new time step is not too small or too large. We can do this by setting</p> <ul> <li> <p>Safety factor <code>safety_fac_max = 6.0</code> and <code>safety_fac_min = 0.33</code> so that      \\(f_{\\text{max}} \\Delta t_{n + 1} \\leq \\Delta t_{n + 1} \\leq f_{\\text{min}} \\Delta t_{n + 1}\\).</p> </li> <li> <p>Lower bound of \\(\\Delta t\\) such that \\(\\Delta t_{n + 1} \\geq 10^{-12} (t_f - t_0)\\).</p> </li> <li>Lower bound of error such that \\(\\text{error} \\geq 10^{-12}\\).</li> </ul> <p>We have the following code:</p> <pre><code># Safety factors for step-size control\nsafety_fac_max = 6.0\nsafety_fac_min = 0.33\nsafety_fac = math.pow(0.38, 1.0 / (1.0 + float(min_power)))\n\n...\n\n# Calculate dt for next step\nif error &lt; 1e-12:\n    error = 1e-12  # Prevent error from being too small\n\ndt_new = dt * safety_fac / math.pow(error, 1.0 / (1.0 + float(min_power)))\nif dt_new &gt; safety_fac_max * dt:\n    dt *= safety_fac_max\nelif dt_new &lt; safety_fac_min * dt:\n    dt *= safety_fac_min\nelse:\n    dt = dt_new\n\nif dt_new &lt; TF * 1e-12:\n    dt = TF * 1e-12\n\n# Correct overshooting\nif current_time &lt; TF and current_time + dt &gt; TF:\n    dt = TF - current_time\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step5/#initial-dt","title":"Initial dt","text":"<p>The final thing we need is to set the initial time step. I found it easiest and most accurate by setting it manually. First, just set it to some arbitrary small value such as 1.0 days. Then, simulate for a short period and observe  how the time step corrects itself. Finally, choose a new time step and restart the simulation.</p>"},{"location":"5_steps_to_n_body_simulation/step5/#putting-it-all-together","title":"Putting it all together","text":"<p>Now, we can put everything together. First, we will need to slightly modify the print_simulation_info function:</p> common.py<pre><code>def print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n</code></pre> <p>We also want to store and plot <code>sol_dt</code> to keep track of the evolution of time step. common.py<pre><code>def plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n</code></pre></p> <p>The final code is given below.</p> step5.py (Click to expand) 5_steps_to_n_body_simulation/python/step5.py<pre><code>import math\nimport timeit\n\nimport numpy as np\n\nimport common\n\nOPTION = 0\n\n# Default units is AU, days, and M_sun\n\n# Solar system\nif OPTION == 0:\n    INITIAL_CONDITION = \"solar_system\"\n    TF = 200.0 * 365.24  # 200 years to days\n    TOLERANCE = 1e-8\n    OUTPUT_INTERVAL = 0.01 * 365.24  # 0.01 year to days\n    INITIAL_DT = 1.0\n\n# Pyth-3-body\nelif OPTION == 1:\n    INITIAL_CONDITION = \"pyth-3-body\"\n    TF = 70.0\n    TOLERANCE = 1e-13\n    OUTPUT_INTERVAL = 0.001\n    INITIAL_DT = 0.01\n\nelse:\n    raise ValueError(\"Invalid option. Choose 0 for solar system or 1 for Pyth-3-body.\")\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n\n    # RKF4(5) coefficients\n    # fmt: off\n    coeff = np.array((\n        [1.0 / 4.0, 0.0, 0.0, 0.0, 0.0],\n        [3.0 / 32.0, 9.0 / 32.0, 0.0, 0.0, 0.0],\n        [1932.0 / 2197.0, -7200.0 / 2197.0, 7296.0 / 2197.0, 0.0, 0.0],\n        [439.0 / 216.0, -8.0, 3680.0 / 513.0, -845.0 / 4104.0, 0.0],\n        [-8.0 / 27.0, 2.0, -3544.0 / 2565.0, 1859.0 / 4104.0, -11.0 / 40.0],\n    ))\n    # fmt: on\n    weights = np.array(\n        [25.0 / 216.0, 0.0, 1408.0 / 2565.0, 2197.0 / 4104.0, -1.0 / 5.0, 0.0]\n    )\n    weights_test = np.array(\n        [\n            16.0 / 135.0,\n            0.0,\n            6656.0 / 12825.0,\n            28561.0 / 56430.0,\n            -9.0 / 50.0,\n            2.0 / 55.0,\n        ]\n    )\n    min_power = 4\n    num_stages = len(weights)\n\n    # Initialize memory and arrays\n    a = np.zeros((system.num_particles, 3))\n    temp_system = common.System(\n        num_particles=system.num_particles,\n        x=np.zeros((system.num_particles, 3)),\n        v=np.zeros((system.num_particles, 3)),\n        m=system.m,\n        G=system.G,\n    )\n    x_1 = np.zeros((system.num_particles, 3))\n    v_1 = np.zeros((system.num_particles, 3))\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n    error_estimation_delta_x = np.zeros((system.num_particles, 3))\n    error_estimation_delta_v = np.zeros((system.num_particles, 3))\n    tolerance_scale_x = np.zeros((system.num_particles, 3))\n    tolerance_scale_v = np.zeros((system.num_particles, 3))\n\n    # Safety factors for step-size control\n    safety_fac_max = 6.0\n    safety_fac_min = 0.33\n    safety_fac = math.pow(0.38, 1.0 / (1.0 + float(min_power)))\n\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_dt = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    sol_dt[0] = INITIAL_DT\n    output_count = 1\n\n    # Launch simulation\n    common.print_simulation_info_adaptive_step_size(\n        system, TF, TOLERANCE, INITIAL_DT, OUTPUT_INTERVAL, sol_size\n    )\n    next_output_time = output_count * OUTPUT_INTERVAL\n    start = timeit.default_timer()\n    dt = INITIAL_DT\n    current_time = 0.0\n    while current_time &lt; TF:\n        # Initial stage\n        common.acceleration(a, system)\n        xk[0] = system.v\n        vk[0] = a\n\n        # Compute the stages\n        for stage in range(1, num_stages):\n            # Empty temp_x and temp_v\n            temp_system.x.fill(0.0)\n            temp_system.v.fill(0.0)\n\n            for i in range(stage):\n                temp_system.x[:] += coeff[stage - 1, i] * xk[i]\n                temp_system.v[:] += coeff[stage - 1, i] * vk[i]\n\n            temp_system.x[:] = system.x + dt * temp_system.x\n            temp_system.v[:] = system.v + dt * temp_system.v\n\n            # Compute the acceleration\n            xk[stage] = temp_system.v\n            common.acceleration(vk[stage], temp_system)\n\n        # Calculate x_1, v_1 and also delta x, delta v for error estimation\n        x_1[:] = system.x\n        v_1[:] = system.v\n        error_estimation_delta_x.fill(0.0)\n        error_estimation_delta_v.fill(0.0)\n        for stage in range(num_stages):\n            x_1[:] += dt * weights[stage] * xk[stage]\n            v_1[:] += dt * weights[stage] * vk[stage]\n            error_estimation_delta_x[:] += (\n                dt * (weights[stage] - weights_test[stage]) * xk[stage]\n            )\n            error_estimation_delta_v[:] += (\n                dt * (weights[stage] - weights_test[stage]) * vk[stage]\n            )\n\n        # Error estimation\n        tolerance_scale_x[:] = (\n            TOLERANCE + np.maximum(np.abs(system.x), np.abs(x_1)) * TOLERANCE\n        )\n        tolerance_scale_v[:] = (\n            TOLERANCE + np.maximum(np.abs(system.v), np.abs(v_1)) * TOLERANCE\n        )\n\n        total = np.average(\n            np.square(error_estimation_delta_x / tolerance_scale_x)\n        ) + np.average(np.square(error_estimation_delta_v / tolerance_scale_v))\n        error = math.sqrt(total / 2.0)\n\n        # Advance step\n        if error &lt;= 1.0 or dt &lt;= TF * 1e-12:\n            current_time += dt\n            system.x[:] = x_1\n            system.v[:] = v_1\n\n            if current_time &gt;= next_output_time:\n                sol_x[output_count] = system.x\n                sol_v[output_count] = system.v\n                sol_t[output_count] = current_time\n                sol_dt[output_count] = dt\n\n                output_count += 1\n                next_output_time = output_count * OUTPUT_INTERVAL\n\n                print(f\"Current time: {current_time:.2f} days\", end=\"\\r\")\n\n        # Calculate dt for next step\n        if error &lt; 1e-12:\n            error = 1e-12  # Prevent error from being too small\n\n        dt_new = dt * safety_fac / math.pow(error, 1.0 / (1.0 + float(min_power)))\n        if dt_new &gt; safety_fac_max * dt:\n            dt *= safety_fac_max\n        elif dt_new &lt; safety_fac_min * dt:\n            dt *= safety_fac_min\n        else:\n            dt = dt_new\n\n        if dt_new &lt; TF * 1e-12:\n            dt = TF * 1e-12\n\n        # Correct overshooting\n        if current_time &lt; TF and current_time + dt &gt; TF:\n            dt = TF - current_time\n\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n    sol_dt = sol_dt[:output_count]\n\n    end = timeit.default_timer()\n\n    print()\n    print(f\"Done! Runtime: {end - start:.3g} seconds, Solution size: {output_count}\")\n    common.plot_trajectory(\n        sol_x=sol_x,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n\n    # Compute and plot relative energy error\n    rel_energy_error = common.compute_rel_energy_error(sol_x, sol_v, system)\n    print(f\"Relative energy error: {rel_energy_error[-1]:.3g}\")\n    common.plot_rel_energy_error(rel_energy_error, sol_t / 365.24)\n    common.plot_dt(sol_dt, sol_t)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"5_steps_to_n_body_simulation/step5/#simulation-results","title":"Simulation results","text":"<p>Let us try to run the code again for the solar system. We use a tolerance = \\(10^{-8}\\) and initial time step = 1.0 days. The plots are shown below, with \\(\\Delta t\\) fluctuated quickly between \\(\\sim 1.4 - 2.75\\) days. This allows a more flexible time stepping to reduce the computation cost.</p> <p> </p>"},{"location":"5_steps_to_n_body_simulation/step5/#pythagorean-three-body-problem","title":"Pythagorean Three-Body Problem","text":"<p>As the Solar system is mostly stable, we may not be able to see the benefits of adaptive time-stepping. Here, we try the Pythagorean three-body problem, which is an extremely chaotic system with close encounters. Below is an illustration of the initial condition. We have three particles at rest at the vertices of a right-angled triangle with length ratio 3:4:5. The mass of the particles are \\(3.0 / G, 4.0 / G\\) and \\(5.0 / G\\) respectively.</p> <p></p> <p>The initial condition is available in the <code>get_initial_conditions</code> function we implemented before. Also, we set the following simulation parameters:</p> <pre><code>TF = 70.0  # 70 days\nTOLERANCE = 1e-13\nOUTPUT_INTERVAL = 0.001  # 0.001 day\nINITIAL_DT = 0.01  # Initial time step in days\n</code></pre> <p>The simulation result is shown below:</p> <p> </p> <p>As shown from the plots, \\(\\Delta t\\) fluctuated greatly between \\(10^{-8} - 10^{-2}\\) days! This is because of the close encounters between the particles. A video of the evolution in real time is available on youtube:</p> <p>Can we simulate this with RK4? Yes, but not with the time step we used before. Because the smallest time step for RKF4(5) is \\(10^{-8}\\) days, we will also need to set the time step for RK4 to \\(10^{-8}\\) days for the whole simulation, which is very inefficient! I have tested it using our <code>grav_sim</code> package written in C. The largest \\(\\Delta t\\)  we can use is \\(\\sim 2 \\times 10^{-8}\\) days, and the simulation took about 8 minutes, while the RKF45 finished within seconds! In Python it would probably takes hours to run the RK4 simulation.</p>"},{"location":"5_steps_to_n_body_simulation/step5/#summary","title":"Summary","text":"<p>In this step, we have implemented the RKF4(5) method with adaptive time-stepping. It is very efficient and allow us to save computational time, especially for chaotic systems or systems with close encounters.</p>"},{"location":"5_steps_to_n_body_simulation/step5/#full-scripts","title":"Full scripts","text":"<p>The full scripts are available at <code>5_steps_to_n_body_simulation/python/</code>, or https://github.com/alvinng4/grav_sim/blob/main/5_steps_to_n_body_simulation/python/</p> step5.py (Click to expand) 5_steps_to_n_body_simulation/python/step5.py<pre><code>import math\nimport timeit\n\nimport numpy as np\n\nimport common\n\nOPTION = 0\n\n# Default units is AU, days, and M_sun\n\n# Solar system\nif OPTION == 0:\n    INITIAL_CONDITION = \"solar_system\"\n    TF = 200.0 * 365.24  # 200 years to days\n    TOLERANCE = 1e-8\n    OUTPUT_INTERVAL = 0.01 * 365.24  # 0.01 year to days\n    INITIAL_DT = 1.0\n\n# Pyth-3-body\nelif OPTION == 1:\n    INITIAL_CONDITION = \"pyth-3-body\"\n    TF = 70.0\n    TOLERANCE = 1e-13\n    OUTPUT_INTERVAL = 0.001\n    INITIAL_DT = 0.01\n\nelse:\n    raise ValueError(\"Invalid option. Choose 0 for solar system or 1 for Pyth-3-body.\")\n\n\ndef main() -&gt; None:\n    # Get initial conditions\n    system, labels, colors, legend = common.get_initial_conditions(INITIAL_CONDITION)\n\n    # RKF4(5) coefficients\n    # fmt: off\n    coeff = np.array((\n        [1.0 / 4.0, 0.0, 0.0, 0.0, 0.0],\n        [3.0 / 32.0, 9.0 / 32.0, 0.0, 0.0, 0.0],\n        [1932.0 / 2197.0, -7200.0 / 2197.0, 7296.0 / 2197.0, 0.0, 0.0],\n        [439.0 / 216.0, -8.0, 3680.0 / 513.0, -845.0 / 4104.0, 0.0],\n        [-8.0 / 27.0, 2.0, -3544.0 / 2565.0, 1859.0 / 4104.0, -11.0 / 40.0],\n    ))\n    # fmt: on\n    weights = np.array(\n        [25.0 / 216.0, 0.0, 1408.0 / 2565.0, 2197.0 / 4104.0, -1.0 / 5.0, 0.0]\n    )\n    weights_test = np.array(\n        [\n            16.0 / 135.0,\n            0.0,\n            6656.0 / 12825.0,\n            28561.0 / 56430.0,\n            -9.0 / 50.0,\n            2.0 / 55.0,\n        ]\n    )\n    min_power = 4\n    num_stages = len(weights)\n\n    # Initialize memory and arrays\n    a = np.zeros((system.num_particles, 3))\n    temp_system = common.System(\n        num_particles=system.num_particles,\n        x=np.zeros((system.num_particles, 3)),\n        v=np.zeros((system.num_particles, 3)),\n        m=system.m,\n        G=system.G,\n    )\n    x_1 = np.zeros((system.num_particles, 3))\n    v_1 = np.zeros((system.num_particles, 3))\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n    error_estimation_delta_x = np.zeros((system.num_particles, 3))\n    error_estimation_delta_v = np.zeros((system.num_particles, 3))\n    tolerance_scale_x = np.zeros((system.num_particles, 3))\n    tolerance_scale_v = np.zeros((system.num_particles, 3))\n\n    # Safety factors for step-size control\n    safety_fac_max = 6.0\n    safety_fac_min = 0.33\n    safety_fac = math.pow(0.38, 1.0 / (1.0 + float(min_power)))\n\n    # Solution array\n    sol_size = int(TF // OUTPUT_INTERVAL + 2)  # +2 for initial and final time\n    sol_x = np.zeros((sol_size, system.num_particles, 3))\n    sol_v = np.zeros((sol_size, system.num_particles, 3))\n    sol_t = np.zeros(sol_size)\n    sol_dt = np.zeros(sol_size)\n    sol_x[0] = system.x\n    sol_v[0] = system.v\n    sol_t[0] = 0.0\n    sol_dt[0] = INITIAL_DT\n    output_count = 1\n\n    # Launch simulation\n    common.print_simulation_info_adaptive_step_size(\n        system, TF, TOLERANCE, INITIAL_DT, OUTPUT_INTERVAL, sol_size\n    )\n    next_output_time = output_count * OUTPUT_INTERVAL\n    start = timeit.default_timer()\n    dt = INITIAL_DT\n    current_time = 0.0\n    while current_time &lt; TF:\n        # Initial stage\n        common.acceleration(a, system)\n        xk[0] = system.v\n        vk[0] = a\n\n        # Compute the stages\n        for stage in range(1, num_stages):\n            # Empty temp_x and temp_v\n            temp_system.x.fill(0.0)\n            temp_system.v.fill(0.0)\n\n            for i in range(stage):\n                temp_system.x[:] += coeff[stage - 1, i] * xk[i]\n                temp_system.v[:] += coeff[stage - 1, i] * vk[i]\n\n            temp_system.x[:] = system.x + dt * temp_system.x\n            temp_system.v[:] = system.v + dt * temp_system.v\n\n            # Compute the acceleration\n            xk[stage] = temp_system.v\n            common.acceleration(vk[stage], temp_system)\n\n        # Calculate x_1, v_1 and also delta x, delta v for error estimation\n        x_1[:] = system.x\n        v_1[:] = system.v\n        error_estimation_delta_x.fill(0.0)\n        error_estimation_delta_v.fill(0.0)\n        for stage in range(num_stages):\n            x_1[:] += dt * weights[stage] * xk[stage]\n            v_1[:] += dt * weights[stage] * vk[stage]\n            error_estimation_delta_x[:] += (\n                dt * (weights[stage] - weights_test[stage]) * xk[stage]\n            )\n            error_estimation_delta_v[:] += (\n                dt * (weights[stage] - weights_test[stage]) * vk[stage]\n            )\n\n        # Error estimation\n        tolerance_scale_x[:] = (\n            TOLERANCE + np.maximum(np.abs(system.x), np.abs(x_1)) * TOLERANCE\n        )\n        tolerance_scale_v[:] = (\n            TOLERANCE + np.maximum(np.abs(system.v), np.abs(v_1)) * TOLERANCE\n        )\n\n        total = np.average(\n            np.square(error_estimation_delta_x / tolerance_scale_x)\n        ) + np.average(np.square(error_estimation_delta_v / tolerance_scale_v))\n        error = math.sqrt(total / 2.0)\n\n        # Advance step\n        if error &lt;= 1.0 or dt &lt;= TF * 1e-12:\n            current_time += dt\n            system.x[:] = x_1\n            system.v[:] = v_1\n\n            if current_time &gt;= next_output_time:\n                sol_x[output_count] = system.x\n                sol_v[output_count] = system.v\n                sol_t[output_count] = current_time\n                sol_dt[output_count] = dt\n\n                output_count += 1\n                next_output_time = output_count * OUTPUT_INTERVAL\n\n                print(f\"Current time: {current_time:.2f} days\", end=\"\\r\")\n\n        # Calculate dt for next step\n        if error &lt; 1e-12:\n            error = 1e-12  # Prevent error from being too small\n\n        dt_new = dt * safety_fac / math.pow(error, 1.0 / (1.0 + float(min_power)))\n        if dt_new &gt; safety_fac_max * dt:\n            dt *= safety_fac_max\n        elif dt_new &lt; safety_fac_min * dt:\n            dt *= safety_fac_min\n        else:\n            dt = dt_new\n\n        if dt_new &lt; TF * 1e-12:\n            dt = TF * 1e-12\n\n        # Correct overshooting\n        if current_time &lt; TF and current_time + dt &gt; TF:\n            dt = TF - current_time\n\n    sol_x = sol_x[:output_count]\n    sol_v = sol_v[:output_count]\n    sol_t = sol_t[:output_count]\n    sol_dt = sol_dt[:output_count]\n\n    end = timeit.default_timer()\n\n    print()\n    print(f\"Done! Runtime: {end - start:.3g} seconds, Solution size: {output_count}\")\n    common.plot_trajectory(\n        sol_x=sol_x,\n        labels=labels,\n        colors=colors,\n        legend=legend,\n    )\n\n    # Compute and plot relative energy error\n    rel_energy_error = common.compute_rel_energy_error(sol_x, sol_v, system)\n    print(f\"Relative energy error: {rel_energy_error[-1]:.3g}\")\n    common.plot_rel_energy_error(rel_energy_error, sol_t / 365.24)\n    common.plot_dt(sol_dt, sol_t)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> common.py (Click to expand) 5_steps_to_n_body_simulation/python/common.py<pre><code>from typing import Tuple, List, Optional\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n##### Step 1 #####\nclass System:\n    def __init__(\n        self, num_particles: int, x: np.ndarray, v: np.ndarray, m: np.ndarray, G: float\n    ) -&gt; None:\n        self.num_particles = num_particles\n        self.x = x\n        self.v = v\n        self.m = m\n        self.G = G\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n\ndef get_initial_conditions(\n    initial_condition: str,\n) -&gt; Tuple[System, List[Optional[str]], List[Optional[str]], bool]:\n    \"\"\"\n    Returns the initial conditions for solar system,\n    with units AU, days, and M_sun.\n\n    Parameters\n    ----------\n    initial_condition : str\n        Name for the initial condition.\n\n    Returns\n    -------\n    system: System\n        System object with initial conditions.\n    labels: list\n        Labels for the particles.\n    colors: list\n        Colors for the particles.\n    legend: bool\n        Whether to show the legend.\n    \"\"\"\n    # Conversion factor from km^3 s^-2 to AU^3 d^-2\n    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)\n\n    # GM values (km^3 s^-2)\n    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf\n    GM_KM_S = {\n        \"Sun\": 132712440041.279419,\n        \"Mercury\": 22031.868551,\n        \"Venus\": 324858.592000,\n        \"Earth\": 398600.435507,\n        \"Mars\": 42828.375816,\n        \"Jupiter\": 126712764.100000,\n        \"Saturn\": 37940584.841800,\n        \"Uranus\": 5794556.400000,\n        \"Neptune\": 6836527.100580,\n        \"Moon\": 4902.800118,\n        \"Pluto\": 975.500000,\n        \"Ceres\": 62.62890,\n        \"Vesta\": 17.288245,\n    }\n\n    # GM values (AU^3 d^-2)\n    GM_AU_DAY = {\n        \"Sun\": 132712440041.279419 * CONVERSION_FACTOR,\n        \"Mercury\": 22031.868551 * CONVERSION_FACTOR,\n        \"Venus\": 324858.592000 * CONVERSION_FACTOR,\n        \"Earth\": 398600.435507 * CONVERSION_FACTOR,\n        \"Mars\": 42828.375816 * CONVERSION_FACTOR,\n        \"Jupiter\": 126712764.100000 * CONVERSION_FACTOR,\n        \"Saturn\": 37940584.841800 * CONVERSION_FACTOR,\n        \"Uranus\": 5794556.400000 * CONVERSION_FACTOR,\n        \"Neptune\": 6836527.100580 * CONVERSION_FACTOR,\n        \"Moon\": 4902.800118 * CONVERSION_FACTOR,\n        \"Pluto\": 975.500000 * CONVERSION_FACTOR,\n        \"Ceres\": 62.62890 * CONVERSION_FACTOR,\n        \"Vesta\": 17.288245 * CONVERSION_FACTOR,\n    }\n\n    # Solar system masses (M_sun^-1)\n    SOLAR_SYSTEM_MASSES = {\n        \"Sun\": 1.0,\n        \"Mercury\": GM_KM_S[\"Mercury\"] / GM_KM_S[\"Sun\"],\n        \"Venus\": GM_KM_S[\"Venus\"] / GM_KM_S[\"Sun\"],\n        \"Earth\": GM_KM_S[\"Earth\"] / GM_KM_S[\"Sun\"],\n        \"Mars\": GM_KM_S[\"Mars\"] / GM_KM_S[\"Sun\"],\n        \"Jupiter\": GM_KM_S[\"Jupiter\"] / GM_KM_S[\"Sun\"],\n        \"Saturn\": GM_KM_S[\"Saturn\"] / GM_KM_S[\"Sun\"],\n        \"Uranus\": GM_KM_S[\"Uranus\"] / GM_KM_S[\"Sun\"],\n        \"Neptune\": GM_KM_S[\"Neptune\"] / GM_KM_S[\"Sun\"],\n        \"Moon\": GM_KM_S[\"Moon\"] / GM_KM_S[\"Sun\"],\n        \"Pluto\": GM_KM_S[\"Pluto\"] / GM_KM_S[\"Sun\"],\n        \"Ceres\": GM_KM_S[\"Ceres\"] / GM_KM_S[\"Sun\"],\n        \"Vesta\": GM_KM_S[\"Vesta\"] / GM_KM_S[\"Sun\"],\n    }\n\n    G = GM_AU_DAY[\"Sun\"]\n\n    # Solar system position and velocities data\n    # Units: AU-D\n    # Coordinate center: Solar System Barycenter\n    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB\n    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/\n    SOLAR_SYSTEM_POS = {\n        \"Sun\": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],\n        \"Mercury\": [\n            -2.825983269538632e-01,\n            1.974559795958082e-01,\n            4.177433558063677e-02,\n        ],\n        \"Venus\": [\n            -7.232103701666379e-01,\n            -7.948302026312400e-02,\n            4.042871428174315e-02,\n        ],\n        \"Earth\": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],\n        \"Mars\": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],\n        \"Jupiter\": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],\n        \"Saturn\": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],\n        \"Uranus\": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],\n        \"Neptune\": [\n            2.983501460984741e01,\n            -1.793812957956852e00,\n            -6.506401132254588e-01,\n        ],\n        \"Moon\": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],\n        \"Pluto\": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],\n        \"Ceres\": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],\n        \"Vesta\": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],\n    }\n    SOLAR_SYSTEM_VEL = {\n        \"Sun\": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],\n        \"Mercury\": [\n            -2.232165900189702e-02,\n            -2.157207103176252e-02,\n            2.855193410495743e-04,\n        ],\n        \"Venus\": [\n            2.034068201002341e-03,\n            -2.020828626592994e-02,\n            -3.945639843855159e-04,\n        ],\n        \"Earth\": [\n            -1.723001232538228e-02,\n            -2.967721342618870e-03,\n            6.382125383116755e-07,\n        ],\n        \"Mars\": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],\n        \"Jupiter\": [\n            -5.470970658852281e-03,\n            5.642487338479145e-03,\n            9.896190602066252e-05,\n        ],\n        \"Saturn\": [\n            1.822013845554067e-03,\n            5.143470425888054e-03,\n            -1.617235904887937e-04,\n        ],\n        \"Uranus\": [\n            -3.097615358317413e-03,\n            2.276781932345769e-03,\n            4.860433222241686e-05,\n        ],\n        \"Neptune\": [\n            1.676536611817232e-04,\n            3.152098732861913e-03,\n            -6.877501095688201e-05,\n        ],\n        \"Moon\": [\n            -1.746667306153906e-02,\n            -3.473438277358121e-03,\n            -3.359028758606074e-05,\n        ],\n        \"Pluto\": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],\n        \"Ceres\": [\n            8.978653480111301e-03,\n            -4.873256528198994e-03,\n            -1.807162046049230e-03,\n        ],\n        \"Vesta\": [\n            -1.017876585480054e-02,\n            -5.452367109338154e-04,\n            1.255870551153315e-03,\n        ],\n    }\n\n    SOLAR_SYSTEM_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n    }\n\n    SOLAR_SYSTEM_PLUS_COLORS = {\n        \"Sun\": \"orange\",\n        \"Mercury\": \"slategrey\",\n        \"Venus\": \"wheat\",\n        \"Earth\": \"skyblue\",\n        \"Mars\": \"red\",\n        \"Jupiter\": \"darkgoldenrod\",\n        \"Saturn\": \"gold\",\n        \"Uranus\": \"paleturquoise\",\n        \"Neptune\": \"blue\",\n        \"Pluto\": None,\n        \"Ceres\": None,\n        \"Vesta\": None,\n    }\n\n    if initial_condition == \"pyth-3-body\":\n        # Pythagorean 3-body problem\n        R1 = np.array([1.0, 3.0, 0.0])\n        R2 = np.array([-2.0, -1.0, 0.0])\n        R3 = np.array([1.0, -1.0, 0.0])\n        V1 = np.array([0.0, 0.0, 0.0])\n        V2 = np.array([0.0, 0.0, 0.0])\n        V3 = np.array([0.0, 0.0, 0.0])\n\n        x = np.array([R1, R2, R3])\n        v = np.array([V1, V2, V3])\n        m = np.array([3.0 / G, 4.0 / G, 5.0 / G])\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels: List[Optional[str]] = [None, None, None]\n        colors: List[Optional[str]] = [None, None, None]\n        legend = False\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    elif initial_condition == \"solar_system_plus\":\n        m = np.array(\n            [\n                SOLAR_SYSTEM_MASSES[\"Sun\"],\n                SOLAR_SYSTEM_MASSES[\"Mercury\"],\n                SOLAR_SYSTEM_MASSES[\"Venus\"],\n                SOLAR_SYSTEM_MASSES[\"Earth\"],\n                SOLAR_SYSTEM_MASSES[\"Mars\"],\n                SOLAR_SYSTEM_MASSES[\"Jupiter\"],\n                SOLAR_SYSTEM_MASSES[\"Saturn\"],\n                SOLAR_SYSTEM_MASSES[\"Uranus\"],\n                SOLAR_SYSTEM_MASSES[\"Neptune\"],\n                SOLAR_SYSTEM_MASSES[\"Pluto\"],\n                SOLAR_SYSTEM_MASSES[\"Ceres\"],\n                SOLAR_SYSTEM_MASSES[\"Vesta\"],\n            ]\n        )\n\n        R1 = np.array(SOLAR_SYSTEM_POS[\"Sun\"])\n        R2 = np.array(SOLAR_SYSTEM_POS[\"Mercury\"])\n        R3 = np.array(SOLAR_SYSTEM_POS[\"Venus\"])\n        R4 = np.array(SOLAR_SYSTEM_POS[\"Earth\"])\n        R5 = np.array(SOLAR_SYSTEM_POS[\"Mars\"])\n        R6 = np.array(SOLAR_SYSTEM_POS[\"Jupiter\"])\n        R7 = np.array(SOLAR_SYSTEM_POS[\"Saturn\"])\n        R8 = np.array(SOLAR_SYSTEM_POS[\"Uranus\"])\n        R9 = np.array(SOLAR_SYSTEM_POS[\"Neptune\"])\n        R10 = np.array(SOLAR_SYSTEM_POS[\"Pluto\"])\n        R11 = np.array(SOLAR_SYSTEM_POS[\"Ceres\"])\n        R12 = np.array(SOLAR_SYSTEM_POS[\"Vesta\"])\n\n        V1 = np.array(SOLAR_SYSTEM_VEL[\"Sun\"])\n        V2 = np.array(SOLAR_SYSTEM_VEL[\"Mercury\"])\n        V3 = np.array(SOLAR_SYSTEM_VEL[\"Venus\"])\n        V4 = np.array(SOLAR_SYSTEM_VEL[\"Earth\"])\n        V5 = np.array(SOLAR_SYSTEM_VEL[\"Mars\"])\n        V6 = np.array(SOLAR_SYSTEM_VEL[\"Jupiter\"])\n        V7 = np.array(SOLAR_SYSTEM_VEL[\"Saturn\"])\n        V8 = np.array(SOLAR_SYSTEM_VEL[\"Uranus\"])\n        V9 = np.array(SOLAR_SYSTEM_VEL[\"Neptune\"])\n        V10 = np.array(SOLAR_SYSTEM_VEL[\"Pluto\"])\n        V11 = np.array(SOLAR_SYSTEM_VEL[\"Ceres\"])\n        V12 = np.array(SOLAR_SYSTEM_VEL[\"Vesta\"])\n\n        x = np.array(\n            [\n                R1,\n                R2,\n                R3,\n                R4,\n                R5,\n                R6,\n                R7,\n                R8,\n                R9,\n                R10,\n                R11,\n                R12,\n            ]\n        )\n        v = np.array(\n            [\n                V1,\n                V2,\n                V3,\n                V4,\n                V5,\n                V6,\n                V7,\n                V8,\n                V9,\n                V10,\n                V11,\n                V12,\n            ]\n        )\n\n        system = System(\n            num_particles=len(m),\n            x=x,\n            v=v,\n            m=m,\n            G=G,\n        )\n        system.center_of_mass_correction()\n\n        labels = list(SOLAR_SYSTEM_PLUS_COLORS.keys())\n        colors = list(SOLAR_SYSTEM_PLUS_COLORS.values())\n        legend = True\n\n        return system, labels, colors, legend\n\n    else:\n        raise ValueError(f\"Initial condition not recognized: {initial_condition}.\")\n\n\ndef plot_initial_conditions(\n    system: System,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the initial positions.\n\n    Parameters\n    ----------\n    system : System\n        System object.\n    labels : list\n        Labels for the particles.\n    colors : list\n        Colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(system.num_particles):\n        ax.scatter(\n            system.x[i, 0], system.x[i, 1], marker=\"o\", color=colors[i], label=labels[i]\n        )\n\n    if legend:\n        ax.legend()\n\n    plt.show()\n\n\n##### Step 2 #####\ndef acceleration(\n    a: np.ndarray,\n    system: System,\n) -&gt; None:\n    \"\"\"\n    Compute the gravitational acceleration\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array to be modified in-place,\n        with shape (N, 3)\n    system : System\n        System object.\n    \"\"\"\n    # Empty acceleration array\n    a.fill(0.0)\n\n    # Declare variables\n    x = system.x\n    m = system.m\n    G = system.G\n\n    # Compute the displacement vector\n    r_ij = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n\n    # Compute the distance\n    r_norm = np.linalg.norm(r_ij, axis=2)\n\n    # Compute 1 / r^3\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        inv_r_cubed = 1.0 / (r_norm * r_norm * r_norm)\n\n    # Set diagonal elements to 0 to avoid self-interaction\n    np.fill_diagonal(inv_r_cubed, 0.0)\n\n    # Compute the acceleration\n    a[:] = G * np.einsum(\"ijk,ij,i-&gt;jk\", r_ij, inv_r_cubed, m)\n\n\n##### Step 3 #####\ndef euler(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler's method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.x += system.v * dt\n    system.v += a * dt\n\n\ndef print_simulation_info_fixed_step_size(\n    system: System,\n    tf: float,\n    dt: float,\n    num_steps: int,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days (Actual tf = dt * num_steps = {dt * num_steps} days)\")\n    print(f\"dt: {dt} days\")\n    print(f\"Num_steps: {num_steps}\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 2D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    plt.show()\n\n\n##### Step 4 #####\ndef compute_rel_energy_error(\n    sol_x: np.ndarray, sol_v: np.ndarray, system: System\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute the relative energy error of the simulation.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    sol_v : np.ndarray\n        Solution velocity array with shape (N_steps, num_particles, 3).\n    system : System\n        System object.\n\n    Returns\n    -------\n    energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    \"\"\"\n    # Allocate memory and initialize arrays\n    n_steps = sol_x.shape[0]\n    num_particles = system.num_particles\n    m = system.m\n    G = system.G\n    rel_energy_error = np.zeros(n_steps)\n\n    # Compute the total energy (KE + PE)\n    for count in range(n_steps):\n        x = sol_x[count]\n        v = sol_v[count]\n        for i in range(num_particles):\n            # KE\n            rel_energy_error[count] += 0.5 * m[i] * np.linalg.norm(v[i]) ** 2\n            # PE\n            for j in range(i + 1, num_particles):\n                rel_energy_error[count] -= G * m[i] * m[j] / np.linalg.norm(x[i] - x[j])\n\n    # Compute the relative energy error\n    initial_energy = rel_energy_error[0]\n    rel_energy_error = (rel_energy_error - initial_energy) / initial_energy\n    rel_energy_error = np.abs(rel_energy_error)\n\n    return rel_energy_error\n\n\ndef plot_rel_energy_error(rel_energy_error: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the relative energy error.\n\n    Parameters\n    ----------\n    rel_energy_error : np.ndarray\n        Relative energy error of the simulation, with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.plot(sol_t, rel_energy_error)\n    plt.yscale(\"log\")\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Relative Energy Error\")\n    plt.title(\"Relative Energy Error vs Time\")\n    plt.show()\n\n\ndef euler_cromer(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the Euler-Cromer method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    acceleration(a, system)\n    system.v += a * dt\n    system.x += system.v * dt\n\n\ndef rk4(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the RK4 method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    num_stages = 4\n    coeff = np.array([0.5, 0.5, 1.0])\n    weights = np.array([1.0, 2.0, 2.0, 1.0]) / 6.0\n\n    # Allocate memory and initialize arrays\n    x0 = system.x.copy()\n    v0 = system.v.copy()\n    xk = np.zeros((num_stages, system.num_particles, 3))\n    vk = np.zeros((num_stages, system.num_particles, 3))\n\n    # Initial stage\n    acceleration(a, system)\n    xk[0] = v0\n    vk[0] = a\n\n    # Compute the stages\n    for stage in range(1, num_stages):\n        # Compute acceleration\n        system.x = x0 + dt * coeff[stage - 1] * xk[stage - 1]\n        acceleration(a, system)\n\n        # Compute xk and vk\n        xk[stage] = v0 + dt * coeff[stage - 1] * vk[stage - 1]\n        vk[stage] = a\n\n    # Advance step\n    # dx = 0.0\n    # dv = 0.0\n    # for stage in range(num_stages):\n    #     dx += weights[stage] * xk[stage]\n    #     dv += weights[stage] * vk[stage]\n\n    dx = np.einsum(\"i,ijk-&gt;jk\", weights, xk)\n    dv = np.einsum(\"i,ijk-&gt;jk\", weights, vk)\n\n    system.x = x0 + dt * dx\n    system.v = v0 + dt * dv\n\n\ndef leapfrog(a: np.ndarray, system: System, dt: float) -&gt; None:\n    \"\"\"\n    Advance one step with the LeapFrog method.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Gravitational accelerations array with shape (N, 3).\n    system : System\n        System object.\n    dt : float\n        Time step.\n    \"\"\"\n    # Velocity kick (v_1/2)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n    # Position drift (x_1)\n    system.x += system.v * dt\n\n    # Velocity kick (v_1)\n    acceleration(a, system)\n    system.v += a * 0.5 * dt\n\n\n##### Step 5 #####\ndef print_simulation_info_adaptive_step_size(\n    system: System,\n    tf: float,\n    tolerance: float,\n    initial_dt: float,\n    output_interval: float,\n    sol_size: int,\n) -&gt; None:\n    print(\"----------------------------------------------------------\")\n    print(\"Simulation Info:\")\n    print(f\"num_particles: {system.num_particles}\")\n    print(f\"G: {system.G}\")\n    print(f\"tf: {tf} days\")\n    print(f\"tolerance: {tolerance}\")\n    print(f\"Initial dt: {initial_dt} days\")\n    print()\n    print(f\"Output interval: {output_interval} days\")\n    print(f\"Estimated solution size: {sol_size}\")\n    print(\"----------------------------------------------------------\")\n\n\ndef plot_dt(sol_dt: np.ndarray, sol_t: np.ndarray) -&gt; None:\n    \"\"\"\n    Plot the time step.\n\n    Parameters\n    ----------\n    sol_dt : np.ndarray\n        Time step array with shape (N_steps,).\n    sol_t : np.ndarray\n        Solution time array with shape (N_steps,).\n    \"\"\"\n    plt.figure()\n    plt.semilogy(sol_t, sol_dt)\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"dt\")\n    plt.show()\n\n\n##### Extra #####\ndef set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n\n\ndef plot_3d_trajectory(\n    sol_x: np.ndarray,\n    labels: list,\n    colors: list,\n    legend: bool,\n) -&gt; None:\n    \"\"\"\n    Plot the 3D trajectory.\n\n    Parameters\n    ----------\n    sol_x : np.ndarray\n        Solution position array with shape (N_steps, num_particles, 3).\n    labels : list\n        List of labels for the particles.\n    colors : list\n        List of colors for the particles.\n    legend : bool\n        Whether to show the legend.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_xlabel(\"$x$ (AU)\")\n    ax.set_ylabel(\"$y$ (AU)\")\n    ax.set_zlabel(\"$z$ (AU)\")  # type: ignore\n\n    for i in range(sol_x.shape[1]):\n        traj = ax.plot(\n            sol_x[:, i, 0],\n            sol_x[:, i, 1],\n            sol_x[:, i, 2],\n            color=colors[i],\n        )\n        # Plot the last position with marker\n        ax.scatter(\n            sol_x[-1, i, 0],\n            sol_x[-1, i, 1],\n            sol_x[-1, i, 2],\n            marker=\"o\",\n            color=traj[0].get_color(),\n            label=labels[i],\n        )\n\n    set_3d_axes_equal(ax)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(right=0.7)\n\n    plt.show()\n</code></pre>"},{"location":"docs/","title":"Index","text":"<ul> <li>Home</li> <li>Getting Started</li> <li>Documentations</li> <li>Examples</li> <li>5 Steps to N-body simulation</li> </ul>"},{"location":"docs/#grav_sim","title":"grav_sim","text":"<p>N-body gravity simulation library with C and Python API</p> <ul> <li>Source code: https://github.com/alvinng4/grav_sim</li> <li>Project Homepage and documentations: https://alvinng4.github.io/grav_sim/</li> </ul> <p>Target Audience:</p> <ul> <li>Physics students</li> <li>Anyone interested in N-body simulations</li> </ul> <p>Features:</p> <ul> <li>Ten integrators including WHFast and IAS15</li> <li>Barnes-Hut algorithm with linear octree</li> <li>Particle-Mesh method for cosmological structure formation</li> <li>Multiple sample projects</li> </ul>"},{"location":"docs/#5-steps-to-n-body-simulation","title":"5 steps to N-body simulation","text":"<p>A short course to teach beginners how to write fast and clean N-body gravity simulations code in Python.</p> <p>Homepage: https://alvinng4.github.io/grav_sim/5_steps_to_n_body_simulation/</p> <p>Contents</p> <ul> <li>Step 1: Initial setup</li> <li>Step 2: Gravity</li> <li>Step 3: Your first N-body program</li> <li>Step 4: Higher-order algorithms</li> <li>Step 5: Adaptive time-stepping</li> <li>Extra: Plotting and animation</li> <li>Conclusion and Final Project</li> </ul> <p> </p>"},{"location":"docs/#sample-projects","title":"Sample projects","text":""},{"location":"docs/#evolving-the-solar-system-for-1-million-years","title":"Evolving the solar system for 1 million years","text":""},{"location":"docs/#asteroid-belt-animation","title":"Asteroid belt animation","text":""},{"location":"docs/#formation-of-kirkwood-gaps","title":"Formation of Kirkwood gaps","text":""},{"location":"docs/#galaxy-collision","title":"Galaxy collision","text":""},{"location":"docs/#cosmological-structure-formation","title":"Cosmological structure formation","text":""},{"location":"docs/#feedback-and-bugs","title":"Feedback and Bugs","text":"<p>If you found any bugs or want to leave some feedback, please feel free to let me know by opening an issue or sending an email to alvinng324(at)gmail.com.</p>"},{"location":"docs/host_docs/","title":"Host docs","text":"<p>To host the docs locally, first install the libraries: <pre><code>pip install mkdocs-material mkdocs-bibtex mkdocs-jupyter mkdocs-same-dir \"mkdocstrings[python]\"\n</code></pre></p> <p>Then, run the following command to start the server: <pre><code>cd ..           # Go to the root directory\nmkdocs serve\n</code></pre></p>"},{"location":"docs/documentations/","title":"Index","text":""},{"location":"docs/documentations/#table-of-contents","title":"Table of Contents","text":""},{"location":"docs/documentations/#documentations","title":"Documentations","text":"<ul> <li>Integrators</li> <li>Massless acceleration</li> <li>Barnes-Hut algorithm</li> <li>Particle-Mesh algorithm</li> <li>Comoving coordinates</li> <li>Output formats</li> <li>Force softening</li> <li>Reducing round off error</li> <li>Why C?</li> </ul>"},{"location":"docs/documentations/#python-api","title":"Python API","text":"<ul> <li>GravitySimulatorAPI</li> <li>Parameters</li> <li>Plotting</li> <li>System</li> <li>Simulator</li> </ul>"},{"location":"docs/documentations/#c-api","title":"C API","text":"<ul> <li>Grav sim</li> </ul>"},{"location":"docs/documentations/#project-file-structure","title":"Project File Structure","text":"<pre><code>grav_sim/\n\u251c\u2500\u2500 docs/                           # Documentation\n\u251c\u2500\u2500 examples/                       # Example scripts\n\u251c\u2500\u2500 grav_sim/                       # Python wrapper\n\u251c\u2500\u2500 overrides/                      # Mkdocs overrides\n\u251c\u2500\u2500 pcg/                            # PCG random number generator\n\u251c\u2500\u2500 src/                            # C source code\n\u251c\u2500\u2500 5_steps_to_n_body_simulation/   # 5 steps to n-body simulation\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 FindFFTW3.cmake\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 MANIFEST.in\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md            \n\u251c\u2500\u2500 requirements.txt             \n\u251c\u2500\u2500 setup.py      \n\u2514\u2500\u2500 .github/   \n</code></pre>"},{"location":"docs/documentations/barnes_hut/","title":"Barnes-Hut algorithm","text":"<p>The classic Barnes-Hut algorithm<sup>1</sup> provides a way to approximate forces in \\(\\mathcal{O}(N \\log N)\\) without losing accuracy at close range. Because gravity decays at a quadratic rate, the accuracy of long range interactions are less important. Therefore, it is reasonable to approximate a far cluster of  particles as a single particle with mass \\(m = m_{\\textnormal{cluster}} \\) and coordinate \\(x = x_{\\textnormal{com, cluster} } \\). One simple choice of criterion is the opening angle \\(\\theta = l / d\\), where \\(l\\) is the length of the cubical cell enclosing the cluster and \\(d\\) is the distance between the target particle and the center of mass of the cluster (see figure 1). This is purely geometric and does not depends on the  mass or number of particles in the cluster.</p> Figure 1: Illustration of Barnes-Hut algorithm."},{"location":"docs/documentations/barnes_hut/#linear-octree-construction","title":"Linear octree construction","text":"Source code (Click to expand) <pre><code>/**\n * \\file linear_octree.c\n * \\brief Implementation of linear octree for Barnes-Hut algorithm\n * \n * \\author Ching-Yin Ng\n */\n\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#ifdef USE_OPENMP\n    #include &lt;omp.h&gt;\n#endif\n\n#include \"acceleration.h\"\n#include \"common.h\"\n#include \"error.h\"\n#include \"linear_octree.h\"\n\n\n// // For debug only\n// IN_FILE void print_octree_nodes(\n//     const LinearOctree *restrict octree,\n//     const double *restrict x,\n//     const double *restrict m,\n//     const int node_idx,\n//     const int indent\n// )\n// {\n//     // Print indent spaces\n//     for (int i = 0; i &lt; indent; ++i)\n//     printf(\"  \");\n\n//     // Print summary info about the node\n//     printf(\"Node %d:\\n\", node_idx);\n\n//     for (int i = 0; i &lt; indent; ++i) printf(\"  \");\n//     printf(\"  Num Particles: %d, Num children: %d\\n\",\n//         octree-&gt;tree_num_particles[node_idx],\n//         octree-&gt;tree_num_internal_children[node_idx]\n//     );\n\n//     if (octree-&gt;tree_num_internal_children[node_idx] &gt; 0)\n//     {\n//         for (int i = 0; i &lt; indent; ++i) printf(\"  \");\n//         printf(\"  Center of Mass: (%.16g, %.16g, %.16g), Total Mass: %.16g\\n\",\n//             octree-&gt;tree_center_of_mass_x[node_idx],\n//             octree-&gt;tree_center_of_mass_y[node_idx],\n//             octree-&gt;tree_center_of_mass_z[node_idx],\n//             octree-&gt;tree_mass[node_idx]\n//         );\n//     }\n//     else\n//     {\n//         for (int i = 0; i &lt; octree-&gt;tree_num_particles[node_idx]; i++)\n//         {\n//             int particle_idx = octree-&gt;sorted_indices[octree-&gt;tree_first_particle_sorted_idx[node_idx] + i];\n//             for (int j = 0; j &lt; indent; ++j) printf(\"  \");\n//             printf(\"  Particle %d: (%.4g, %.4g, %.4g), m = %.4g\\n\",\n//                 particle_idx,\n//                 x[particle_idx * 3 + 0],\n//                 x[particle_idx * 3 + 1],\n//                 x[particle_idx * 3 + 2],\n//                 m[particle_idx]\n//             );\n//         }\n//     }\n\n//     // Recurse on internal children (if any)\n//     int num_children = octree-&gt;tree_num_internal_children[node_idx];\n//     if (num_children &gt; 0) \n//     {\n//         int first_child = octree-&gt;tree_first_internal_children_idx[node_idx];\n//         for (int i = 0; i &lt; num_children; ++i)\n//         {\n//             int child_idx = first_child + i;\n//             print_octree_nodes(\n//                 octree,\n//                 x,\n//                 m,\n//                 child_idx,\n//                 indent + 1\n//             );\n//         }\n//     }\n// }\n\nLinearOctree get_new_linear_octree(void)\n{\n    LinearOctree linear_octree;\n    linear_octree.particle_morton_indices_deepest_level = NULL;\n    linear_octree.sorted_indices = NULL;\n    linear_octree.tree_num_particles = NULL;\n    linear_octree.tree_num_internal_children = NULL;\n    linear_octree.tree_first_internal_children_idx = NULL;\n    linear_octree.tree_mass = NULL;\n    linear_octree.tree_center_of_mass_x = NULL;\n    linear_octree.tree_center_of_mass_y = NULL;\n    linear_octree.tree_center_of_mass_z = NULL;\n    return linear_octree;\n}\n\n/**\n * \\brief Calculate the bounding box of the system\n * \n * \\param[out] center 3D vector of the center of the bounding box\n * \\param[out] width Width of the bounding box\n * \\param[in] num_particles Number of particles\n * \\param[in] x Array of position vectors\n */\nIN_FILE void calculate_bounding_box(\n    double *restrict center,\n    double *restrict width,\n    const int num_particles,\n    const double *restrict x\n)\n{\n    /* Find the width of the bounding box */\n    double min_x = x[0];\n    double max_x = x[0];\n    double min_y = x[1];\n    double max_y = x[1];\n    double min_z = x[2];\n    double max_z = x[2];\n\n    for (int i = 1; i &lt; num_particles; i++)\n    {\n        min_x = fmin(min_x, x[i * 3 + 0]);\n        max_x = fmax(max_x, x[i * 3 + 0]);\n        min_y = fmin(min_y, x[i * 3 + 1]);\n        max_y = fmax(max_y, x[i * 3 + 1]);\n        min_z = fmin(min_z, x[i * 3 + 2]);\n        max_z = fmax(max_z, x[i * 3 + 2]);\n    }\n\n    center[0] = (max_x + min_x) / 2.0;\n    center[1] = (max_y + min_y) / 2.0;\n    center[2] = (max_z + min_z) / 2.0;\n\n    const double width_x = max_x - min_x;\n    const double width_y = max_y - min_y;\n    const double width_z = max_z - min_z;\n    *width = fmax(fmax(width_x, width_y), width_z);\n}\n\n/**\n * \\brief Compute the 3D Morton indices at level 21 using magic number\n * \n * \\param[out] morton_indices Array of Morton indices\n * \\param[in] object_count Number of particles\n * \\param[in] x Array of position vectors\n * \\param[in] center 3D vector of the center of the bounding box\n * \\param[in] width Width of the bounding box\n * \n * \\ref https://stackoverflow.com/a/18528775, Stack Overflow\n */\nIN_FILE void compute_3d_particle_morton_indices_deepest_level(\n    int64 *restrict morton_indices,\n    const int object_count,\n    const double *restrict x,\n    const double *restrict center,\n    const double width\n)\n{\n    for (int i = 0; i &lt; object_count; i++)\n    {\n        /* Normalize the position */\n        const double x_i = (x[i * 3 + 0] - center[0]) / width + 0.5;\n        const double y_i = (x[i * 3 + 1] - center[1]) / width + 0.5;\n        const double z_i = (x[i * 3 + 2] - center[2]) / width + 0.5;\n\n        /* Compute the morton indices */\n        int64 n_x = x_i * (1 &lt;&lt; 21);\n        int64 n_y = y_i * (1 &lt;&lt; 21);\n        int64 n_z = z_i * (1 &lt;&lt; 21);\n\n        n_x &amp;= 0x1fffff;\n        n_x = (n_x | n_x &lt;&lt; 32) &amp; 0x1f00000000ffff;\n        n_x = (n_x | n_x &lt;&lt; 16) &amp; 0x1f0000ff0000ff;\n        n_x = (n_x | n_x &lt;&lt; 8)  &amp; 0x100f00f00f00f00f;\n        n_x = (n_x | n_x &lt;&lt; 4)  &amp; 0x10c30c30c30c30c3;\n        n_x = (n_x | n_x &lt;&lt; 2)  &amp; 0x1249249249249249;\n\n        n_y &amp;= 0x1fffff;\n        n_y = (n_y | n_y &lt;&lt; 32) &amp; 0x1f00000000ffff;\n        n_y = (n_y | n_y &lt;&lt; 16) &amp; 0x1f0000ff0000ff;\n        n_y = (n_y | n_y &lt;&lt; 8)  &amp; 0x100f00f00f00f00f;\n        n_y = (n_y | n_y &lt;&lt; 4)  &amp; 0x10c30c30c30c30c3;\n        n_y = (n_y | n_y &lt;&lt; 2)  &amp; 0x1249249249249249;\n\n        n_z &amp;= 0x1fffff;\n        n_z = (n_z | n_z &lt;&lt; 32) &amp; 0x1f00000000ffff;\n        n_z = (n_z | n_z &lt;&lt; 16) &amp; 0x1f0000ff0000ff;\n        n_z = (n_z | n_z &lt;&lt; 8)  &amp; 0x100f00f00f00f00f;\n        n_z = (n_z | n_z &lt;&lt; 4)  &amp; 0x10c30c30c30c30c3;\n        n_z = (n_z | n_z &lt;&lt; 2)  &amp; 0x1249249249249249;\n\n        morton_indices[i] = n_x | (n_y &lt;&lt; 1) | (n_z &lt;&lt; 2);\n    }\n}\n\n/**\n * \\brief Perform radix sort on the particles based on their Morton indices\n * \n * \\param morton_indices Array of Morton indices\n * \\param indices Array of indices\n * \\param object_count Number of particles\n * \\param level Level of the Morton indices\n * \n * \\return ErrorStatus\n * \n * \\exception GRAV_MEMORY_ERROR if memory allocation for temporary arrays failed\n */\nIN_FILE ErrorStatus radix_sort_particles_morton_index(\n    int64 *restrict morton_indices,\n    int *restrict indices,\n    const int object_count,\n    const int level\n)\n{\n    /* Calculate constnats */\n    const int RADIX_BITS = 9;\n    const int RADIX_SIZE = 1 &lt;&lt; RADIX_BITS;\n    const int RADIX_MASK = RADIX_SIZE - 1;\n\n    const int num_significant_bits = 3 * level;\n    const int num_passes = (num_significant_bits + RADIX_BITS - 1) / RADIX_BITS;\n\n    /* Allocate memory */\n    int64 *restrict temp_morton_indices = malloc(object_count * sizeof(int64));\n    int *restrict temp_indices = malloc(object_count * sizeof(int));\n    int *restrict count = malloc(RADIX_SIZE * sizeof(int));\n    if (!temp_morton_indices || !temp_indices || !count)\n    {\n        free(count);\n        free(temp_morton_indices);\n        free(temp_indices);\n\n        return WRAP_RAISE_ERROR(\n            GRAV_MEMORY_ERROR,\n            \"Failed to allocate memory for temporary arrays\"\n        );\n    }\n\n    /* Perform LSB radix sort */\n\n    // Flag to indicate whether the sorted array is in temp arrays\n    // This can reduce the number of memcpy to O(1) instead of O(num_passes)\n    bool is_temp = false; \n\n    for (int i = 0; i &lt; num_passes; i++) \n    {\n        // Empty count array\n        for (int j = 0; j &lt; RADIX_SIZE; j++)\n        {\n            count[j] = 0;\n        }\n\n        // Calculate shift for this pass (start from least significant bits)\n        const int shift = i * RADIX_BITS;\n\n        // Count occurrences of each radix value\n        if (is_temp)\n        {\n            for (int j = 0; j &lt; object_count; j++) \n            {\n                count[(temp_morton_indices[j] &gt;&gt; shift) &amp; RADIX_MASK]++;\n            }\n        }\n        else\n        {\n            for (int j = 0; j &lt; object_count; j++) \n            {\n                count[(morton_indices[j] &gt;&gt; shift) &amp; RADIX_MASK]++;\n            }\n        }\n\n        // Get cumulative count\n        int total = 0;\n        for (int j = 0; j &lt; RADIX_SIZE; j++) \n        {\n            int old_count = count[j];\n            count[j] = total;\n            total += old_count;\n        }\n\n        // Sort elements into temporary arrays\n        if (is_temp)\n        {\n            for (int j = 0; j &lt; object_count; j++) \n            {\n                const int dest = count[(temp_morton_indices[j] &gt;&gt; shift) &amp; RADIX_MASK]++;\n\n                morton_indices[dest] = temp_morton_indices[j];\n                indices[dest] = temp_indices[j];\n            }\n        }\n        else\n        {\n            for (int j = 0; j &lt; object_count; j++) \n            {\n                const int dest = count[(morton_indices[j] &gt;&gt; shift) &amp; RADIX_MASK]++;\n\n                temp_morton_indices[dest] = morton_indices[j];\n                temp_indices[dest] = indices[j];\n            }\n        }\n\n        is_temp = !is_temp;\n    }\n\n    // Copy the sorted array to the original array\n    if (is_temp)\n    {\n        memcpy(morton_indices, temp_morton_indices, object_count * sizeof(int64));\n        memcpy(indices, temp_indices, object_count * sizeof(int));\n    }\n\n    free(count);\n    free(temp_morton_indices);\n    free(temp_indices);\n\n    return make_success_error_status();\n}\n\n/**\n * \\brief Perform binary search to find the number of particles in each octant\n * \n * \\param[out] num_particles_per_octant Array to store the number of particles in each octant\n * \\param[in] particle_morton_indices_deepest_level Array of Morton indices at the deepest level\n * \\param[in] node_morton_index_level Morton index of the node\n * \\param[in] start_idx Start index of the particles in the node\n * \\param[in] end_idx End index of the particles in the node\n * \\param[in] leaf_level Level of the leaf nodes\n * \n * \\return ErrorStatus\n * \n * \\exception GRAV_VALUE_ERROR if the Morton index is out of range\n */\nIN_FILE ErrorStatus binary_search_num_particles_per_octant(\n    int *restrict num_particles_per_octant,\n    const int64 *restrict particle_morton_indices_deepest_level,\n    const int64 node_morton_index_level,\n    const int start_idx,\n    const int end_idx,\n    const int leaf_level\n)\n{\n    const int64 prefix = node_morton_index_level * 8;\n    const int level_shift = 3 * (MORTON_MAX_LEVEL - leaf_level);\n\n    int cumulative_count = 0;\n\n    for (int i = 0; i &lt; 8; i++)\n    {\n        // Binary search for the index of last i\n        int left = start_idx + cumulative_count;\n        int right = end_idx;\n        while (left &lt;= right)\n        {\n            const int mid = left + (right - left) / 2;\n            const int mid_octant = ((particle_morton_indices_deepest_level[mid] &gt;&gt; level_shift) - prefix);\n\n            if (mid_octant &gt; 7 || mid_octant &lt; 0)\n            {\n                return raise_error_fmt(\n                    __FILE__,\n                    __LINE__,\n                    __func__,\n                    GRAV_VALUE_ERROR,\n                    \"Morton index %d is out of range [0, 7]\",\n                    mid_octant\n                );\n            }\n\n            if (mid_octant == i &amp;&amp; (mid == end_idx || (((particle_morton_indices_deepest_level[mid + 1] &gt;&gt; level_shift) - prefix)) &gt; i))\n            {\n                num_particles_per_octant[i] = mid - (start_idx + cumulative_count) + 1;\n                cumulative_count += num_particles_per_octant[i];\n                break;\n            }\n            else if (mid_octant &lt;= i)\n            {\n                left = mid + 1;\n            }\n            else\n            {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return make_success_error_status();\n}\n\n/**\n * \\brief Set up a new internal node\n * \n * \\param[out] octree Pointer to the linear octree\n * \\param[out] allocated_internal_nodes_ptr Pointer to the number of allocated internal nodes\n * \\param[in] level Node level\n * \\param[in] node Node index\n * \\param[in] node_morton_index_level Morton index of the node at the current level\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus setup_node(\n    LinearOctree *restrict octree,\n    int *restrict allocated_internal_nodes_ptr,\n    const int level,\n    const int node,\n    const int64 node_morton_index_level\n)\n{\n    ErrorStatus error_status;\n\n    /* Declare variables */\n    int *restrict num_internal_nodes_ptr = &amp;octree-&gt;num_internal_nodes;\n    int *restrict tree_num_particles = octree-&gt;tree_num_particles;\n    int *restrict tree_num_internal_children = octree-&gt;tree_num_internal_children;\n    int *restrict tree_first_particle_sorted_idx = octree-&gt;tree_first_particle_sorted_idx;\n    int *restrict tree_first_internal_children_idx = octree-&gt;tree_first_internal_children_idx;\n\n    double *restrict tree_mass = octree-&gt;tree_mass;\n    double *restrict tree_center_of_mass_x = octree-&gt;tree_center_of_mass_x;\n    double *restrict tree_center_of_mass_y = octree-&gt;tree_center_of_mass_y;\n    double *restrict tree_center_of_mass_z = octree-&gt;tree_center_of_mass_z;\n\n    int num_particles_per_octant[8] = {0};\n\n    /* Find the number of particles in each octant */\n    const int start_idx = tree_first_particle_sorted_idx[node];\n    const int end_idx = start_idx + tree_num_particles[node] - 1;\n    const int child_level = level + 1;\n    error_status = WRAP_TRACEBACK(binary_search_num_particles_per_octant(\n        num_particles_per_octant,\n        octree-&gt;particle_morton_indices_deepest_level,\n        node_morton_index_level,\n        start_idx,\n        end_idx,\n        child_level\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n\n    /* Set up child nodes */\n    bool first_child_found = false;\n    int cumulative_count = 0;\n    for (int i = 0; i &lt; 8; i++)\n    {\n        if (num_particles_per_octant[i] &lt;= 0)\n        {\n            continue;\n        }\n\n        const int child = *num_internal_nodes_ptr;\n\n        // Reallocate memory if necessary\n        if (child &gt;= *allocated_internal_nodes_ptr)\n        {\n            *allocated_internal_nodes_ptr *= 2;\n            int *tmp_tree_num_particles = realloc(tree_num_particles, *allocated_internal_nodes_ptr * sizeof(int));\n            if (!tmp_tree_num_particles)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_num_particles\"\n                );\n            }\n            tree_num_particles = tmp_tree_num_particles;\n            octree-&gt;tree_num_particles = tree_num_particles;\n\n            int *tmp_tree_num_internal_children = realloc(tree_num_internal_children, *allocated_internal_nodes_ptr * sizeof(int));\n            if (!tmp_tree_num_internal_children)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_num_internal_children\"\n                );\n            }\n            tree_num_internal_children = tmp_tree_num_internal_children;\n            octree-&gt;tree_num_internal_children = tree_num_internal_children;\n\n            int *tmp_tree_first_particle_sorted_idx = realloc(tree_first_particle_sorted_idx, *allocated_internal_nodes_ptr * sizeof(int));\n            if (!tmp_tree_first_particle_sorted_idx)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_first_particle_sorted_idx\"\n                );\n            }\n            tree_first_particle_sorted_idx = tmp_tree_first_particle_sorted_idx;\n            octree-&gt;tree_first_particle_sorted_idx = tree_first_particle_sorted_idx;\n\n            int *tmp_tree_first_internal_children_idx = realloc(tree_first_internal_children_idx, *allocated_internal_nodes_ptr * sizeof(int));\n            if (!tmp_tree_first_internal_children_idx)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_first_internal_children_idx\"\n                );\n            }\n            tree_first_internal_children_idx = tmp_tree_first_internal_children_idx;\n            octree-&gt;tree_first_internal_children_idx = tree_first_internal_children_idx;\n\n            double *tmp_tree_mass = realloc(octree-&gt;tree_mass, *allocated_internal_nodes_ptr * sizeof(double));\n            if (!tmp_tree_mass)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_mass\"\n                );\n            }\n            tree_mass = tmp_tree_mass;\n            octree-&gt;tree_mass = tmp_tree_mass;\n\n            double *tmp_tree_center_of_mass_x = realloc(octree-&gt;tree_center_of_mass_x, *allocated_internal_nodes_ptr * sizeof(double));\n            if (!tmp_tree_center_of_mass_x)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_center_of_mass_x\"\n                );\n            }\n            octree-&gt;tree_center_of_mass_x = tmp_tree_center_of_mass_x;\n            tree_center_of_mass_x = tmp_tree_center_of_mass_x;\n\n            double *tmp_tree_center_of_mass_y = realloc(octree-&gt;tree_center_of_mass_y, *allocated_internal_nodes_ptr * sizeof(double));\n            if (!tmp_tree_center_of_mass_y)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_center_of_mass_y\"\n                );\n            }\n            octree-&gt;tree_center_of_mass_y = tmp_tree_center_of_mass_y;\n            tree_center_of_mass_y = tmp_tree_center_of_mass_y;\n\n            double *tmp_tree_center_of_mass_z = realloc(octree-&gt;tree_center_of_mass_z, *allocated_internal_nodes_ptr * sizeof(double));\n            if (!tmp_tree_center_of_mass_z)\n            {\n                return WRAP_RAISE_ERROR(\n                    GRAV_MEMORY_ERROR,\n                    \"Failed to reallocate memory for tree_center_of_mass_z\"\n                );\n            }\n            octree-&gt;tree_center_of_mass_z = tmp_tree_center_of_mass_z;\n            tree_center_of_mass_z = tmp_tree_center_of_mass_z;\n        }\n\n        if (!first_child_found)\n        {\n            first_child_found = true;\n            tree_first_internal_children_idx[node] = child;\n            tree_num_internal_children[node] = 0;\n        }\n\n        // Create a new internal node\n        (*num_internal_nodes_ptr)++;\n        (tree_num_internal_children[node])++;\n\n        tree_num_internal_children[child] = 0;\n        tree_num_particles[child] = num_particles_per_octant[i];\n        tree_first_particle_sorted_idx[child] = start_idx + cumulative_count;\n\n        tree_mass[child] = 0.0;\n        tree_center_of_mass_x[child] = 0.0;\n        tree_center_of_mass_y[child] = 0.0;\n        tree_center_of_mass_z[child] = 0.0;\n\n        cumulative_count += num_particles_per_octant[i];\n    }\n\n    return make_success_error_status();\n}\n\n/**\n * \\brief Helper function to construct the octree\n * \n * \\param[out] octree Pointer to the linear octree\n * \\param[in] allocated_internal_nodes Number of allocated internal nodes\n * \\param[in] max_num_particles_per_leaf Maximum number of particles per leaf\n * \\param[in] num_particles Number of particles\n * \\param[in] x Array of position vectors\n * \\param[in] m Array of masses\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus helper_construct_octree(\n    LinearOctree *restrict octree,\n    int allocated_internal_nodes,\n    const int max_num_particles_per_leaf,\n    const int num_particles,\n    const double *restrict x,\n    const double *restrict m\n)\n{\n    typedef struct Stack\n    {\n        int node;\n        int processed_children;\n        double total_mass;\n        double mass_times_distance[3];\n        struct Stack *parent;\n    } Stack;\n\n    ErrorStatus error_status;\n\n    /* Create a stack */\n    Stack stack[MORTON_MAX_LEVEL + 1];\n    Stack *restrict current_stack = &amp;(stack[0]);\n\n    current_stack-&gt;node = 0;\n    current_stack-&gt;processed_children = -1;\n    current_stack-&gt;total_mass = 0.0;\n    current_stack-&gt;mass_times_distance[0] = 0.0;\n    current_stack-&gt;mass_times_distance[1] = 0.0;\n    current_stack-&gt;mass_times_distance[2] = 0.0;\n    current_stack-&gt;parent = NULL;\n\n    /* Declare variables */\n    int *restrict num_internal_nodes_ptr = &amp;(octree-&gt;num_internal_nodes);\n    const int64 *restrict particle_morton_indices_deepest_level = octree-&gt;particle_morton_indices_deepest_level;\n    const int *restrict sorted_indices = octree-&gt;sorted_indices;\n\n    /* Set up the root node */\n    int level = 0;\n    *num_internal_nodes_ptr = 1;\n\n    octree-&gt;tree_num_particles[0] = num_particles;\n    octree-&gt;tree_num_internal_children[0] = 0;\n    octree-&gt;tree_first_particle_sorted_idx[0] = 0;\n    octree-&gt;tree_mass[0] = 0.0;\n    octree-&gt;tree_center_of_mass_x[0] = 0.0;\n    octree-&gt;tree_center_of_mass_y[0] = 0.0;\n    octree-&gt;tree_center_of_mass_z[0] = 0.0;\n\n    error_status = WRAP_TRACEBACK(setup_node(\n        octree,\n        &amp;allocated_internal_nodes,\n        level,\n        current_stack-&gt;node,\n        0\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n    level++;\n\n    while (true)\n    {\n        const int current_node = current_stack-&gt;node;\n        for (int i = current_stack-&gt;processed_children + 1; i &lt; octree-&gt;tree_num_internal_children[current_node]; i++)\n        {\n            const int child = octree-&gt;tree_first_internal_children_idx[current_node] + i;\n            const int start_idx = octree-&gt;tree_first_particle_sorted_idx[child];\n            const int num_particles = octree-&gt;tree_num_particles[child];\n\n            /* Leaf node */\n            if (num_particles &lt;= max_num_particles_per_leaf || level &gt;= MORTON_MAX_LEVEL)\n            {\n                octree-&gt;tree_num_internal_children[child] = 0;\n\n                // Update the stack\n                for (int j = 0; j &lt; num_particles; j++)\n                {\n                    const int particle_idx = sorted_indices[start_idx + j];\n                    current_stack-&gt;total_mass += m[particle_idx];\n                    current_stack-&gt;mass_times_distance[0] += m[particle_idx] * x[particle_idx * 3 + 0];\n                    current_stack-&gt;mass_times_distance[1] += m[particle_idx] * x[particle_idx * 3 + 1];\n                    current_stack-&gt;mass_times_distance[2] += m[particle_idx] * x[particle_idx * 3 + 2];\n                }\n                current_stack-&gt;processed_children = i;\n\n                continue;\n            }\n\n            /* Internal node */\n            else\n            {\n                const int64 child_morton_index_level = (particle_morton_indices_deepest_level[start_idx] &gt;&gt; (3 * (MORTON_MAX_LEVEL - level)));\n                error_status = WRAP_TRACEBACK(setup_node(\n                    octree,\n                    &amp;allocated_internal_nodes,\n                    level,\n                    child,\n                    child_morton_index_level\n                ));\n                if (error_status.return_code != GRAV_SUCCESS)\n                {\n                    return error_status;\n                }\n\n                Stack *restrict new_item = &amp;(stack[level + 1]);\n                new_item-&gt;node = child;\n                new_item-&gt;processed_children = -1;\n                new_item-&gt;total_mass = 0.0;\n                new_item-&gt;mass_times_distance[0] = 0.0;\n                new_item-&gt;mass_times_distance[1] = 0.0;\n                new_item-&gt;mass_times_distance[2] = 0.0;\n                new_item-&gt;parent = current_stack;\n\n                current_stack = new_item;\n                level++;\n\n                break;\n            }\n        }\n\n        /* Processed all children */\n        if ((current_stack-&gt;processed_children + 1) &gt;= octree-&gt;tree_num_internal_children[current_stack-&gt;node])\n        {\n            /* Update center of mass */\n            octree-&gt;tree_mass[current_node] = current_stack-&gt;total_mass;\n            octree-&gt;tree_center_of_mass_x[current_node] = current_stack-&gt;mass_times_distance[0] / current_stack-&gt;total_mass;\n            octree-&gt;tree_center_of_mass_y[current_node] = current_stack-&gt;mass_times_distance[1] / current_stack-&gt;total_mass;\n            octree-&gt;tree_center_of_mass_z[current_node] = current_stack-&gt;mass_times_distance[2] / current_stack-&gt;total_mass;\n\n            Stack *parent = current_stack-&gt;parent;\n            if (!parent)\n            {\n                break;\n            }\n\n            parent-&gt;total_mass += current_stack-&gt;total_mass;\n            parent-&gt;mass_times_distance[0] += current_stack-&gt;mass_times_distance[0];\n            parent-&gt;mass_times_distance[1] += current_stack-&gt;mass_times_distance[1];\n            parent-&gt;mass_times_distance[2] += current_stack-&gt;mass_times_distance[2];\n\n            current_stack = parent;\n            (current_stack-&gt;processed_children)++;\n            level--;\n        }\n    }\n\n    /* Release unused memory */\n    if (allocated_internal_nodes &gt; (*num_internal_nodes_ptr))\n    {\n        int *restrict tmp_tree_num_particles = realloc(octree-&gt;tree_num_particles, *num_internal_nodes_ptr * sizeof(int));\n        if (!tmp_tree_num_particles)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_num_particles\"\n            );\n        }\n        octree-&gt;tree_num_particles = tmp_tree_num_particles;\n\n        int *restrict tmp_tree_num_internal_children = realloc(octree-&gt;tree_num_internal_children, *num_internal_nodes_ptr * sizeof(int));\n        if (!tmp_tree_num_internal_children)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_num_internal_children\"\n            );\n        }\n        octree-&gt;tree_num_internal_children = tmp_tree_num_internal_children;\n\n        int *restrict tmp_tree_first_particle_sorted_idx = realloc(octree-&gt;tree_first_particle_sorted_idx, *num_internal_nodes_ptr * sizeof(int));\n        if (!tmp_tree_first_particle_sorted_idx)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_first_particle_sorted_idx\"\n            );\n        }\n        octree-&gt;tree_first_particle_sorted_idx = tmp_tree_first_particle_sorted_idx;\n\n        int *restrict tmp_tree_first_internal_children_idx = realloc(octree-&gt;tree_first_internal_children_idx, *num_internal_nodes_ptr * sizeof(int));\n        if (!tmp_tree_first_internal_children_idx)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_first_internal_children_idx\"\n            );\n        }\n        octree-&gt;tree_first_internal_children_idx = tmp_tree_first_internal_children_idx;\n\n        double *restrict tmp_tree_mass = realloc(octree-&gt;tree_mass, *num_internal_nodes_ptr * sizeof(double));\n        if (!tmp_tree_mass)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_mass\"\n            );\n        }\n        octree-&gt;tree_mass = tmp_tree_mass;\n\n        double *restrict tmp_tree_center_of_mass_x = realloc(octree-&gt;tree_center_of_mass_x, *num_internal_nodes_ptr * sizeof(double));\n        if (!tmp_tree_center_of_mass_x)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_center_of_mass_x\"\n            );\n        }\n        octree-&gt;tree_center_of_mass_x = tmp_tree_center_of_mass_x;\n\n        double *restrict tmp_tree_center_of_mass_y = realloc(octree-&gt;tree_center_of_mass_y, *num_internal_nodes_ptr * sizeof(double));\n        if (!tmp_tree_center_of_mass_y)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_center_of_mass_y\"\n            );\n        }\n        octree-&gt;tree_center_of_mass_y = tmp_tree_center_of_mass_y;\n\n        double *restrict tmp_tree_center_of_mass_z = realloc(octree-&gt;tree_center_of_mass_z, *num_internal_nodes_ptr * sizeof(double));\n        if (!tmp_tree_center_of_mass_z)\n        {\n            return WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to reallocate memory for tree_center_of_mass_z\"\n            );\n        }\n        octree-&gt;tree_center_of_mass_z = tmp_tree_center_of_mass_z;\n    }\n\n    return make_success_error_status();\n}\n\nWIN32DLL_API ErrorStatus construct_octree(\n    LinearOctree *restrict octree,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param,\n    const double *restrict box_center,\n    const double box_width\n)\n{\n    ErrorStatus error_status;\n\n    /* Check for pointers */\n    if (!octree)\n    {\n        return WRAP_RAISE_ERROR(GRAV_POINTER_ERROR, \"Octree pointer is NULL\");\n    }\n    if (!system)\n    {\n        return WRAP_RAISE_ERROR(GRAV_POINTER_ERROR, \"System pointer is NULL\");\n    }\n    if (!acceleration_param)\n    {\n        return WRAP_RAISE_ERROR(GRAV_POINTER_ERROR, \"Acceleration parameter pointer is NULL\");\n    }\n\n    const int num_particles = system-&gt;num_particles;\n    const double *restrict x = system-&gt;x;\n    const double *restrict m = system-&gt;m;\n    const int max_num_particles_per_leaf = acceleration_param-&gt;max_num_particles_per_leaf;\n\n    /* Find the width and center of the bounding box */\n    double center[3];\n    if (!box_center || box_width &lt;= 0.0)\n    {\n        calculate_bounding_box(center, &amp;(octree-&gt;box_width), num_particles, x);\n        box_center = center;\n    }\n    else\n    {\n        octree-&gt;box_width = box_width;\n        center[0] = box_center[0];\n        center[1] = box_center[1];\n        center[2] = box_center[2];\n    }\n\n    /* Allocate memory */\n    // Indices\n    octree-&gt;particle_morton_indices_deepest_level = malloc(num_particles * sizeof(int64));\n    octree-&gt;sorted_indices = malloc(num_particles * sizeof(int));\n    if (!octree-&gt;particle_morton_indices_deepest_level || !octree-&gt;sorted_indices)\n    {\n        error_status = WRAP_RAISE_ERROR(\n            GRAV_MEMORY_ERROR,\n            \"Failed to allocate memory for Morton indices and sorted indices\"\n        );\n        goto err_indices_memory_alloc;\n    }\n\n    // Internal nodes\n    // int allocated_internal_nodes = num_particles * 2 / max_num_particles_per_leaf;\n    int allocated_internal_nodes = num_particles;\n\n    octree-&gt;tree_num_particles = malloc(allocated_internal_nodes * sizeof(int));\n    octree-&gt;tree_num_internal_children = malloc(allocated_internal_nodes * sizeof(int));\n    octree-&gt;tree_first_internal_children_idx = malloc(allocated_internal_nodes * sizeof(int));\n    octree-&gt;tree_first_particle_sorted_idx = malloc(allocated_internal_nodes * sizeof(int));\n    octree-&gt;tree_mass = malloc(allocated_internal_nodes * sizeof(double));\n    octree-&gt;tree_center_of_mass_x = malloc(allocated_internal_nodes * sizeof(double));\n    octree-&gt;tree_center_of_mass_y = malloc(allocated_internal_nodes * sizeof(double));\n    octree-&gt;tree_center_of_mass_z = malloc(allocated_internal_nodes * sizeof(double));\n    if (\n        !octree-&gt;tree_num_particles ||\n        !octree-&gt;tree_num_internal_children ||\n        !octree-&gt;tree_first_internal_children_idx ||\n        !octree-&gt;tree_first_particle_sorted_idx ||\n        !octree-&gt;tree_mass ||\n        !octree-&gt;tree_center_of_mass_x ||\n        !octree-&gt;tree_center_of_mass_y ||\n        !octree-&gt;tree_center_of_mass_z\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(\n            GRAV_MEMORY_ERROR,\n            \"Failed to allocate memory for internal nodes\"\n        );\n        goto err_internal_nodes_memory_alloc;\n    }\n\n    /* Initialize the sorted indices */\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        octree-&gt;sorted_indices[i] = i;\n    }\n\n    /* Compute the 3D Morton indices at level 21 */\n    compute_3d_particle_morton_indices_deepest_level(\n        octree-&gt;particle_morton_indices_deepest_level,\n        num_particles,\n        x,\n        center,\n        octree-&gt;box_width\n    );\n\n    /* Sort the particles based on their Morton indices */\n    error_status = WRAP_TRACEBACK(radix_sort_particles_morton_index(\n        octree-&gt;particle_morton_indices_deepest_level,\n        octree-&gt;sorted_indices,\n        num_particles,\n        MORTON_MAX_LEVEL\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto err_radix_sort;\n    }\n\n    /* Construct the octree */\n    error_status = WRAP_TRACEBACK(helper_construct_octree(\n        octree,\n        allocated_internal_nodes,\n        max_num_particles_per_leaf,\n        num_particles,\n        x,\n        m\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto err_construct_octree;\n    }\n\n    return make_success_error_status();\n\nerr_construct_octree:\nerr_radix_sort:\nerr_internal_nodes_memory_alloc:\nerr_indices_memory_alloc:\n    free_linear_octree(octree);\n\n    return error_status;\n}\n\nWIN32DLL_API void free_linear_octree(LinearOctree *restrict octree)\n{\n    free(octree-&gt;particle_morton_indices_deepest_level);\n    free(octree-&gt;sorted_indices);\n    free(octree-&gt;tree_num_particles);\n    free(octree-&gt;tree_num_internal_children);\n    free(octree-&gt;tree_first_particle_sorted_idx);\n    free(octree-&gt;tree_first_internal_children_idx);\n    free(octree-&gt;tree_mass);\n    free(octree-&gt;tree_center_of_mass_x);\n    free(octree-&gt;tree_center_of_mass_y);\n    free(octree-&gt;tree_center_of_mass_z);\n}\n\nWIN32DLL_API bool linear_octree_check_if_included(\n    const int64 morton_index_i,\n    const int64 morton_index_j,\n    const int level\n)\n{\n    return (morton_index_i &gt;&gt; (3 * (MORTON_MAX_LEVEL - level))) == (morton_index_j &gt;&gt; (3 * (MORTON_MAX_LEVEL - level)));\n}\n</code></pre> <p>Figure 2: Morton curve for Morton index 0 to 7. This is the full curve for level 1,         or the first \\(\\frac{1}{8}\\) of the full curve at level 2, etc.</p> <p>Here, we provide a detailed description on constructing a static linear octree using only linear arrays and Morton indices. To build a linear octree, we utilize the idea of Morton code (also known as Z-order or Morton space filling curve). Figure 2 shows a Morton curve at level 1 of the tree. The Morton index is calculated by encoding the spatial coordinate in binary format. For example, at level 1 we have \\(x, y, z \\in \\{0, 1\\}\\). For \\(x = 0, y = 0, z = 1\\), we have the Morton index \\(\\underset{z}{1}\\underset{y}{0}\\underset{x}{0} \\textnormal{ (binary)} = 4\\). For \\(x = 1, y = 1, z = 0\\), we have the Morton index \\(\\underset{z}{0}\\underset{y}{1}\\underset{x}{1} \\textnormal{ (binary)} = 3\\). As we traverse into deeper level, we stack another three bits after the Morton index for each level.  For example, a particle has a local Morton index 5 at level 1 and local Morton index 3 at level 2. The full Morton index at level 2 is obtained by</p> \\[\\begin{equation}     %\\label{}     \\overset{5}{\\overbrace{\\underset{z}{1}\\underset{y}{0}\\underset{x}{1}}}     \\overset{3}{\\overbrace{\\underset{z}{0}\\underset{y}{1}\\underset{x}{1}}}     \\textnormal{ (binary)}     = 43. \\end{equation}\\] <p>Unlike a tree data structure, there is a limit for the depth of the octree. For 64-bit integer, there can only be \\(\\lfloor64 / 3 \\rfloor = 21\\) levels (excluding level 0)  as it takes three bits for each level. This could become an issue for exascale simulations, but this could be resolved by using integers with more bits. </p> <p>The Morton index could be calculated easily using bit-shift operations and loops. In our project, we fixed the Morton indices to 64-bit integers by default and uses magic numbers to compute the Morton indices at level 21 directly without a loop. The magic numbers are generated using the script by <sup>2</sup>. Morton index on each level can then be retrieved with bit-shift operations.</p> <p>Figure 3: Graphical illustration of linear octree. On the top, there are multiple aligned         arrays. Each index represent one tree node, and each array represent a piece         of information stored by the tree node. On below, we have the sorted Morton         indices and the particle indices sorted with Morton indices.         Since they are sorted, only the first index and the number of particles are needed         to obtain the full particle list of each tree node. Tree node 0 is the         root node with \\(N\\) particles. Tree node 1 and 2 are the proper successor of the root node,         with 4 and 8 particles respectively.</p> <p>Now, with the knowledge of Morton index, we can construct a linear octree building algorithm. The tree is represented with multiple aligned arrays, where each index to the arrays corresponds to one internal node. An illustration of the linear octree is provided in figure 3.</p> <ol> <li>Compute the Morton index for all particles at the deepest     level (level 21 for 64-bit integers)</li> <li>Sort the Morton index (e.g. radix sort) along with the particle indices, so that     we have an array of sorted Morton indices, and particle indices     that corresponds to each Morton index.</li> <li>For each particle, starts from the root node,<ul> <li> <p>Check if there are any particles in the corresponding suboctant of the current node.     This can be done with binary search of the suboctant's Morton index at that level.     (The binary search also tells us how many particles are in each child node.)</p> <ul> <li>If not, instantiate a new child node for that suboctant by assigning a tree index.     Backpropogate the mass and coordinate all the way to the root node.</li> <li>Otherwise, traverse deeper into the child node.</li> </ul> </li> </ul> </li> </ol> <p>Side note: We do not know beforehand how many internal nodes there will be. Therefore, the arrays might become full during construction. By using a dynamic array (one that doubles in size whenever it is full), we can build an octree with as many internal nodes as needed.</p>"},{"location":"docs/documentations/barnes_hut/#tree-traversal","title":"Tree traversal","text":"Source code (Click to expand) <pre><code>/**\n * \\file acceleration_barnes_hut.c\n * \\brief Implementation of Barnes-Hut algorithm\n * \n * \\author Ching-Yin Ng\n */\n\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\n#ifdef USE_OPENMP\n#include &lt;omp.h&gt;\n#endif\n\n#include \"acceleration.h\"\n#include \"linear_octree.h\"\n\n/**\n * \\brief Helper function to compute acceleration\n * \n * \\param[out] a Array of acceleration vectors to be modified\n * \\param[in] system Pointer to the gravitational system\n * \\param[in] acceleration_param Pointer to the acceleration parameters\n * \\param[in] octree Pointer to the linear octree\n */\nIN_FILE void helper_compute_acceleration(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param,\n    const LinearOctree *restrict octree\n);\n\nWIN32DLL_API ErrorStatus acceleration_barnes_hut(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param\n)\n{\n    ErrorStatus error_status;\n\n    /* Empty the input array */\n    const int num_particles = system-&gt;num_particles;\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        a[i * 3 + 0] = 0.0;\n        a[i * 3 + 1] = 0.0;\n        a[i * 3 + 2] = 0.0;\n    }\n\n    /* Construct octree */\n    LinearOctree octree = get_new_linear_octree();\n    error_status = WRAP_TRACEBACK(construct_octree(\n        &amp;octree,\n        system,\n        acceleration_param,\n        NULL,\n        -1.0\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n\n    /* Compute acceleration */\n    helper_compute_acceleration(\n        a,\n        system,\n        acceleration_param,\n        &amp;octree\n    );\n\n    /* Free memory */\n    free_linear_octree(&amp;octree);\n\n    return make_success_error_status();\n}\n\nIN_FILE void helper_compute_acceleration(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param,\n    const LinearOctree *restrict octree\n)\n{\n    typedef struct Stack\n    {\n        int node;\n        int processed_children;\n        struct Stack *parent;\n    } Stack;\n\n    /* Declare variables */\n    const int num_particles = system-&gt;num_particles;\n    const double *restrict x = system-&gt;x;\n    const double *restrict m = system-&gt;m;\n    const double G = system-&gt;G;\n    const double softening_length = acceleration_param-&gt;softening_length;\n    const double softening_length_squared = softening_length * softening_length;\n    const double opening_angle = acceleration_param-&gt;opening_angle;\n    const double opening_angle_squared = opening_angle * opening_angle;\n\n    const double box_length = octree-&gt;box_width * 2.0;\n    const int64 *restrict particle_morton_indices_deepest_level = octree-&gt;particle_morton_indices_deepest_level;\n    const int *restrict sorted_indices = octree-&gt;sorted_indices;\n    const int *restrict tree_num_particles = octree-&gt;tree_num_particles;\n    const int *restrict tree_num_internal_children = octree-&gt;tree_num_internal_children;\n    const int *restrict tree_first_particle_sorted_idx = octree-&gt;tree_first_particle_sorted_idx;\n    const int *restrict tree_first_internal_children_idx = octree-&gt;tree_first_internal_children_idx;\n    const double *restrict tree_mass = octree-&gt;tree_mass;\n    const double *restrict tree_center_of_mass_x = octree-&gt;tree_center_of_mass_x;\n    const double *restrict tree_center_of_mass_y = octree-&gt;tree_center_of_mass_y;\n    const double *restrict tree_center_of_mass_z = octree-&gt;tree_center_of_mass_z;\n\n#ifdef USE_OPENMP\n    #pragma omp parallel for\n#endif\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        const int idx_i = sorted_indices[i];    // For coalesced memory access\n        const int64 morton_index_i = particle_morton_indices_deepest_level[idx_i];\n        const double x_i[3] = {x[idx_i * 3 + 0], x[idx_i * 3 + 1], x[idx_i * 3 + 2]};\n\n        Stack stack[MORTON_MAX_LEVEL + 1];\n        Stack *current_stack = &amp;(stack[0]);\n        current_stack-&gt;processed_children = -1;\n        current_stack-&gt;node = 0;\n        current_stack-&gt;parent = NULL;\n        double acceleration[3] = {0.0, 0.0, 0.0};\n\n        int level = 1;\n\n        /* Tree walk */\n        while (true)\n        {\n            const int current_node = current_stack-&gt;node;\n            for (int j = (current_stack-&gt;processed_children) + 1; j &lt; tree_num_internal_children[current_node]; j++)\n            {\n                const int child_j = tree_first_internal_children_idx[current_node] + j;\n                const int num_children_j = tree_num_internal_children[child_j];\n                const int start_idx_j = tree_first_particle_sorted_idx[child_j];\n\n                // If object i is included, then we need to traverse deeper\n                const bool is_included = linear_octree_check_if_included(\n                    morton_index_i,\n                    particle_morton_indices_deepest_level[sorted_indices[start_idx_j]],\n                    level\n                );\n\n                // Check Barnes-Hut criteria\n                if (!is_included)\n                {\n                    const double R[3] = {\n                        x_i[0] - tree_center_of_mass_x[child_j],\n                        x_i[1] - tree_center_of_mass_y[child_j],\n                        x_i[2] - tree_center_of_mass_z[child_j]\n                    };\n                    const double box_length_j = box_length / (2 &lt;&lt; level);\n                    const double norm_square = R[0] * R[0] + R[1] * R[1] + R[2] * R[2];\n\n                    // Check if box_length_j / norm &lt; opening_angle\n                    // Use squared values to avoid sqrt\n                    if ((box_length_j * box_length_j) &lt; opening_angle_squared * norm_square)\n                    {\n                        const double R_norm = sqrt(\n                            norm_square + softening_length_squared\n                        );\n\n                        const double temp_value = G * tree_mass[child_j] / (R_norm * R_norm * R_norm);\n                        acceleration[0] -= temp_value * R[0];\n                        acceleration[1] -= temp_value * R[1];\n                        acceleration[2] -= temp_value * R[2];\n\n                        current_stack-&gt;processed_children = j;\n                        continue;\n                    }\n                }\n\n                /* Traverse deeper */\n\n                /* Leaf node */\n                if (num_children_j &lt;= 0)\n                {\n                    const int num_particles_j = tree_num_particles[child_j];\n                    for (int k = 0; k &lt; num_particles_j; k++)\n                    {\n                        const int idx_j = sorted_indices[start_idx_j + k];\n                        if (idx_i == idx_j)\n                        {\n                            continue;\n                        }\n\n                        // Calculate \\vec{R} and its norm\n                        const double R[3] = {\n                            x_i[0] - x[idx_j * 3 + 0],\n                            x_i[1] - x[idx_j * 3 + 1],\n                            x_i[2] - x[idx_j * 3 + 2]\n                        };\n                        const double R_norm = sqrt(\n                            R[0] * R[0] + \n                            R[1] * R[1] + \n                            R[2] * R[2] +\n                            softening_length_squared\n                        );\n\n                        // Calculate the acceleration\n                        const double temp_value = G * m[idx_j] / (R_norm * R_norm * R_norm);\n                        acceleration[0] -= temp_value * R[0];\n                        acceleration[1] -= temp_value * R[1];\n                        acceleration[2] -= temp_value * R[2];\n                    }\n\n                    current_stack-&gt;processed_children = j;\n                    continue;\n                }\n\n                /* Internal node */\n                else\n                {\n                    Stack *new_item = &amp;(stack[level + 1]);\n                    new_item-&gt;node = child_j;\n                    new_item-&gt;processed_children = -1;\n                    new_item-&gt;parent = current_stack;\n\n                    current_stack = new_item;\n                    level++;\n                    break;\n                }\n            }\n\n            if ((current_stack-&gt;processed_children + 1) &gt;= tree_num_internal_children[current_stack-&gt;node])\n            {\n                Stack *parent_stack = current_stack-&gt;parent;\n                if (!parent_stack)\n                {\n                    break;\n                }\n\n                current_stack = parent_stack;\n                current_stack-&gt;processed_children += 1;\n                level--;\n            }\n        }\n\n        a[idx_i * 3 + 0] = acceleration[0];\n        a[idx_i * 3 + 1] = acceleration[1];\n        a[idx_i * 3 + 2] = acceleration[2];\n    }\n}\n</code></pre> <p>To compute the acceleration, we use a stack to traverse the tree recursively:</p> <ol> <li>Push the root node to the stack.</li> <li>While the stack is not empty:<ul> <li>2.1 Pop the top node from the stack.</li> <li>2.2 If the node is a leaf node, compute the acceleration directly.</li> <li>2.3 If the node is not a leaf node, check if it passes the opening angle criterion.     If yes, compute the acceleration using the center of mass of the node.     Otherwise, push all child nodes to the stack.</li> </ul> </li> </ol> <p>Danger</p> <p>We need to check whether the current node is included in the branch to avoid self-interaction. This can be done by a simple check of the Morton index.</p>"},{"location":"docs/documentations/barnes_hut/#benchmark","title":"Benchmark","text":"<p>Here we provide a simple benchmark of the Barnes-Hut algorithm compared to the brute-force  algorithm. It was done on Macbook Air M1. The brute-force algorithm spent 18.6 seconds  on \\(N = 10^5\\), while the Barnes-Hut algorithm with \\(\\theta = 1\\) and \\(\\theta = 0.5\\) spent \\(7.94\\) s on \\(N = 10^6\\) and \\(18.2\\) s on \\(N = 10^7\\) respectively. This shows that Barnes-Hut algorithm could handle 10-100 times more particles than the brute force algorithm.</p> <p>(For the benchmark, the particles are uniformly distributed where \\(\\{x, y, z\\} \\sim U(-1, 1)\\))</p> <ol> <li> <p>Josh Barnes and Piet Hut. A hierarchical \\(O\\)(\\(N\\) $\\log $ \\(N\\)) force-calculation algorithm. Nature, 324(6096):446\u2013449, December 1986. URL: https://www.nature.com/articles/324446a0 (visited on 2025-01-19), doi:10.1038/324446a0.\u00a0\u21a9</p> </li> <li> <p>Gabriel (https://stackoverflow.com/users/293195/gabriel). How to compute a 3d morton number (interleave the bits of 3 ints). Stack Overflow. version: 2021-09-18. URL: https://stackoverflow.com/a/18528775, arXiv:https://stackoverflow.com/a/18528775.\u00a0\u21a9</p> </li> </ol>"},{"location":"docs/documentations/comoving_coordinates/","title":"Comoving coordinates","text":"Source code (Click to expand) <pre><code>/**\n * \\file integrator_cosmology_leapfrog.c\n * \\brief Leapfrog integrator for cosmological simulations.\n * \n * \\author Ching-Yin Ng\n */\n\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"acceleration.h\"\n#include \"common.h\"\n#include \"cosmology.h\"\n#include \"error.h\"\n#include \"integrator.h\"\n#include \"output.h\"\n#include \"progress_bar.h\"\n#include \"settings.h\"\n#include \"system.h\"\n#include \"utils.h\"\n#include \"math_functions.h\"\n\n\nWIN32DLL_API ErrorStatus leapfrog_cosmology(\n    CosmologicalSystem *restrict system,\n    OutputParam *restrict output_param,\n    SimulationStatus *restrict simulation_status,\n    Settings *restrict settings,\n    const double a_final,\n    const int num_steps,\n    const int pm_grid_size\n)\n{\n    /* Declare variables */\n    ErrorStatus error_status;\n\n    const int num_particles = system-&gt;num_particles;\n    double *restrict x = system-&gt;x;\n    double *restrict v = system-&gt;v;\n    const double H0 = system-&gt;h * 100.0;\n    const double omega_m = system-&gt;omega_m;\n    const double omega_lambda = system-&gt;omega_lambda;\n\n    bool is_output = (output_param-&gt;method != OUTPUT_METHOD_DISABLED);\n    int *restrict output_count_ptr = &amp;(output_param-&gt;output_count_);\n    const double output_interval = output_param-&gt;output_interval;\n    double next_output_time = output_interval;\n\n    const double t0 = log(system-&gt;scale_factor);\n    const double tf = log(a_final);\n    double *restrict t_ptr = &amp;(simulation_status-&gt;t);\n    *t_ptr = t0;\n    int64 *restrict num_steps_ptr = &amp;(simulation_status-&gt;num_steps);\n\n    const bool enable_progress_bar = settings-&gt;enable_progress_bar;\n\n    double H_a;\n\n    /* Allocate memory */\n    double *restrict momentum = malloc(num_particles * 3 * sizeof(double));\n    double *restrict a = malloc(num_particles * 3 * sizeof(double));\n\n    // Check if memory allocation is successful\n    if (!momentum || !a)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for arrays\");\n        goto err_memory;\n    }\n\n    /* Get mean background density */\n    const double G = 6.67430e-8 * (\n        system-&gt;unit_mass\n        * system-&gt;unit_time * system-&gt;unit_time\n        / (system-&gt;unit_length * system-&gt;unit_length * system-&gt;unit_length)\n    );\n\n    /* Initial output */\n    if (is_output &amp;&amp; output_param-&gt;output_initial)\n    {\n        error_status = WRAP_TRACEBACK(output_snapshot_cosmology(\n            output_param,\n            system,\n            simulation_status,\n            settings\n        ));\n        if (error_status.return_code != GRAV_SUCCESS)\n        {\n            goto err_initial_output;\n        }\n    }\n\n    /* Set periodic boundary conditions */\n    set_periodic_boundary_conditions(system);\n\n    /* Initialize momentum */\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        for (int j = 0; j &lt; 3; j++)\n        {\n            momentum[i * 3 + j] = (system-&gt;scale_factor) * (system-&gt;scale_factor) * v[i * 3 + j];\n        }\n    }\n\n    /* Compute initial acceleration */\n    error_status = WRAP_TRACEBACK(acceleration_PM(\n        a,\n        system,\n        G,\n        pm_grid_size\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto err_acceleration;\n    }\n\n    /* Main Loop */\n    double dt = (tf - t0) / num_steps;\n    int64 total_num_steps = (int64) ceil((tf - t0) / dt);\n    ProgressBarParam progress_bar_param;\n    if (enable_progress_bar)\n    {\n        error_status = WRAP_TRACEBACK(start_progress_bar(&amp;progress_bar_param, total_num_steps));\n        if (error_status.return_code != GRAV_SUCCESS)\n        {\n            goto err_start_progress_bar;\n        }\n    }\n\n    simulation_status-&gt;dt = dt;\n    *num_steps_ptr = 0;\n    while (*num_steps_ptr &lt; total_num_steps)\n    {\n        /* Check dt overshoot */\n        if (*t_ptr + dt &gt; tf)\n        {\n            dt = tf - *t_ptr;\n        }\n        simulation_status-&gt;dt = dt;\n\n        /* Kick (p_1/2) */\n        H_a = compute_H(system-&gt;scale_factor, H0, omega_m, omega_lambda);\n        for (int i = 0; i &lt; num_particles; i++)\n        {\n            for (int j = 0; j &lt; 3; j++)\n            {\n                momentum[i * 3 + j] -= (0.5 * dt) * a[i * 3 + j] / H_a;\n            }\n        }\n        *t_ptr += 0.5 * dt;\n        system-&gt;scale_factor = exp(*t_ptr);\n\n        /* Drift (x_1) */\n        H_a = compute_H(system-&gt;scale_factor, H0, omega_m, omega_lambda);\n        for (int i = 0; i &lt; num_particles; i++)\n        {\n            for (int j = 0; j &lt; 3; j++)\n            {\n                x[i * 3 + j] += dt * momentum[i * 3 + j] / ((system-&gt;scale_factor) * (system-&gt;scale_factor) * H_a);\n            }\n        }\n\n        /* Set periodic boundary conditions */\n        set_periodic_boundary_conditions(system);\n\n        /* Kick (p_1) */\n        error_status = WRAP_TRACEBACK(acceleration_PM(\n            a,\n            system,\n            G,\n            pm_grid_size\n        ));\n        if (error_status.return_code != GRAV_SUCCESS)\n        {\n            goto err_acceleration;\n        }\n\n        for (int i = 0; i &lt; num_particles; i++)\n        {\n            for (int j = 0; j &lt; 3; j++)\n            {\n                momentum[i * 3 + j] -= (0.5 * dt) * a[i * 3 + j] / H_a;\n            }\n        }\n\n        (*num_steps_ptr)++;\n        *t_ptr = t0 + (*num_steps_ptr) * dt;\n        system-&gt;scale_factor = exp(*t_ptr);\n\n        /* Store solution */\n        if (is_output &amp;&amp; system-&gt;scale_factor &gt;= next_output_time)\n        {\n            /* Get velocity from momentum */\n            for (int i = 0; i &lt; num_particles; i++)\n            {\n                for (int j = 0; j &lt; 3; j++)\n                {\n                    v[i * 3 + j] = momentum[i * 3 + j] / (system-&gt;scale_factor * system-&gt;scale_factor);\n                }\n            }\n            error_status = WRAP_TRACEBACK(output_snapshot_cosmology(\n                output_param,\n                system,\n                simulation_status,\n                settings\n            ));\n            if (error_status.return_code != GRAV_SUCCESS)\n            {\n                goto err_output;\n            }\n\n            next_output_time = (*output_count_ptr) * output_interval;\n        }\n\n        if (enable_progress_bar)\n        {\n            update_progress_bar(&amp;progress_bar_param, *num_steps_ptr, false);\n        }\n\n        /* Check exit */\n        if (*(settings-&gt;is_exit_ptr))\n        {\n            break;\n        }\n    }\n\n    if (enable_progress_bar)\n    {\n        update_progress_bar(&amp;progress_bar_param, *num_steps_ptr, true);\n    }\n\n    free(momentum);\n    free(a);\n\n    return make_success_error_status();\n\nerr_output:\nerr_acceleration:\nerr_start_progress_bar:\nerr_initial_output:\nerr_memory:\n    free(momentum);\n    free(a);\n\n    return error_status;\n}\n</code></pre> <p>To account for cosmological expansion, we need to use comoving coordinates. We first review particle motion in comoving coordinates following LSSU<sup>1</sup>. In comoving coordinates, we have</p> \\[\\begin{equation}     %\\label{}     \\textbf{r} = a(t) \\textbf{x}, \\end{equation}\\] <p>where \\(\\textbf{x}\\) is a vector in comoving coordinates and \\(a(t)\\) is the scale factor.  We may express the field equation as</p> \\[\\begin{equation}     \\label{eqn:poisson_peculiar}     \\nabla^2 \\phi = 4 \\pi G [\\rho - \\overline{\\rho}] a^2, \\end{equation}\\] <p>where \\(\\phi\\) is the peculiar potential, \\(\\rho\\) and \\(\\overline{\\rho}\\) are the density and average background density respectively. Note that the gradient is taken with respect to \\(\\textbf{x}\\).  In addition, we have the proper velocity of a particle</p> \\[\\begin{equation}     %\\label{}     \\textbf{u} = a \\dot{\\textbf{x}} + \\textbf{x} \\dot{a}, \\end{equation}\\] <p>so that the Lagrangian for the particle motion is</p> \\[\\begin{equation}     %\\label{}     \\mathcal{L} = \\frac{1}{2} m (a \\dot{\\textbf{x}} + \\textbf{x} \\dot{a})^2 - m \\Phi. \\end{equation}\\] <p>The canonical transformation</p> \\[\\begin{equation}     %\\label{}     \\mathcal{L} \\to \\mathcal{L} - \\frac{\\mathrm{d}\\psi}{\\mathrm{d}t},     \\quad \\psi = \\frac{1}{2} m a \\dot{a} x^2,  \\end{equation}\\] <p>reduces the Lagrangian to</p> \\[\\begin{equation}     %\\label{}     \\mathcal{L} = \\frac{1}{2} m a^2 \\dot{x}^2 - m \\phi,     \\quad \\phi = \\Phi + \\frac{1}{2} a \\ddot{a} x^2. \\end{equation}\\] <p>Now, we could define the canonical momentum</p> \\[\\begin{equation}     \\label{eqn:canonical_momentum}     \\textbf{p} = m a^2 \\dot{x},     \\quad \\frac{\\mathrm{d}\\textbf{p}}{\\mathrm{d}t} = - m \\nabla \\phi. \\end{equation}\\] <p>With the proper peculiar velocity</p> \\[\\begin{equation}     %\\label{}     \\textbf{v}_{\\textnormal{pec} } = a \\dot{\\textbf{x}}, \\end{equation}\\] <p>we obtain from the canonical momentum equation,</p> \\[\\begin{equation}     \\label{eqn:peculiar_velocity_derivative}     \\frac{\\mathrm{d}\\textbf{v}_\\textnormal{pec} }{\\mathrm{d}t}     + \\textbf{v}_\\textnormal{pec}  \\frac{\\dot{a}}{a}     = - \\frac{\\nabla \\phi}{a}. \\end{equation}\\] <p>In our program, since matter is the main component that contributes to the density perturbation, we rewrite the poisson equation as</p> \\[\\begin{equation}     %\\label{}     \\nabla^2 \\phi = \\frac{4 \\pi G}{a} [\\rho_{m, \\textnormal{comoving} } - \\overline{\\rho}_{m, \\textnormal{comoving} }]. \\end{equation}\\] <p>where</p> \\[\\begin{equation}     %\\label{}     \\rho_{m, \\textnormal{comoving} } - \\overline{\\rho}_{m, \\textnormal{comoving} }     = a^3 [\\rho_{m} - \\overline{\\rho}_{m}]. \\end{equation}\\] <p>In fact, we can even drop the background density term since we only care about the acceleration \\(\\mathbf{a} = - \\nabla \\phi\\). Also, instead of the canonical momentum, we define a conjugate momentum</p> \\[\\begin{equation}     %\\label{}     \\textbf{p}' = a^2 \\dot{x} = a \\textbf{v}_{\\textnormal{pec} },     \\quad \\frac{\\mathrm{d}\\textbf{p}'}{\\mathrm{d}t} = - \\nabla \\phi. \\end{equation}\\] <p>Following Gadget-4<sup>2</sup>, we use \\(\\tau = \\ln a\\) as the integration variable. We have</p> \\[\\begin{equation}     \\frac{\\mathrm{d} a}{\\mathrm{d} \\tau}     = \\frac{\\mathrm{d} a}{\\mathrm{d} \\ln a}     = \\left(\\frac{\\mathrm{d} \\ln a}{\\mathrm{d} a} \\right)^{-1}     = a, \\end{equation}\\] \\[\\begin{equation}     \\frac{\\mathrm{d} \\textbf{p}'}{\\mathrm{d} \\tau}     = \\frac{\\mathrm{d} a}{\\mathrm{d} \\tau} \\frac{\\mathrm{d}t}{\\mathrm{d}a} \\frac{\\mathrm{d} \\textbf{p}'}{\\mathrm{d} t}     = - \\nabla \\phi \\frac{a}{\\dot{a}}     = - \\frac{\\nabla \\phi}{H(a)}, \\end{equation}\\] <p>where</p> \\[\\begin{equation}     H(a) = H_0 \\sqrt{\\frac{\\Omega_{m, 0}}{a^{3} } + \\frac{1 - \\Omega}{a^{2}} + \\Omega_{\\Lambda, 0}}\\,\\,, \\end{equation}\\] <p>assuming \\(\\Omega_{\\textnormal{radiation} } / a^4 \\sim 0\\). For \\(\\textbf{x}\\),</p> \\[\\begin{equation}     %\\label{}     \\frac{\\partial \\textbf{x}}{\\partial \\tau}     = \\frac{\\mathrm{d} a}{\\mathrm{d} \\tau} \\frac{\\mathrm{d}t}{\\mathrm{d}a}  \\dot{x}     = \\frac{a}{\\dot{a}} \\left( \\frac{\\textbf{p}'}{a^2} \\right)     = \\frac{\\textbf{p}'}{a^2 H(a)}. \\end{equation}\\] <p>With these relations, we could now do time integration using \\(\\textbf{x}\\) and \\(\\textbf{p}'\\) in comoving coordinates. </p> <ol> <li> <p>P. J. E. Peebles. The large-scale structure of the universe. Princeton University Press, 1980.\u00a0\u21a9</p> </li> <li> <p>Volker Springel, R\u00fcdiger Pakmor, Oliver Zier, and Martin Reinecke. Simulating cosmic structure formation with the gadget-4 code. Monthly Notices of the Royal Astronomical Society, 506(2):2871\u20132949, 07 2021. doi:10.1093/mnras/stab1855.\u00a0\u21a9</p> </li> </ol>"},{"location":"docs/documentations/force_softening/","title":"Force Softening","text":"<p>To avoid singularity for r = 0, we implemented a very simple force softening model: <pre><code>const double R_norm = sqrt(\n    R[0] * R[0] + \n    R[1] * R[1] + \n    R[2] * R[2] +\n    softening_length * softening_length\n);\n</code></pre></p>"},{"location":"docs/documentations/integrators/","title":"Integrators","text":""},{"location":"docs/documentations/integrators/#simple-methods","title":"Simple methods","text":"<p>Below are four simple fixed step size methods to simulate the system with a given step size \\(\\Delta t\\).</p> Simple methods Euler Euler Cromer Fourth Order Runge-Kutta (RK4) Leapfrog"},{"location":"docs/documentations/integrators/#embedded-runge-kutta-methods","title":"Embedded Runge-Kutta methods","text":"<p>Embedded RK methods are adaptive methods that decides the step size automatically based on the estimated error. They can resolve close encounters but fail to conserve energy over long time scele.</p> Embdedded Runge-Kutta methods Recommended tolerance (for reference only) Runge\u2013Kutta\u2013Fehlberg 4(5) \\(10^{-8}\\) to \\(10^{-14}\\) Dormand\u2013Prince method (DOPRI) 5(4) \\(10^{-8}\\) to \\(10^{-14}\\) Verner's method (DVERK) 6(5) \\(10^{-8}\\) to \\(10^{-14}\\) Runge\u2013Kutta\u2013Fehlberg 7(8) \\(10^{-4}\\) to \\(10^{-8}\\)"},{"location":"docs/documentations/integrators/#ias15","title":"IAS15","text":"<p>IAS15 (Implicit integrator with Adaptive time Stepping, 15th order) is a highly optimized integrator with extremely high accuracy. The recommended tolerance is \\(10^{-9}\\). Since the integrator is 15th order, changing the tolerance results in little improvement in performance, but a huge penalty in accuracy. Therefore, it is not recommended to change this tolerance.</p>"},{"location":"docs/documentations/integrators/#whfast","title":"WHFast","text":"<p>WHFast is a second order symplectic method with fixed step size, which conserves  energy over long integration period. This integrator is suitable for stable central mass systems like the solar system.</p>"},{"location":"docs/documentations/massless_acceleration/","title":"Massless acceleration","text":"Source code (Click to expand) <pre><code>/**\n * \\file acceleration.c\n * \\brief Functions for computing gravitational acceleration\n * \n * \\author Ching-Yin Ng\n */\n\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"acceleration.h\"\n#include \"common.h\"\n#include \"error.h\"\n#include \"math_functions.h\"\n#include \"system.h\"\n#include \"utils.h\"\n\n/**\n * \\brief Check the acceleration method\n * \n * \\param acceleration_method Acceleration method\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus check_acceleration_method(const int acceleration_method);\n\n/**\n * \\brief Compute acceleration with direct pairwise method\n * \n * \\param a Array of acceleration vectors to be modified\n * \\param system Pointer to the gravitational system\n * \\param acceleration_param Pointer to the acceleration parameters\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus acceleration_pairwise(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param\n);\n\n/**\n * \\brief Compute acceleration with direct pairwise method,\n *        ignoring the contribution of massless particles\n * \n * \\param a Array of acceleration vectors to be modified\n * \\param system Pointer to the gravitational system\n * \\param acceleration_param Pointer to the acceleration parameters\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus acceleration_massless(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param\n);\n\n\nWIN32DLL_API AccelerationParam get_new_acceleration_param(void)\n{\n    AccelerationParam acceleration_param = {\n        .method = ACCELERATION_METHOD_PAIRWISE,\n        .opening_angle = 1.0,\n        .softening_length = 0.0,\n        .max_num_particles_per_leaf = -1\n    };\n    return acceleration_param;\n}\n\nWIN32DLL_API ErrorStatus finalize_acceleration_param(\n    AccelerationParam *restrict acceleration_param\n)\n{\n    ErrorStatus error_status;\n\n    /* Check the acceleration method */\n    error_status = WRAP_TRACEBACK(\n        check_acceleration_method(acceleration_param-&gt;method)\n    );\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n\n    /* Check the softening length */\n    if (acceleration_param-&gt;softening_length &lt; 0.0)\n    {\n        return raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n            GRAV_VALUE_ERROR,\n            \"Softening length is negative. Got: %.3g\",\n            acceleration_param-&gt;softening_length\n        );\n    }\n\n    /* Check the opening angle */\n    if (\n        acceleration_param-&gt;method == ACCELERATION_METHOD_BARNES_HUT\n        &amp;&amp; acceleration_param-&gt;opening_angle &lt; 0.0\n    )\n    {\n        return raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n            GRAV_VALUE_ERROR,\n            \"Opening angle is negative. Got: %.3g\",\n            acceleration_param-&gt;opening_angle\n        );\n    }\n\n    /* Check the maximum number of particles per leaf */\n    if (acceleration_param-&gt;method == ACCELERATION_METHOD_BARNES_HUT)\n    {\n        if (acceleration_param-&gt;max_num_particles_per_leaf == -1)\n        {\n            acceleration_param-&gt;max_num_particles_per_leaf = 1;\n        }\n        else if (acceleration_param-&gt;max_num_particles_per_leaf &lt; 1)\n        {\n            return raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n                GRAV_VALUE_ERROR,\n                \"Maximum number of particles per leaf must be positive. Got: %d\",\n                acceleration_param-&gt;max_num_particles_per_leaf\n            );\n        }\n    }\n\n    return make_success_error_status();\n}\n\nWIN32DLL_API ErrorStatus acceleration(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param\n)\n{\n    switch (acceleration_param-&gt;method)\n    {\n        case ACCELERATION_METHOD_PAIRWISE:\n            return acceleration_pairwise(a, system, acceleration_param);\n        case ACCELERATION_METHOD_MASSLESS:\n            return acceleration_massless(a, system, acceleration_param);\n        case ACCELERATION_METHOD_BARNES_HUT:\n            return acceleration_barnes_hut(a, system, acceleration_param);\n        default:\n        {\n            return raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n                GRAV_VALUE_ERROR,\n                \"Unknown acceleration method. Got: %d\",\n                acceleration_param-&gt;method\n            );\n        }\n    }\n}\n\nIN_FILE ErrorStatus check_acceleration_method(const int acceleration_method)\n{\n    switch (acceleration_method)\n    {\n        case ACCELERATION_METHOD_PAIRWISE:\n        case ACCELERATION_METHOD_MASSLESS:\n        case ACCELERATION_METHOD_BARNES_HUT:\n            break;\n        default:\n        {\n            return raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n                GRAV_VALUE_ERROR,\n                \"Unknown acceleration method. Got: %d\",\n                acceleration_method\n            );\n        }\n    }\n\n    return make_success_error_status();\n}\n\nIN_FILE ErrorStatus acceleration_pairwise(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param\n)\n{\n    const int num_particles = system-&gt;num_particles;\n    const double *x = system-&gt;x;\n    const double *m = system-&gt;m;\n    const double G = system-&gt;G;\n    const double softening_length = acceleration_param-&gt;softening_length;\n\n    /* Empty the input array */\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        a[i * 3 + 0] = 0.0;\n        a[i * 3 + 1] = 0.0;\n        a[i * 3 + 2] = 0.0;\n    }\n\n    /* Compute the pairwise acceleration */\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        const double m_i = m[i];\n        for (int j = i + 1; j &lt; num_particles; j++)\n        {\n            // Calculate \\vec{R} and its norm\n            const double R[3] = {\n                x[i * 3 + 0] - x[j * 3 + 0],\n                x[i * 3 + 1] - x[j * 3 + 1],\n                x[i * 3 + 2] - x[j * 3 + 2]\n            };\n            const double R_norm = sqrt(\n                R[0] * R[0] + \n                R[1] * R[1] + \n                R[2] * R[2] +\n                softening_length * softening_length\n            );\n\n            // Calculate the acceleration\n            const double temp_value = G / (R_norm * R_norm * R_norm);\n            const double m_j = m[j];\n            double temp_vec[3] = {\n                temp_value * R[0],\n                temp_value * R[1],\n                temp_value * R[2]\n            };\n            a[i * 3 + 0] -= temp_vec[0] * m_j;\n            a[i * 3 + 1] -= temp_vec[1] * m_j;\n            a[i * 3 + 2] -= temp_vec[2] * m_j;\n            a[j * 3 + 0] += temp_vec[0] * m_i;\n            a[j * 3 + 1] += temp_vec[1] * m_i;\n            a[j * 3 + 2] += temp_vec[2] * m_i;\n        }\n    }\n\n    return make_success_error_status();\n}\n\nIN_FILE ErrorStatus acceleration_massless(\n    double *restrict a,\n    const System *restrict system,\n    const AccelerationParam *restrict acceleration_param\n)\n{\n    const int num_particles = system-&gt;num_particles;\n    const double *x = system-&gt;x;\n    const double *m = system-&gt;m;\n    const double G = system-&gt;G;\n    const double softening_length = acceleration_param-&gt;softening_length;\n\n    /* Empty the input array */\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        a[i * 3 + 0] = 0.0;\n        a[i * 3 + 1] = 0.0;\n        a[i * 3 + 2] = 0.0;\n    }\n\n    /* Find the numbers of massive and massless particles */\n    int massive_objects_count = 0;\n    int massless_objects_count = 0;\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        if (m[i] != 0.0)\n        {\n            massive_objects_count++;\n        }\n        else\n        {\n            massless_objects_count++;\n        }\n    }\n\n    /* Find the indices of massive and massless particles */\n    int *restrict massive_indices = malloc(massive_objects_count * sizeof(int));\n    int *restrict massless_indices = malloc(massless_objects_count * sizeof(int));\n    massive_objects_count = 0;\n    massless_objects_count = 0;\n\n    if (massive_indices == NULL || massless_indices == NULL)\n    {\n        free(massive_indices);\n        free(massless_indices);\n        return WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for massive and massless indices\");\n    }\n\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        if (m[i] != 0.0)\n        {\n            massive_indices[massive_objects_count] = i;\n            massive_objects_count++;\n        }\n        else\n        {\n            massless_indices[massless_objects_count] = i;\n            massless_objects_count++;\n        }\n    }\n\n    /* Pairwise acceleration calculation for massive particles */\n    for (int i = 0; i &lt; massive_objects_count; i++)\n    {\n        const int idx_i = massive_indices[i];\n        const double m_i = m[idx_i];\n        for (int j = i + 1; j &lt; massive_objects_count; j++)\n        {\n            const int idx_j = massive_indices[j];\n            const double m_j = m[idx_j];\n            double temp_vec[3];\n            double R[3];\n\n            // Calculate \\vec{R} and its norm\n            R[0] = x[idx_i * 3 + 0] - x[idx_j * 3 + 0];\n            R[1] = x[idx_i * 3 + 1] - x[idx_j * 3 + 1];\n            R[2] = x[idx_i * 3 + 2] - x[idx_j * 3 + 2];\n            const double R_norm = sqrt(\n                R[0] * R[0] + \n                R[1] * R[1] + \n                R[2] * R[2] +\n                softening_length * softening_length\n            );\n\n            // Calculate the acceleration\n            double temp_value = G / (R_norm * R_norm * R_norm);\n            temp_vec[0] = temp_value * R[0];\n            temp_vec[1] = temp_value * R[1];\n            temp_vec[2] = temp_value * R[2];\n            a[idx_i * 3 + 0] -= temp_vec[0] * m_j;\n            a[idx_i * 3 + 1] -= temp_vec[1] * m_j;\n            a[idx_i * 3 + 2] -= temp_vec[2] * m_j;\n            a[idx_j * 3 + 0] += temp_vec[0] * m_i;\n            a[idx_j * 3 + 1] += temp_vec[1] * m_i;\n            a[idx_j * 3 + 2] += temp_vec[2] * m_i;\n        }\n    }\n\n    /* Acceleration calculation for massless particles due to massive particles */\n    for (int i = 0; i &lt; massive_objects_count; i++)\n    {\n        for (int j = 0; j &lt; massless_objects_count; j++)\n        {\n            int idx_i = massive_indices[i];\n            int idx_j = massless_indices[j];\n            double R[3];\n\n            // Calculate \\vec{R} and its norm\n            R[0] = x[idx_i * 3 + 0] - x[idx_j * 3 + 0];\n            R[1] = x[idx_i * 3 + 1] - x[idx_j * 3 + 1];\n            R[2] = x[idx_i * 3 + 2] - x[idx_j * 3 + 2];\n            double R_norm = sqrt(\n                R[0] * R[0] + \n                R[1] * R[1] + \n                R[2] * R[2] +\n                softening_length * softening_length\n            );\n\n            // Calculate the acceleration\n            double temp_value = G / (R_norm * R_norm * R_norm);\n            a[idx_j * 3 + 0] += temp_value * R[0] * m[i];\n            a[idx_j * 3 + 1] += temp_value * R[1] * m[i];\n            a[idx_j * 3 + 2] += temp_value * R[2] * m[i];\n        }\n    }\n\n    free(massive_indices);\n    free(massless_indices);\n\n    return make_success_error_status();\n}\n\nWIN32DLL_API ErrorStatus benchmark_acceleration(\n    const System *restrict system,\n    const AccelerationParam *acceleration_params,\n    const int num_acceleration_params,\n    const int *restrict num_times_acceleration_param    \n)\n{\n    ErrorStatus error_status;\n\n    double *restrict reference_a = malloc(\n        system-&gt;num_particles * 3 * sizeof(double)\n    );\n    double *restrict a = malloc(\n        system-&gt;num_particles * 3 * sizeof(double)\n    );\n    if (!reference_a || !a)\n    {\n        error_status = WRAP_RAISE_ERROR(\n            GRAV_MEMORY_ERROR,\n            \"Failed to allocate memory for acceleration arrays\"\n        );\n        goto err_malloc;\n    }\n\n    fputs(\"Benchmarking acceleration...\\n\", stdout);\n\n    for (int i = 0; i &lt; num_acceleration_params; i++)\n    {\n        const AccelerationParam *acceleration_param = &amp;(acceleration_params[i]);\n        const int num_times = num_times_acceleration_param[i];\n\n        if (num_times &lt;= 0)\n        {\n            printf(\"Test %d:    Skipped since num_times: %d &lt;= 0\\n\\n\", i, num_times);\n            continue;\n        }\n\n        double *restrict run_time = calloc(num_times, sizeof(double));\n        double mae = 0.0;\n\n        if (!run_time)\n        {\n            free(run_time);\n            error_status = WRAP_RAISE_ERROR(\n                GRAV_MEMORY_ERROR,\n                \"Failed to allocate memory for runtime array\"\n            );\n            goto err_malloc;\n        }\n\n        for (int j = 0; j &lt; num_times; j++)\n        {\n            if (i == 0 &amp;&amp; j == 0)\n            {\n                double start_time = grav_get_current_time();\n                error_status = WRAP_TRACEBACK(acceleration(\n                    reference_a,\n                    system,\n                    acceleration_param\n                ));\n                if (error_status.return_code != GRAV_SUCCESS)\n                {\n                    return error_status;\n                }\n                double end_time = grav_get_current_time();\n                run_time[j] += (end_time - start_time);\n            }\n            else\n            {\n                double start_time = grav_get_current_time();\n                error_status = WRAP_TRACEBACK(acceleration(\n                    a,\n                    system,\n                    acceleration_param\n                ));\n                if (error_status.return_code != GRAV_SUCCESS)\n                {\n                    return error_status;\n                }\n                double end_time = grav_get_current_time();\n                run_time[j] += (end_time - start_time);\n            }\n\n            // Calculate the MAE\n            if (i != 0 &amp;&amp; j == 0)\n            {\n                for (int k = 0; k &lt; system-&gt;num_particles; k++)\n                {\n                    const double diff[3] = {\n                        reference_a[k * 3 + 0] - a[k * 3 + 0],\n                        reference_a[k * 3 + 1] - a[k * 3 + 1],\n                        reference_a[k * 3 + 2] - a[k * 3 + 2]\n                    };\n                    mae += fabs(diff[0]) + fabs(diff[1]) + fabs(diff[2]);\n                }\n                mae /= system-&gt;num_particles;\n            }\n        }\n\n        printf(\"Test %d:\", i);\n        switch(acceleration_param-&gt;method)\n        {\n            case ACCELERATION_METHOD_PAIRWISE:\n                fputs(\"    Method: Pairwise\\n\", stdout);\n                break;\n            case ACCELERATION_METHOD_MASSLESS:\n                fputs(\"    Method: Massless\\n\", stdout);\n                break;\n            case ACCELERATION_METHOD_BARNES_HUT:\n                fputs(\"    Method: Barnes-Hut\\n\", stdout);\n                break;\n            default:\n                error_status = raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n                    GRAV_VALUE_ERROR,\n                    \"Unknown acceleration method. Got: %d\",\n                    acceleration_param-&gt;method\n                );\n                goto err_unknown_acceleration_method;\n        }\n\n        printf(\"    Number of times: %d\\n\", num_times);\n        printf(\"    Avg time: %.3g (+- %.3g) s\\n\", compute_mean(run_time, num_times), compute_std(run_time, num_times, 1) / sqrt(num_times));\n        printf(\"    MAE: %.3g\\n\", mae);\n        printf(\"\\n\");\n\n        free(run_time);\n    }\n\n    free(reference_a);\n    free(a);\n\n    return make_success_error_status();\n\nerr_unknown_acceleration_method:\nerr_malloc:\n    free(reference_a);\n    free(a);\n    return error_status;\n}\n</code></pre> <p>Let's say you have 10 regular particles and 10 massless particles (i.e. particles with mass so small that is negligible). One may compute the acceleration with the brute-force algorithm</p> \\[ \\mathbf{a}_i = \\sum_{j \\neq i} \\frac{G m_j}{r_{ij}^2} \\hat{\\mathbf{r}}_{ij} \\quad \\text{for } i = 1, \\ldots, N \\] <p>But this is \\(\\mathcal{O}(N^2)\\), and we don't actually need to compute the acceleration due to the massless particles. Therefore, a more efficient way is to separate the calculations for massive and massless particles.</p> <p>We first produce two list of indices, one for the massive particles and  one for the massless particles. Then, we compute the acceleration for the massive particles with the brute-force algorithm. For the massless particles, we compute the acceleration of them due to the massive particles only. This gives a time complexity: \\(O(M^2 + MN)\\), where \\(M\\) and \\(N\\) are the number of massive and massless particles respectively.</p>"},{"location":"docs/documentations/output_formats/","title":"Output formats","text":"Source code (Click to expand) <pre><code>/**\n * \\file output.c\n * \\brief Function definitions for simulation output\n * \n * \\author Ching-Yin Ng\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n\n/* HDF5 */\n#ifdef USE_HDF5\n#include &lt;hdf5.h&gt;\n#endif\n\n/* For mkdir */\n#ifndef _WIN32\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#else\n#include &lt;direct.h&gt;\n#include &lt;windows.h&gt;\n#endif\n\n#include \"acceleration.h\"\n#include \"common.h\"\n#include \"error.h\"\n#include \"integrator.h\"\n#include \"output.h\"\n#include \"system.h\"\n\n/**\n * \\brief Output a snapshot of the simulation in CSV format.\n * \n * \\param system Pointer to the gravitational system.\n * \\param integrator_param Pointer to the integrator parameters.\n * \\param acceleration_param Pointer to the acceleration parameters.\n * \\param output_param Pointer to the output parameters.\n * \\param simulation_status Pointer to the simulation status.\n * \\param settings Pointer to the settings.\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus output_snapshot_csv(\n    OutputParam *output_param,\n    const System *system,\n    const IntegratorParam *integrator_param,\n    const AccelerationParam *acceleration_param,\n    const SimulationStatus *simulation_status,\n    const Settings *settings\n);\n\n#ifdef USE_HDF5\n/**\n * \\brief Output a snapshot of the simulation in HDF5 format.\n * \n * \\param system Pointer to the gravitational system.\n * \\param integrator_param Pointer to the integrator parameters.\n * \\param acceleration_param Pointer to the acceleration parameters.\n * \\param output_param Pointer to the output parameters.\n * \\param simulation_status Pointer to the simulation status.\n * \\param settings Pointer to the settings.\n * \n * \\return ErrorStatus\n */\nIN_FILE ErrorStatus output_snapshot_hdf5(\n    OutputParam *output_param,\n    const System *system,\n    const IntegratorParam *integrator_param,\n    const AccelerationParam *acceleration_param,\n    const SimulationStatus *simulation_status,\n    const Settings *settings\n);\n\nIN_FILE ErrorStatus output_snapshot_cosmology_hdf5(\n    OutputParam *output_param,\n    const CosmologicalSystem *system,\n    const SimulationStatus *simulation_status,\n    const Settings *settings\n);\n#endif\n\nOutputParam get_new_output_param(void)\n{\n    OutputParam output_param = {\n        .method = OUTPUT_METHOD_DISABLED,\n        .output_dir = NULL,\n        .output_initial = false,\n        .output_interval = -1.0,\n        .coordinate_output_dtype = OUTPUT_DTYPE_DOUBLE,\n        .velocity_output_dtype = OUTPUT_DTYPE_DOUBLE,\n        .mass_output_dtype = OUTPUT_DTYPE_DOUBLE,\n        .output_count_ = 0\n    };\n    return output_param;\n}\n\nIN_FILE ErrorStatus check_output_method(const int output_method)\n{\n    switch (output_method)\n    {\n        case OUTPUT_METHOD_DISABLED:\n        case OUTPUT_METHOD_CSV:\n            break;\n        case OUTPUT_METHOD_HDF5:\n#ifdef USE_HDF5\n            break;\n#else\n            return WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"HDF5 output method is not available\");\n#endif\n        default:\n        {\n            return raise_error_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                GRAV_VALUE_ERROR,\n                \"Unknown output method. Got: %d\",\n                output_method\n            );\n        }\n    }\n\n    return make_success_error_status();\n}\n\nWIN32DLL_API ErrorStatus finalize_output_param(\n    OutputParam *restrict output_param,\n    const Settings *restrict settings\n)\n{\n    ErrorStatus error_status;\n\n    error_status = WRAP_TRACEBACK(check_output_method(output_param-&gt;method));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n\n    if (output_param-&gt;method == OUTPUT_METHOD_DISABLED)\n    {\n        return make_success_error_status();\n    }\n\n    /* Check storing interval */\n    if (output_param-&gt;output_interval &lt;= 0.0)\n    {\n        return raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n            GRAV_VALUE_ERROR,\n            \"Output interval must be positive. Got: %.17g\",\n            output_param-&gt;output_interval\n        );\n    }\n\n    /* Check directory path */\n    if (!output_param-&gt;output_dir)\n    {\n        // Set to snapshots_YYYYMMDD_HHMMSS if directory path is not set\n        size_t path_str_len = strlen(\"snapshots_YYYYMMDD_HHMMSS/\") + 1;\n        char *output_dir = malloc(path_str_len * sizeof(char));\n        if (!output_dir)\n        {\n            return WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for directory path.\");\n        }\n        const time_t raw_time = time(NULL);\n        struct tm *time_info = localtime(&amp;raw_time);\n        strftime(output_dir, path_str_len, \"snapshots_%Y%m%d_%H%M%S/\", time_info);\n        output_param-&gt;output_dir = output_dir;\n    }\n    else\n    {\n        if (output_param-&gt;output_dir[strlen(output_param-&gt;output_dir) - 1] != '/')\n        {\n            return raise_error_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                GRAV_VALUE_ERROR,\n                \"Directory path for storing snapshots must end with a trailing slash (\\\"/\\\"). Got: \\\"%s\\\".\",\n                output_param-&gt;output_dir\n            );\n        }\n    }\n\n    /* Create directory */\n#ifdef _WIN32\n    if (_mkdir(output_param-&gt;output_dir) == -1)\n    {\n        if (GetFileAttributes(output_param-&gt;output_dir) == INVALID_FILE_ATTRIBUTES)\n        {\n            return raise_error_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                GRAV_OS_ERROR,\n                \"Failed to access path for storing snapshots: \\\"%s\\\".\",\n                output_param-&gt;output_dir\n            );\n        }\n        else if (\n            (GetFileAttributes(output_param-&gt;output_dir) &amp; FILE_ATTRIBUTE_DIRECTORY)\n            &amp;&amp; (settings-&gt;verbose &gt;= GRAV_VERBOSITY_IGNORE_INFO)\n        )\n        {\n            error_status = raise_warning_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                \"Directory for storing snapshots already exists. The files will be overwritten. Directory: \\\"%s\\\".\",\n                output_param-&gt;output_dir\n            );\n            if (error_status.return_code != GRAV_SUCCESS)\n            {\n                return error_status;\n            }\n        }\n    }\n#else\n    struct stat st = {0};\n    if (mkdir(output_param-&gt;output_dir, 0777) == -1)\n    {\n        if(stat(output_param-&gt;output_dir, &amp;st) != 0)\n        {\n            return raise_error_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                GRAV_OS_ERROR,\n                \"Failed to access path for storing snapshots: \\\"%s\\\".\",\n                output_param-&gt;output_dir\n            );\n        }\n\n        else if (\n            (st.st_mode &amp; S_IFDIR)\n            &amp;&amp; (settings-&gt;verbose &gt;= GRAV_VERBOSITY_IGNORE_INFO)\n        )\n        {\n            error_status = raise_warning_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                \"Directory for storing snapshots already exists. The files will be overwritten. Directory: \\\"%s\\\".\",\n                output_param-&gt;output_dir\n            );\n            if (error_status.return_code != GRAV_SUCCESS)\n            {\n                return error_status;\n            }\n        }\n    }\n#endif\n\n    return make_success_error_status();\n}\n\nWIN32DLL_API ErrorStatus output_snapshot(\n    OutputParam *output_param,\n    const System *system,\n    const IntegratorParam *integrator_param,\n    const AccelerationParam *acceleration_param,\n    const SimulationStatus *simulation_status,\n    const Settings *settings\n)\n{\n    ErrorStatus error_status = make_success_error_status();\n\n    switch (output_param-&gt;method)\n    {\n        case OUTPUT_METHOD_DISABLED:\n            break;\n        case OUTPUT_METHOD_CSV:\n            error_status = WRAP_TRACEBACK(output_snapshot_csv(\n                output_param,\n                system,\n                integrator_param,\n                acceleration_param,\n                simulation_status,\n                settings\n            ));\n            break;\n        case OUTPUT_METHOD_HDF5:\n#ifdef USE_HDF5\n            error_status = WRAP_TRACEBACK(output_snapshot_hdf5(\n                output_param,\n                system,\n                integrator_param,\n                acceleration_param,\n                simulation_status,\n                settings\n            ));\n            break;\n#else\n            error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"HDF5 output method is not available\");\n            break;\n#endif\n        default:\n            error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Unknown output method\");\n            break;\n    }\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n\n    (output_param-&gt;output_count_)++;\n\n    return make_success_error_status();\n}\n\nWIN32DLL_API ErrorStatus output_snapshot_cosmology(\n    OutputParam *output_param,\n    const CosmologicalSystem *system,\n    const SimulationStatus *simulation_status,\n    const Settings *settings\n)\n{\n    ErrorStatus error_status = make_success_error_status();\n\n    switch (output_param-&gt;method)\n    {\n        case OUTPUT_METHOD_DISABLED:\n            break;\n        case OUTPUT_METHOD_CSV:\n            error_status = WRAP_RAISE_ERROR(\n                GRAV_VALUE_ERROR,\n                \"CSV output method is not supported for cosmological simulation.\"\n            );\n            break;\n        case OUTPUT_METHOD_HDF5:\n#ifdef USE_HDF5\n            error_status = WRAP_TRACEBACK(output_snapshot_cosmology_hdf5(\n                output_param,\n                system,\n                simulation_status,\n                settings\n            ));\n            break;\n#else\n            (void) system;\n            (void) simulation_status;\n            (void) settings;\n            error_status = WRAP_RAISE_ERROR(\n                GRAV_VALUE_ERROR,\n                \"HDF5 output method is not available. Please recompile with HDF5 support.\"\n            );\n            break;\n#endif\n        default:\n            error_status = raise_error_fmt(\n                __FILE__,\n                __LINE__,\n                __func__,\n                GRAV_VALUE_ERROR,\n                \"Unknown output method. Got: %d\",\n                output_param-&gt;method\n            );\n            break;\n    }\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        return error_status;\n    }\n\n    (output_param-&gt;output_count_)++;\n\n    return make_success_error_status();\n}\n\nIN_FILE ErrorStatus output_snapshot_csv(\n    OutputParam *restrict output_param,\n    const System *restrict system,\n    const IntegratorParam *restrict integrator_param,\n    const AccelerationParam *restrict acceleration_param,\n    const SimulationStatus *restrict simulation_status,\n    const Settings *restrict settings\n)\n{\n    ErrorStatus error_status;\n\n    (void) integrator_param;\n    (void) acceleration_param;\n    (void) settings;\n\n    if (!output_param-&gt;output_dir)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_POINTER_ERROR, \"Output directory path is NULL.\");\n        goto err_output_dir_null;\n    }\n\n    /* Make file path string */\n    const int file_path_length = (\n        strlen(output_param-&gt;output_dir)\n        + snprintf(NULL, 0, \"snapshot_%05d.csv\", output_param-&gt;output_count_)\n        + 1  // Null terminator\n    );\n    char *restrict file_path = malloc(file_path_length * sizeof(char));\n    if (!file_path)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for file path string.\");\n        goto err_file_path_memory_alloc;\n    }\n    int actual_file_path_length = snprintf(file_path, file_path_length, \"%ssnapshot_%05d.csv\", output_param-&gt;output_dir, output_param-&gt;output_count_);\n\n    if (actual_file_path_length &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Failed to get storing file path string\");\n        goto err_write_file_path_string;\n    }\n    else if (actual_file_path_length &gt;= file_path_length)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Storing file path string is truncated.\");\n        goto err_write_file_path_string;\n    }\n\n    /* Open file */\n    FILE *file = fopen(file_path, \"w\");\n    if (!file)\n    {\n        error_status = raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n            GRAV_OS_ERROR,\n            \"Failed to open file for storing snapshots: \\\"%s\\\".\",\n            file_path\n        );\n        goto err_open_file;\n    }\n\n    /* Write metadata */\n    fprintf(file, \"# num_particles: %d\\n\", system-&gt;num_particles);\n    fprintf(file, \"# G: %.17g\\n\", system-&gt;G);\n    fprintf(file, \"# time: %.17g\\n\", simulation_status-&gt;t);\n    fprintf(file, \"# dt: %.17g\\n\", simulation_status-&gt;dt);\n\n    /* Write header */\n    fputs(\"particle_id,m,x,y,z,vx,vy,vz\\n\", file);\n\n    /* Write data */\n    const int num_particles = system-&gt;num_particles;\n    const int *restrict particle_ids = system-&gt;particle_ids;\n    const double *restrict x = system-&gt;x;\n    const double *restrict v = system-&gt;v;\n    const double *restrict m = system-&gt;m;\n\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        // particle_id\n        fprintf(file, \"%d,\", particle_ids[i]);\n\n        // masses\n        if (output_param-&gt;mass_output_dtype == OUTPUT_DTYPE_FLOAT)\n        {\n            fprintf(file, \"%.8g,\", m[i]);\n        }\n        else\n        {\n            fprintf(file, \"%.17g,\", m[i]);\n        }\n\n        // coordinates\n        if (output_param-&gt;coordinate_output_dtype == OUTPUT_DTYPE_FLOAT)\n        {\n            fprintf(file, \"%.8g,\", x[3 * i]);\n            fprintf(file, \"%.8g,\", x[3 * i + 1]);\n            fprintf(file, \"%.8g,\", x[3 * i + 2]);\n        }\n        else\n        {\n            fprintf(file, \"%.17g,\", x[3 * i]);\n            fprintf(file, \"%.17g,\", x[3 * i + 1]);\n            fprintf(file, \"%.17g,\", x[3 * i + 2]);\n        }\n\n        // velocities\n        if (output_param-&gt;velocity_output_dtype == OUTPUT_DTYPE_FLOAT)\n        {\n            fprintf(file, \"%.8g,\", v[3 * i]);\n            fprintf(file, \"%.8g,\", v[3 * i + 1]);\n            fprintf(file, \"%.8g\\n\", v[3 * i + 2]);\n        }\n        else\n        {\n            fprintf(file, \"%.17g,\", v[3 * i]);\n            fprintf(file, \"%.17g,\", v[3 * i + 1]);\n            fprintf(file, \"%.17g\\n\", v[3 * i + 2]);\n        }\n    }\n\n    fflush(file);\n    fclose(file);\n\n    return make_success_error_status();\n\nerr_open_file:\nerr_write_file_path_string:\nerr_file_path_memory_alloc:\n    free(file_path);\nerr_output_dir_null:\n    return error_status;\n}\n\n#ifdef USE_HDF5\nIN_FILE ErrorStatus output_snapshot_hdf5(\n    OutputParam *restrict output_param,\n    const System *restrict system,\n    const IntegratorParam *restrict integrator_param,\n    const AccelerationParam *restrict acceleration_param,\n    const SimulationStatus *restrict simulation_status,\n    const Settings *restrict settings\n)\n{\n    ErrorStatus error_status;\n\n    (void) integrator_param;\n    (void) acceleration_param;\n    (void) settings;\n\n    if (!output_param-&gt;output_dir)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_POINTER_ERROR, \"Output directory path is NULL.\");\n        goto err_output_dir_null;\n    }\n\n    /* Declare variables */\n    const int num_particles = system-&gt;num_particles;\n    const int *restrict particle_ids = system-&gt;particle_ids;\n    const double *restrict x = system-&gt;x;\n    const double *restrict v = system-&gt;v;\n    const double *restrict m = system-&gt;m;\n\n    /* Make file path string */\n    const int file_path_length = (\n        strlen(output_param-&gt;output_dir)\n        + snprintf(NULL, 0, \"snapshot_%05d.hdf5\", output_param-&gt;output_count_)\n        + 1  // Null terminator\n    );\n    char *restrict file_path = malloc(file_path_length * sizeof(char));\n    if (!file_path)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for file path string.\");\n        goto err_file_path_memory_alloc;\n    }\n    int actual_file_path_length = snprintf(file_path, file_path_length, \"%ssnapshot_%05d.hdf5\", output_param-&gt;output_dir, output_param-&gt;output_count_);\n\n    if (actual_file_path_length &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Failed to get storing file path string\");\n        goto err_write_file_path_string;\n    }\n    else if (actual_file_path_length &gt;= file_path_length)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Storing file path string is truncated.\");\n        goto err_write_file_path_string;\n    }\n\n    /* Create HDF5 file */\n    hid_t file = H5Fcreate(file_path, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    if (!file)\n    {\n        error_status = raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n            GRAV_OS_ERROR,\n            \"Failed to create HDF5 file for storing snapshots: \\\"%s\\\".\",\n            file_path\n        );\n        goto err_create_hdf5_file;\n    }\n\n    /* Create group */\n    hid_t header_group = H5Gcreate(file, \"/Header\", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t part_type_0_group = H5Gcreate(file, \"/PartType0\", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    if (header_group == H5I_INVALID_HID || part_type_0_group == H5I_INVALID_HID)\n    {\n        H5Gclose(header_group);\n        H5Gclose(part_type_0_group);\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 groups.\");\n        goto err_create_hdf5_group;\n    }\n\n    /* Create dataspaces */\n    hsize_t dims_1d_1[1] = {1};\n    hsize_t dims_1d_objects_count[1] = {num_particles};\n    hsize_t dims_3d_objects_count[2] = {num_particles, 3};\n    hid_t dataspace_1d_1 = H5Screate_simple(1, dims_1d_1, NULL);\n    hid_t dataspace_1d_objects_count = H5Screate_simple(1, dims_1d_objects_count, NULL);\n    hid_t dataspace_3d_objects_count = H5Screate_simple(2, dims_3d_objects_count, NULL);\n    if (\n        dataspace_1d_1 == H5I_INVALID_HID\n        || dataspace_1d_objects_count == H5I_INVALID_HID\n        || dataspace_3d_objects_count == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 dataspace.\");\n        goto err_create_hdf5_dataspace;\n    }\n\n    /* Create attributes for header */\n    hid_t header_attr_num_files_per_snapshot = H5Acreate(header_group, \"NumFilesPerSnapshot\", H5T_NATIVE_INT, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_num_part_this_file = H5Acreate(header_group, \"NumPart_ThisFile\", H5T_NATIVE_INT, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_num_part_total = H5Acreate(header_group, \"NumPart_Total\", H5T_NATIVE_INT, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_time = H5Acreate(header_group, \"Time\", H5T_NATIVE_DOUBLE, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_dt = H5Acreate(header_group, \"dt\", H5T_NATIVE_DOUBLE, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_G = H5Acreate(header_group, \"G\", H5T_NATIVE_DOUBLE, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    if (\n        header_attr_num_files_per_snapshot == H5I_INVALID_HID\n        || header_attr_num_part_this_file == H5I_INVALID_HID\n        || header_attr_num_part_total == H5I_INVALID_HID\n        || header_attr_time == H5I_INVALID_HID\n        || header_attr_dt == H5I_INVALID_HID\n        || header_attr_G == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 attribute for header.\");\n        goto err_create_hdf5_header_attr;\n    }\n\n    /* Create datasets for PartType0 */\n    hid_t part_type_0_dataset_part_ids = H5Dcreate(part_type_0_group, \"ParticleIDs\", H5T_NATIVE_INT, dataspace_1d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t part_type_0_dataset_masses;\n    hid_t part_type_0_dataset_coordinates;\n    hid_t part_type_0_dataset_velocities;\n\n    if (output_param-&gt;mass_output_dtype == OUTPUT_DTYPE_FLOAT)\n    {\n        part_type_0_dataset_masses = H5Dcreate(part_type_0_group, \"Masses\", H5T_NATIVE_FLOAT, dataspace_1d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n    else\n    {\n        part_type_0_dataset_masses = H5Dcreate(part_type_0_group, \"Masses\", H5T_NATIVE_DOUBLE, dataspace_1d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n\n    if (output_param-&gt;coordinate_output_dtype == OUTPUT_DTYPE_FLOAT)\n    {\n        part_type_0_dataset_coordinates = H5Dcreate(part_type_0_group, \"Coordinates\", H5T_NATIVE_FLOAT, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n    else\n    {\n        part_type_0_dataset_coordinates = H5Dcreate(part_type_0_group, \"Coordinates\", H5T_NATIVE_DOUBLE, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n\n    if (output_param-&gt;velocity_output_dtype == OUTPUT_DTYPE_FLOAT)\n    {\n        part_type_0_dataset_velocities = H5Dcreate(part_type_0_group, \"Velocities\", H5T_NATIVE_FLOAT, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n    else\n    {\n        part_type_0_dataset_velocities = H5Dcreate(part_type_0_group, \"Velocities\", H5T_NATIVE_DOUBLE, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n\n    if (\n        part_type_0_dataset_part_ids == H5I_INVALID_HID\n        || part_type_0_dataset_masses == H5I_INVALID_HID\n        || part_type_0_dataset_coordinates == H5I_INVALID_HID\n        || part_type_0_dataset_velocities == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 datasets.\");\n        goto err_create_hdf5_datasets;\n    }\n\n    /* Write attributes for header */\n    const int num_files_per_snapshot = 1;\n    H5Awrite(header_attr_num_files_per_snapshot, H5T_NATIVE_INT, &amp;num_files_per_snapshot);\n    H5Awrite(header_attr_num_part_this_file, H5T_NATIVE_INT, &amp;num_particles);\n    H5Awrite(header_attr_num_part_total, H5T_NATIVE_INT, &amp;num_particles);\n    H5Awrite(header_attr_time, H5T_NATIVE_DOUBLE, &amp;simulation_status-&gt;t);\n    H5Awrite(header_attr_dt, H5T_NATIVE_DOUBLE, &amp;simulation_status-&gt;dt);\n    H5Awrite(header_attr_G, H5T_NATIVE_DOUBLE, &amp;system-&gt;G);\n\n    /* Write data to HDF5 dataset */\n    H5Dwrite(part_type_0_dataset_part_ids, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, particle_ids);\n    H5Dwrite(part_type_0_dataset_masses, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, m);\n    H5Dwrite(part_type_0_dataset_coordinates, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, x);\n    H5Dwrite(part_type_0_dataset_velocities, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, v);\n\n    /* Close HDF5 objects */\n    H5Dclose(part_type_0_dataset_part_ids);\n    H5Dclose(part_type_0_dataset_masses);\n    H5Dclose(part_type_0_dataset_coordinates);\n    H5Dclose(part_type_0_dataset_velocities);\n\n    H5Aclose(header_attr_num_files_per_snapshot);\n    H5Aclose(header_attr_num_part_this_file);\n    H5Aclose(header_attr_num_part_total);\n    H5Aclose(header_attr_time);\n    H5Aclose(header_attr_dt);\n    H5Aclose(header_attr_G);\n\n    H5Sclose(dataspace_1d_1);\n    H5Sclose(dataspace_1d_objects_count);\n    H5Sclose(dataspace_3d_objects_count);\n\n    H5Gclose(header_group);\n    H5Gclose(part_type_0_group);\n\n    H5Fclose(file);\n\n    return make_success_error_status();\n\n    H5Dclose(part_type_0_dataset_part_ids);\n    H5Dclose(part_type_0_dataset_masses);\n    H5Dclose(part_type_0_dataset_coordinates);\n    H5Dclose(part_type_0_dataset_velocities);\nerr_create_hdf5_datasets:\n    H5Aclose(header_attr_num_files_per_snapshot);\n    H5Aclose(header_attr_num_part_this_file);\n    H5Aclose(header_attr_num_part_total);\n    H5Aclose(header_attr_time);\n    H5Aclose(header_attr_dt);\n    H5Aclose(header_attr_G);\nerr_create_hdf5_header_attr:\n    H5Sclose(dataspace_1d_1);\n    H5Sclose(dataspace_1d_objects_count);\n    H5Sclose(dataspace_3d_objects_count);\nerr_create_hdf5_dataspace:\n    H5Gclose(header_group);\n    H5Gclose(part_type_0_group);\nerr_create_hdf5_group:\n    H5Fclose(file);\nerr_create_hdf5_file:\nerr_write_file_path_string:\nerr_file_path_memory_alloc:\n    free(file_path);\nerr_output_dir_null:\n    return error_status;\n}\n\nIN_FILE ErrorStatus output_snapshot_cosmology_hdf5(\n    OutputParam *restrict output_param,\n    const CosmologicalSystem *restrict system,\n    const SimulationStatus *restrict simulation_status,\n    const Settings *restrict settings\n)\n{\n    ErrorStatus error_status;\n\n    (void) settings;\n\n    if (!output_param-&gt;output_dir)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_POINTER_ERROR, \"Output directory path is NULL.\");\n        goto err_output_dir_null;\n    }\n\n    /* Declare variables */\n    const int num_particles = system-&gt;num_particles;\n    const int *restrict particle_ids = system-&gt;particle_ids;\n    const double *restrict x = system-&gt;x;\n    const double *restrict v = system-&gt;v;\n    const double *restrict m = system-&gt;m;\n\n    /* Make file path string */\n    const int file_path_length = (\n        strlen(output_param-&gt;output_dir)\n        + snprintf(NULL, 0, \"snapshot_%05d.hdf5\", output_param-&gt;output_count_)\n        + 1  // Null terminator\n    );\n    char *restrict file_path = malloc(file_path_length * sizeof(char));\n    if (!file_path)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for file path string.\");\n        goto err_file_path_memory_alloc;\n    }\n    int actual_file_path_length = snprintf(file_path, file_path_length, \"%ssnapshot_%05d.hdf5\", output_param-&gt;output_dir, output_param-&gt;output_count_);\n\n    if (actual_file_path_length &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Failed to get storing file path string\");\n        goto err_write_file_path_string;\n    }\n    else if (actual_file_path_length &gt;= file_path_length)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_VALUE_ERROR, \"Storing file path string is truncated.\");\n        goto err_write_file_path_string;\n    }\n\n    /* Create HDF5 file */\n    hid_t file = H5Fcreate(file_path, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);\n    if (!file)\n    {\n        error_status = raise_error_fmt(\n            __FILE__,\n            __LINE__,\n            __func__,\n            GRAV_OS_ERROR,\n            \"Failed to create HDF5 snapshot file: \\\"%s\\\".\",\n            file_path\n        );\n        goto err_create_hdf5_file;\n    }\n\n    /* Create group */\n    hid_t header_group = H5Gcreate(file, \"/Header\", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t part_type_0_group = H5Gcreate(file, \"/PartType0\", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t units_group = H5Gcreate(file, \"/Units\", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    if (header_group == H5I_INVALID_HID || part_type_0_group == H5I_INVALID_HID || units_group == H5I_INVALID_HID)\n    {\n        H5Gclose(header_group);\n        H5Gclose(part_type_0_group);\n        H5Gclose(units_group);\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 groups.\");\n        goto err_create_hdf5_group;\n    }\n\n    /* Create dataspaces */\n    hsize_t dims_1d_1[1] = {1};\n    hsize_t dims_1d_objects_count[1] = {num_particles};\n    hsize_t dims_3d_objects_count[2] = {num_particles, 3};\n    hid_t dataspace_scaler = H5Screate(H5S_SCALAR);\n    hid_t dataspace_1d_1 = H5Screate_simple(1, dims_1d_1, NULL);\n    hid_t dataspace_1d_objects_count = H5Screate_simple(1, dims_1d_objects_count, NULL);\n    hid_t dataspace_3d_objects_count = H5Screate_simple(2, dims_3d_objects_count, NULL);\n    if (\n        dataspace_scaler == H5I_INVALID_HID\n        || dataspace_1d_1 == H5I_INVALID_HID\n        || dataspace_1d_objects_count == H5I_INVALID_HID\n        || dataspace_3d_objects_count == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 dataspace.\");\n        goto err_create_hdf5_dataspace;\n    }\n\n    /* Create attributes for header */\n    hid_t header_attr_num_files_per_snapshot = H5Acreate(header_group, \"NumFilesPerSnapshot\", H5T_NATIVE_INT, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_num_part_this_file = H5Acreate(header_group, \"NumPart_ThisFile\", H5T_NATIVE_INT, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_num_part_total = H5Acreate(header_group, \"NumPart_Total\", H5T_NATIVE_INT, dataspace_1d_1, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_time = H5Acreate(header_group, \"Time\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_redshift = H5Acreate(header_group, \"Redshift\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_omega_m = H5Acreate(header_group, \"Omega0\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t header_attr_omega_lambda = H5Acreate(header_group, \"OmegaLambda\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    if (\n        header_attr_num_files_per_snapshot == H5I_INVALID_HID\n        || header_attr_num_part_this_file == H5I_INVALID_HID\n        || header_attr_num_part_total == H5I_INVALID_HID\n        || header_attr_time == H5I_INVALID_HID\n        || header_attr_redshift == H5I_INVALID_HID\n        || header_attr_omega_m == H5I_INVALID_HID\n        || header_attr_omega_lambda == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 attribute for header.\");\n        goto err_create_hdf5_header_attr;\n    }\n\n    /* Create datasets for PartType0 */\n    hid_t part_type_0_dataset_part_ids = H5Dcreate(part_type_0_group, \"ParticleIDs\", H5T_NATIVE_INT, dataspace_1d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t part_type_0_dataset_masses;\n    hid_t part_type_0_dataset_coordinates;\n    hid_t part_type_0_dataset_velocities;\n\n    if (output_param-&gt;mass_output_dtype == OUTPUT_DTYPE_FLOAT)\n    {\n        part_type_0_dataset_masses = H5Dcreate(part_type_0_group, \"Masses\", H5T_NATIVE_FLOAT, dataspace_1d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n    else\n    {\n        part_type_0_dataset_masses = H5Dcreate(part_type_0_group, \"Masses\", H5T_NATIVE_DOUBLE, dataspace_1d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n\n    if (output_param-&gt;coordinate_output_dtype == OUTPUT_DTYPE_FLOAT)\n    {\n        part_type_0_dataset_coordinates = H5Dcreate(part_type_0_group, \"Coordinates\", H5T_NATIVE_FLOAT, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n    else\n    {\n        part_type_0_dataset_coordinates = H5Dcreate(part_type_0_group, \"Coordinates\", H5T_NATIVE_DOUBLE, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n\n    if (output_param-&gt;velocity_output_dtype == OUTPUT_DTYPE_FLOAT)\n    {\n        part_type_0_dataset_velocities = H5Dcreate(part_type_0_group, \"Velocities\", H5T_NATIVE_FLOAT, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n    else\n    {\n        part_type_0_dataset_velocities = H5Dcreate(part_type_0_group, \"Velocities\", H5T_NATIVE_DOUBLE, dataspace_3d_objects_count, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);\n    }\n\n    if (\n        part_type_0_dataset_part_ids == H5I_INVALID_HID\n        || part_type_0_dataset_masses == H5I_INVALID_HID\n        || part_type_0_dataset_coordinates == H5I_INVALID_HID\n        || part_type_0_dataset_velocities == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 datasets.\");\n        goto err_create_hdf5_datasets;\n    }\n\n    /* Create attributes for units */\n    hid_t units_attr_current_unit = H5Acreate(units_group, \"Unit current in cgs (U_I)\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t units_attr_length_unit = H5Acreate(units_group, \"Unit length in cgs (U_L)\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t units_attr_mass_unit = H5Acreate(units_group, \"Unit mass in cgs (U_M)\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t units_attr_time_unit = H5Acreate(units_group, \"Unit time in cgs (U_t)\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    hid_t units_attr_temperature_unit = H5Acreate(units_group, \"Unit temperature in cgs (U_T)\", H5T_NATIVE_DOUBLE, dataspace_scaler, H5P_DEFAULT, H5P_DEFAULT);\n    if (\n        units_attr_current_unit == H5I_INVALID_HID\n        || units_attr_length_unit == H5I_INVALID_HID\n        || units_attr_mass_unit == H5I_INVALID_HID\n        || units_attr_time_unit == H5I_INVALID_HID\n        || units_attr_temperature_unit == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to create HDF5 attribute for units.\");\n        goto err_create_hdf5_units_attr;\n    }\n\n    /* Write attributes for header */\n    const int num_files_per_snapshot = 1;\n    H5Awrite(header_attr_num_files_per_snapshot, H5T_NATIVE_INT, &amp;num_files_per_snapshot);\n    H5Awrite(header_attr_num_part_this_file, H5T_NATIVE_INT, &amp;num_particles);\n    H5Awrite(header_attr_num_part_total, H5T_NATIVE_INT, &amp;num_particles);\n    H5Awrite(header_attr_time, H5T_NATIVE_DOUBLE, &amp;(simulation_status-&gt;t));\n    const double z = 1.0 / system-&gt;scale_factor - 1.0;\n    H5Awrite(header_attr_redshift, H5T_NATIVE_DOUBLE, &amp;z);\n    H5Awrite(header_attr_omega_m, H5T_NATIVE_DOUBLE, &amp;(system-&gt;omega_m));\n    H5Awrite(header_attr_omega_lambda, H5T_NATIVE_DOUBLE, &amp;(system-&gt;omega_lambda));\n\n    /* Write data to HDF5 dataset */\n    H5Dwrite(part_type_0_dataset_part_ids, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, particle_ids);\n    H5Dwrite(part_type_0_dataset_masses, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, m);\n    H5Dwrite(part_type_0_dataset_coordinates, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, x);\n    H5Dwrite(part_type_0_dataset_velocities, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, v);\n\n    /* Write attributes for units */\n    double unit_current = 1.0;\n    double unit_temperature = 1.0;\n    H5Awrite(units_attr_current_unit, H5T_NATIVE_DOUBLE, &amp;unit_current);\n    H5Awrite(units_attr_length_unit, H5T_NATIVE_DOUBLE, &amp;(system-&gt;unit_length));\n    H5Awrite(units_attr_mass_unit, H5T_NATIVE_DOUBLE, &amp;(system-&gt;unit_mass));\n    H5Awrite(units_attr_time_unit, H5T_NATIVE_DOUBLE, &amp;(system-&gt;unit_time));\n    H5Awrite(units_attr_temperature_unit, H5T_NATIVE_DOUBLE, &amp;unit_temperature);\n\n    /* Close HDF5 objects */\n    H5Dclose(part_type_0_dataset_part_ids);\n    H5Dclose(part_type_0_dataset_masses);\n    H5Dclose(part_type_0_dataset_coordinates);\n    H5Dclose(part_type_0_dataset_velocities);\n\n    H5Aclose(units_attr_current_unit);\n    H5Aclose(units_attr_length_unit);\n    H5Aclose(units_attr_mass_unit);\n    H5Aclose(units_attr_time_unit);\n    H5Aclose(units_attr_temperature_unit);\n\n    H5Aclose(header_attr_num_files_per_snapshot);\n    H5Aclose(header_attr_num_part_this_file);\n    H5Aclose(header_attr_num_part_total);\n    H5Aclose(header_attr_time);\n    H5Aclose(header_attr_redshift);\n    H5Aclose(header_attr_omega_m);\n    H5Aclose(header_attr_omega_lambda);\n\n    H5Sclose(dataspace_scaler);\n    H5Sclose(dataspace_1d_1);\n    H5Sclose(dataspace_1d_objects_count);\n    H5Sclose(dataspace_3d_objects_count);\n\n    H5Gclose(header_group);\n    H5Gclose(part_type_0_group);\n    H5Gclose(units_group);\n\n    H5Fclose(file);\n\n    return make_success_error_status();\n\n    H5Aclose(units_attr_current_unit);\n    H5Aclose(units_attr_length_unit);\n    H5Aclose(units_attr_mass_unit);\n    H5Aclose(units_attr_time_unit);\n    H5Aclose(units_attr_temperature_unit);\nerr_create_hdf5_units_attr:\n    H5Dclose(part_type_0_dataset_part_ids);\n    H5Dclose(part_type_0_dataset_masses);\n    H5Dclose(part_type_0_dataset_coordinates);\n    H5Dclose(part_type_0_dataset_velocities);\nerr_create_hdf5_datasets:\n    H5Aclose(header_attr_num_files_per_snapshot);\n    H5Aclose(header_attr_num_part_this_file);\n    H5Aclose(header_attr_num_part_total);\n    H5Aclose(header_attr_time);\n    H5Aclose(header_attr_redshift);\n    H5Aclose(header_attr_omega_m);\n    H5Aclose(header_attr_omega_lambda);\nerr_create_hdf5_header_attr:\n    H5Sclose(dataspace_1d_1);\n    H5Sclose(dataspace_1d_objects_count);\n    H5Sclose(dataspace_3d_objects_count);\nerr_create_hdf5_dataspace:\n    H5Gclose(header_group);\n    H5Gclose(part_type_0_group);\n    H5Gclose(units_group);\nerr_create_hdf5_group:\n    H5Fclose(file);\nerr_create_hdf5_file:\nerr_write_file_path_string:\nerr_file_path_memory_alloc:\n    free(file_path);\nerr_output_dir_null:\n    return error_status;\n}\n#endif\n</code></pre> <p>In our project, we support two output formats: CSV and HDF5.</p>"},{"location":"docs/documentations/output_formats/#regular-simulations","title":"Regular simulations","text":""},{"location":"docs/documentations/output_formats/#csv-format","title":"CSV Format","text":"<p>For the CSV format, we output snapshots with file names in the format of <code>snapshot_%05d.csv</code>. The file begins with metadata. For example:</p> <pre><code># num_particles: 3\n# G: 0.00029591220828411951\n# time: 0\n# dt: 0\n</code></pre> <p>Then, the data simply follows the header:</p> <pre><code>particle_id,m,x,y,z,vx,vy,vz\n</code></pre>"},{"location":"docs/documentations/output_formats/#hdf5-format","title":"HDF5 Format","text":"<p>For the HDF5 format, we output snapshots with file names in the format of <code>snapshot_%05d.hdf5</code>. It has two groups: <code>Header</code> and <code>PartType0</code>. Below is a tree structure of the HDF5 file:</p> <pre><code>snapshot_%05d.hdf5\n\u251c\u2500\u2500 Header\n\u2502   \u251c\u2500\u2500 Attribute: NumFilesPerSnapshot\n\u2502   \u251c\u2500\u2500 Attribute: NumPart_ThisFile\n\u2502   \u251c\u2500\u2500 Attribute: NumPart_Total\n\u2502   \u251c\u2500\u2500 Attribute: Time\n\u2502   \u251c\u2500\u2500 Attribute: G\n\u2502   \u2514\u2500\u2500 Attribute: dt\n\u2514\u2500\u2500 PartType0\n    \u251c\u2500\u2500 Dataset: ParticleIDs\n    \u251c\u2500\u2500 Dataset: Masses\n    \u251c\u2500\u2500 Dataset: Coordinates\n    \u2514\u2500\u2500 Dataset: Velocities\n</code></pre>"},{"location":"docs/documentations/output_formats/#cosmology-simulations","title":"Cosmology simulations","text":"<p>In cosmology simulations, we only support the HDF5 format.</p>"},{"location":"docs/documentations/output_formats/#hdf5-format_1","title":"HDF5 Format","text":"<p>For the HDF5 format, we output snapshots with file names in the format of <code>snapshot_%05d.hdf5</code>. It has three groups: <code>Header</code>, <code>PartType0</code> and <code>Units</code>. Below is a tree structure of the HDF5 file:</p> <pre><code>snapshot_%05d.hdf5\n\u251c\u2500\u2500 Header\n\u2502   \u251c\u2500\u2500 Attribute: NumFilesPerSnapshot\n\u2502   \u251c\u2500\u2500 Attribute: NumPart_ThisFile\n\u2502   \u251c\u2500\u2500 Attribute: NumPart_Total\n\u2502   \u251c\u2500\u2500 Attribute: Time\n\u2502   \u251c\u2500\u2500 Attribute: Redshift\n\u2502   \u251c\u2500\u2500 Attribute: Omega0\n\u2502   \u2514\u2500\u2500 Attribute: OmegaLambda\n\u251c\u2500\u2500 PartType0\n\u2502   \u251c\u2500\u2500 Dataset: ParticleIDs\n\u2502   \u251c\u2500\u2500 Dataset: Masses\n\u2502   \u251c\u2500\u2500 Dataset: Coordinates\n\u2502   \u2514\u2500\u2500 Dataset: Velocities\n\u2514\u2500\u2500 Units\n    \u251c\u2500\u2500 Attribute: Unit current in cgs (U_I)\n    \u251c\u2500\u2500 Attribute: Unit length in cgs (U_L)\n    \u251c\u2500\u2500 Attribute: Unit mass in cgs (U_M)\n    \u251c\u2500\u2500 Attribute: Unit time in cgs (U_t)\n    \u2514\u2500\u2500 Attribute: Unit temperature in cgs (U_T)\n</code></pre>"},{"location":"docs/documentations/particle_mesh/","title":"Particle-Mesh algorithm","text":"Source code (Click to expand) <pre><code>#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fftw3.h&gt;\n\n#ifdef USE_OPENMP\n#include &lt;omp.h&gt;\n#endif\n\n#include \"acceleration.h\"\n#include \"error.h\"\n#include \"system.h\"\n#include \"math_functions.h\"\n\nIN_FILE void cloud_in_cell(\n    double *restrict delta,\n    const double *restrict x,\n    const double *restrict m,\n    const int num_particles,\n    const int pm_grid_size,\n    const double *restrict box_center,\n    const double box_length\n)\n{\n    const int grid_size_2 = pm_grid_size * pm_grid_size;\n    const int grid_size_3 = pm_grid_size * pm_grid_size * pm_grid_size; \n\n    /* Clear the grid */\n    for (int i = 0; i &lt; grid_size_3; i++)\n    {\n        delta[i] = 0.0;\n    }\n\n    const double box_width = box_length / 2.0;\n    const double cell_length = box_length / pm_grid_size;\n    const double inv_cell_length = 1.0 / cell_length;\n\n#ifdef USE_OPENMP\n    #pragma omp parallel for\n#endif\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        const double x_normalized = (x[i * 3 + 0] - box_center[0] + box_width) * inv_cell_length;\n        const double y_normalized = (x[i * 3 + 1] - box_center[1] + box_width) * inv_cell_length;\n        const double z_normalized = (x[i * 3 + 2] - box_center[2] + box_width) * inv_cell_length;\n\n        const int n_x = (int) x_normalized;\n        const int n_y = (int) y_normalized;\n        const int n_z = (int) z_normalized;\n\n        const double weight_x = x_normalized - n_x;\n        const double weight_y = y_normalized - n_y;\n        const double weight_z = z_normalized - n_z;\n\n        const double weight_x_m = 1.0 - weight_x;\n        const double weight_y_m = 1.0 - weight_y;\n        const double weight_z_m = 1.0 - weight_z;\n\n        delta[\n            (n_x       % pm_grid_size) * grid_size_2 +\n            (n_y       % pm_grid_size) * pm_grid_size +\n            (n_z       % pm_grid_size)\n        ] += m[i] * weight_x_m * weight_y_m * weight_z_m;\n        delta[\n            ((n_x + 1) % pm_grid_size) * grid_size_2 +\n            (n_y       % pm_grid_size) * pm_grid_size +\n            (n_z       % pm_grid_size)\n        ] += m[i] * weight_x * weight_y_m * weight_z_m;\n        delta[\n            (n_x       % pm_grid_size) * grid_size_2 +\n            ((n_y + 1) % pm_grid_size) * pm_grid_size +\n            (n_z       % pm_grid_size)\n        ] += m[i] * weight_x_m * weight_y * weight_z_m;\n        delta[\n            (n_x       % pm_grid_size) * grid_size_2 +\n            (n_y       % pm_grid_size) * pm_grid_size +\n            ((n_z + 1) % pm_grid_size)\n        ] += m[i] * weight_x_m * weight_y_m * weight_z;\n        delta[\n            ((n_x + 1) % pm_grid_size) * grid_size_2 +\n            ((n_y + 1) % pm_grid_size) * pm_grid_size +\n            (n_z       % pm_grid_size)\n        ] += m[i] * weight_x * weight_y * weight_z_m;\n        delta[\n            ((n_x + 1) % pm_grid_size) * grid_size_2 +\n            (n_y       % pm_grid_size) * pm_grid_size +\n            ((n_z + 1) % pm_grid_size)\n        ] += m[i] * weight_x * weight_y_m * weight_z;\n        delta[\n            (n_x       % pm_grid_size) * grid_size_2 +\n            ((n_y + 1) % pm_grid_size) * pm_grid_size +\n            ((n_z + 1) % pm_grid_size)\n        ] += m[i] * weight_x_m * weight_y * weight_z;\n        delta[\n            ((n_x + 1) % pm_grid_size) * grid_size_2 +\n            ((n_y + 1) % pm_grid_size) * pm_grid_size +\n            ((n_z + 1) % pm_grid_size)\n        ] += m[i] * weight_x * weight_y * weight_z;\n    }\n\n    const double cell_volume = cell_length * cell_length * cell_length;\n    for (int i = 0; i &lt; grid_size_3; i++)\n    {\n        delta[i] /= cell_volume;\n    }\n}\n\nIN_FILE void get_cloud_in_cell_acceleration(\n    double *restrict a,\n    const double *restrict x,\n    const double *restrict acc_grid,\n    const int num_particles,\n    const int pm_grid_size,\n    const double *restrict box_center,\n    const double box_length\n)\n{\n    const double box_width = box_length / 2.0;\n    const double cell_length = box_length / pm_grid_size;\n    const double inv_cell_length = 1.0 / cell_length;\n    const int grid_size_2 = pm_grid_size * pm_grid_size;\n\n#ifdef USE_OPENMP\n    #pragma omp parallel for\n#endif\n    for (int i = 0; i &lt; num_particles; i++)\n    {\n        const double x_normalized = (x[i * 3 + 0] - box_center[0] + box_width) * inv_cell_length;\n        const double y_normalized = (x[i * 3 + 1] - box_center[1] + box_width) * inv_cell_length;\n        const double z_normalized = (x[i * 3 + 2] - box_center[2] + box_width) * inv_cell_length;\n\n        const int n_x = (int) x_normalized;\n        const int n_y = (int) y_normalized;\n        const int n_z = (int) z_normalized;\n\n        const double weight_x = x_normalized - n_x;\n        const double weight_y = y_normalized - n_y;\n        const double weight_z = z_normalized - n_z;\n\n        const double weight_x_m = 1.0 - weight_x;\n        const double weight_y_m = 1.0 - weight_y;\n        const double weight_z_m = 1.0 - weight_z;\n\n        for (int j = 0; j &lt; 3; j++)\n        {\n            a[i * 3 + j] = (\n                acc_grid[\n                    (\n                        (n_x       % pm_grid_size) * grid_size_2 +\n                        (n_y       % pm_grid_size) * pm_grid_size +\n                        (n_z       % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x_m * weight_y_m * weight_z_m\n                + acc_grid[\n                    (\n                        ((n_x + 1) % pm_grid_size) * grid_size_2 +\n                        (n_y       % pm_grid_size) * pm_grid_size +\n                        (n_z       % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x * weight_y_m * weight_z_m\n                + acc_grid[\n                    (\n                        (n_x       % pm_grid_size) * grid_size_2 +\n                        ((n_y + 1) % pm_grid_size) * pm_grid_size +\n                        (n_z       % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x_m * weight_y * weight_z_m\n                + acc_grid[\n                    (\n                        (n_x       % pm_grid_size) * grid_size_2 +\n                        (n_y       % pm_grid_size) * pm_grid_size +\n                        ((n_z + 1) % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x_m * weight_y_m * weight_z\n                + acc_grid[\n                    (\n                        ((n_x + 1) % pm_grid_size) * grid_size_2 +\n                        ((n_y + 1) % pm_grid_size) * pm_grid_size +\n                        (n_z       % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x * weight_y * weight_z_m\n                + acc_grid[\n                    (\n                        ((n_x + 1) % pm_grid_size) * grid_size_2 +\n                        (n_y       % pm_grid_size) * pm_grid_size +\n                        ((n_z + 1) % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x * weight_y_m * weight_z\n                + acc_grid[\n                    (\n                        (n_x       % pm_grid_size) * grid_size_2 +\n                        ((n_y + 1) % pm_grid_size) * pm_grid_size +\n                        ((n_z + 1) % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x_m * weight_y * weight_z\n                + acc_grid[\n                    (\n                        ((n_x + 1) % pm_grid_size) * grid_size_2 +\n                        ((n_y + 1) % pm_grid_size) * pm_grid_size +\n                        ((n_z + 1) % pm_grid_size)\n                    ) * 3 + j\n                ] * weight_x * weight_y * weight_z\n            );\n        }\n    }\n}\n\nIN_FILE void compute_acceleration_with_gradient(\n    double *restrict acc_grid,\n    const double *restrict phi,\n    const int pm_grid_size,\n    const double box_length\n)\n{\n    const double cell_length = box_length / pm_grid_size;\n    const int grid_size_2 = pm_grid_size * pm_grid_size;\n#ifdef USE_OPENMP\n    #pragma omp parallel for\n#endif\n    for (int i = 0; i &lt; pm_grid_size; i++)\n    {\n        const int i_m_2 = (i - 2 + pm_grid_size) % pm_grid_size;\n        const int i_m = (i - 1 + pm_grid_size) % pm_grid_size;\n        const int i_p = (i + 1) % pm_grid_size;\n        const int i_p_2 = (i + 2) % pm_grid_size;\n        for (int j = 0; j &lt; pm_grid_size; j++)\n        {\n            const int j_m_2 = (j - 2 + pm_grid_size) % pm_grid_size;\n            const int j_m = (j - 1 + pm_grid_size) % pm_grid_size;\n            const int j_p = (j + 1) % pm_grid_size;\n            const int j_p_2 = (j + 2) % pm_grid_size;\n            for (int k = 0; k &lt; pm_grid_size; k++)\n            {\n                const int k_m_2 = (k - 2 + pm_grid_size) % pm_grid_size;\n                const int k_m = (k - 1 + pm_grid_size) % pm_grid_size;\n                const int k_p = (k + 1) % pm_grid_size;\n                const int k_p_2 = (k + 2) % pm_grid_size;\n\n                const int index     = i * grid_size_2 + j * pm_grid_size + k;\n\n                const int index_x_m_2 = i_m_2 * grid_size_2 + j * pm_grid_size + k;\n                const int index_x_m   = i_m * grid_size_2 + j * pm_grid_size + k;\n                const int index_x_p   = i_p * grid_size_2 + j * pm_grid_size + k;\n                const int index_x_p_2 = i_p_2 * grid_size_2 + j * pm_grid_size + k;\n\n                const int index_y_m_2 = i * grid_size_2 + j_m_2 * pm_grid_size + k;\n                const int index_y_m   = i * grid_size_2 + j_m * pm_grid_size + k;\n                const int index_y_p   = i * grid_size_2 + j_p * pm_grid_size + k;\n                const int index_y_p_2 = i * grid_size_2 + j_p_2 * pm_grid_size + k;\n\n                const int index_z_m_2 = i * grid_size_2 + j * pm_grid_size + k_m_2;\n                const int index_z_m   = i * grid_size_2 + j * pm_grid_size + k_m;\n                const int index_z_p   = i * grid_size_2 + j * pm_grid_size + k_p;\n                const int index_z_p_2 = i * grid_size_2 + j * pm_grid_size + k_p_2;\n\n                acc_grid[index * 3 + 0] = (\n                    phi[index_x_m_2] - 8.0 * phi[index_x_m] + 8.0 * phi[index_x_p] - phi[index_x_p_2]\n                ) / (12.0 * cell_length);\n                acc_grid[index * 3 + 1] = (\n                    phi[index_y_m_2] - 8.0 * phi[index_y_m] + 8.0 * phi[index_y_p] - phi[index_y_p_2]\n                ) / (12.0 * cell_length);\n                acc_grid[index * 3 + 2] = (\n                    phi[index_z_m_2] - 8.0 * phi[index_z_m] + 8.0 * phi[index_z_p] - phi[index_z_p_2]\n                ) / (12.0 * cell_length);\n            }\n        }\n    }\n}\n\nWIN32DLL_API ErrorStatus acceleration_PM(\n    double *restrict a,\n    const CosmologicalSystem *restrict system,\n    const double G,\n    const int pm_grid_size\n)\n{\n    ErrorStatus error_status;\n\n    /* Declare variables */\n    const int num_particles = system-&gt;num_particles;\n    const double *restrict x = system-&gt;x;\n    const double *restrict m = system-&gt;m;\n    const double *restrict box_center = system-&gt;box_center;\n    const double box_width = system-&gt;box_width;\n    const double box_length = box_width * 2.0;\n    const double scale_factor = system-&gt;scale_factor;\n\n    const int grid_size_2 = pm_grid_size * pm_grid_size;\n    const int grid_size_3 = pm_grid_size * pm_grid_size * pm_grid_size;\n\n    double *restrict acc_grid = malloc(grid_size_3 * 3 * sizeof(double));\n    double *restrict delta = fftw_malloc(grid_size_3 * sizeof(double));\n    fftw_complex *delta_fourier = fftw_malloc(grid_size_2 * (pm_grid_size / 2 + 1) * sizeof(fftw_complex));\n    double *restrict phi = fftw_malloc(grid_size_3 * sizeof(double));\n    if (!acc_grid || !delta || !delta_fourier || !phi)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to allocate memory for particle mesh acceleration\");\n        goto err_malloc;\n    }\n\n    /* Deposit mass onto the grid */\n    cloud_in_cell(delta, x, m, num_particles, pm_grid_size, box_center, box_length);\n\n    /* Compute the density perturbation in Fourier space */\n    fftw_plan plan_forward = fftw_plan_dft_r2c_3d(pm_grid_size, pm_grid_size, pm_grid_size, delta, delta_fourier, FFTW_ESTIMATE);\n    if (!plan_forward)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to create FFTW plan for forward transform\");\n        goto err_fftw_plan_forward;\n    }\n    fftw_execute(plan_forward);\n\n    const int half_grid_size = pm_grid_size / 2 + 1;\n    const double two_pi_over_box_length_squared = 4.0 * M_PI * M_PI / (box_length * box_length);\n#ifdef USE_OPENMP\n    #pragma omp parallel for\n#endif\n    for (int i = 0; i &lt; pm_grid_size; i++)\n    {\n        const int k_x = (i &lt; half_grid_size) ? i : i - pm_grid_size;\n        for (int j = 0; j &lt; pm_grid_size; j++)\n        {\n            const int k_y = (j &lt; half_grid_size) ? j : j - pm_grid_size;\n            for (int k = 0; k &lt; half_grid_size; k++)\n            {\n                const int k_z = k;\n                const double k_sq = (k_x * k_x + k_y * k_y + k_z * k_z) * two_pi_over_box_length_squared;\n\n                const double kernel = k_sq == 0.0 ? 0.0 : -1.0 / k_sq;\n\n                const int index = i * (pm_grid_size * half_grid_size) + j * half_grid_size + k;\n                delta_fourier[index][0] *= kernel;\n                delta_fourier[index][1] *= kernel;\n            }\n        }\n    }\n\n    /* Compute the potential in real space */\n    fftw_plan plan_backward = fftw_plan_dft_c2r_3d(pm_grid_size, pm_grid_size, pm_grid_size, delta_fourier, phi, FFTW_ESTIMATE);\n    if (!plan_backward)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_MEMORY_ERROR, \"Failed to create FFTW plan for backward transform\");\n        goto err_fftw_plan_backward;\n    }\n    fftw_execute(plan_backward);\n\n    const double factor = 4.0 * M_PI * G / (scale_factor * (double) grid_size_3);\n    for (int i = 0; i &lt; grid_size_3; i++)\n    {\n        phi[i] *= factor;\n    }\n\n    /* Compute the force by taking the gradient of the potential */\n    compute_acceleration_with_gradient(\n        acc_grid,\n        phi, pm_grid_size, box_length\n    );\n\n    /* Add the acceleration to the particles */\n    get_cloud_in_cell_acceleration(\n        a, x, acc_grid,\n        num_particles, pm_grid_size, box_center, box_length\n    );\n\n    /* Free memory */\n    free(acc_grid);\n    fftw_free(delta);\n    fftw_free(delta_fourier);\n    fftw_free(phi);\n    fftw_destroy_plan(plan_forward);\n    fftw_destroy_plan(plan_backward);\n\n    return make_success_error_status();\n\nerr_fftw_plan_backward:\n    fftw_destroy_plan(plan_backward);\nerr_fftw_plan_forward:\n    fftw_destroy_plan(plan_forward);\nerr_malloc:\n    free(acc_grid);\n    fftw_free(delta);\n    fftw_free(delta_fourier);\n    fftw_free(phi);\n\n    return error_status;\n}\n</code></pre> <p>For cosmological simulations, we are usually interested in a large domain with periodic boundary conditions. Interestingly, grid-based algorithm like the Particle Mesh method naturally provides periodic boundary conditions by solving the Poisson's equation in the Fourier Space,</p> \\[\\begin{equation}     \\label{eqn:poisson}     \\nabla^2 \\Phi(x) = 4 \\pi G \\rho(\\textbf{x})     \\implies - \\textbf{k}^2 \\Phi(\\textbf{k}) = 4 \\pi G \\rho(\\textbf{k}). \\end{equation}\\] <p>The overall time complexity is \\(\\mathcal{O}(N + N_{\\textnormal{cell} } \\log N_{\\textnormal{cell} })\\), with \\(\\mathcal{O}(N)\\) for interpolation and \\(\\mathcal{O}(N_{\\textnormal{cell} } \\log N_{\\textnormal{cell} })\\) for FFT. Therefore, this method is very fast. However, it is not accurate for short range force where the length scale is smaller than the grid resolution. Thus, it is not suitable for inhomogeneous distributions with high density regions.</p> <p>In this section, we would focus on the details in implementing the Particle Mesh algorithm. There are three steps in the algorithm: </p> <ol> <li>Estimating the density of the underlying grid,</li> <li>Solving the Poisson's equation in fourier space, and</li> <li>Computing the acceleration by taking a gradient of the potential in real space and interpolating the acceleration to the particle.</li> </ol>"},{"location":"docs/documentations/particle_mesh/#density-estimation","title":"Density estimation","text":"<p>In a sense, N-body simulation is a Monte Carlo technique for large scale simulations. Each particle is a sampling drawn from a distribution at \\(t = 0\\), where all \\(N\\) particles together models the underlying continuous distribution<sup>1</sup>. Therefore, when estimating the density of the underlying grid, we should not think of the particles as a localized point with extreme high density (e.g. an enormous star), but a cloud of mass that is represented as a particle due to limited computational capability.</p> <p>In figure 1, we shows the comparison between the Nearest Grid Point (NGP) scheme versus the Cloud-In-Cell (CIC) scheme. The latter provides a much smoother estimation of density. In 3D, a particle at \\(\\textbf{x}_p = (x_p, y_p, z_p)\\) could contribute density to its parent cell \\(\\textbf{x}_c = (x_c, y_c, z_c)\\) and seven neighboring cells. Define the weightings</p> \\[\\begin{equation}     %\\label{}     \\textbf{d} = \\frac{\\textbf{x}_p - \\textbf{x}_c}{l}, \\quad     \\textbf{t} = 1 - \\textbf{d}, \\end{equation}\\] <p>where \\(l\\) is the cell length. We have the density contribution due to a particle<sup>2</sup></p> \\[\\begin{align}     \\rho_{i, j, k} &amp;= \\rho_p t_x t_y t_z,       &amp;\\rho_{i + 1, j + 1, k} &amp;= \\rho_p d_x d_y t_z, \\\\     \\rho_{i + 1, j, k} &amp;= \\rho_p d_x t_y t_z,   &amp;\\rho_{i + 1, j, k + 1} &amp;= \\rho_p d_x t_y d_z, \\nonumber \\\\     \\rho_{i, j + 1, k} &amp;= \\rho_p t_x d_y t_z,   &amp;\\rho_{i, j + 1, k + 1} &amp;= \\rho_p t_x d_y d_z, \\nonumber \\\\     \\rho_{i, j, k + 1} &amp;= \\rho_p t_x t_y d_z,   &amp;\\rho_{i + 1, j + 1, k + 1} &amp;= \\rho_p d_x d_y d_z, \\nonumber \\end{align}\\] <p>where \\(\\rho_p = m_p / V_{\\textnormal{unit cell}}\\).  </p> Figure 1: Two different schemes in estimating density in a discretized particle mesh."},{"location":"docs/documentations/particle_mesh/#solving-the-poissons-equation","title":"Solving the Poisson's equation","text":"<p>Now, we have a grid with assigned density value on each grid point. To transform it into Fourier Space, we simply do a discrete fourier transform using FFT libraries (e.g. FFTW in C or <code>numpy.fft</code> in Python). Then, we compute the wave numbers by</p> \\[\\begin{equation}     %\\label{}     \\textbf{k} = \\left( \\frac{2 \\pi n_x}{L_x}, \\frac{2 \\pi n_y}{L_y}, \\frac{2 \\pi n_z}{L_z} \\right), \\end{equation}\\] <p>where \\(\\textbf{L} = (L_x, L_y, L_z)\\) is the box length, and \\(\\textbf{n} = (n_x, n_y, n_z) \\in [0, N)\\) is the grid indices (one may need to wrap the indices above \\(\\frac{N}{2}\\) to \\(-\\frac{N}{2}\\) so that  \\((n_x, n_y, n_z) \\in [- \\frac{N}{2}, \\frac{N}{2})\\)). Then, we simply compute \\(\\textbf{k}^2\\) and obtain the potential in Fourier Space</p> \\[\\begin{equation}     %\\label{}     \\Phi(\\textbf{k}) = -\\frac{4 \\pi G}{\\textbf{k}^2} \\rho(\\textbf{k}). \\end{equation}\\]"},{"location":"docs/documentations/particle_mesh/#interpolating-the-acceleration","title":"Interpolating the acceleration","text":"<p>Now, we do an inverse discrete fourier transform to obtain the potential on the grid points. Then, the acceleration can be obtained by computing \\(\\textbf{a} = - \\nabla \\Phi\\) by a central finite difference scheme with fourth order accuracy:</p> \\[\\begin{equation}     %\\label{}     f'(x) \\approx \\frac{1}{l^3} \\left[ \\frac{1}{12} f(x - 2l) - \\frac{2}{3} f(x - l) + \\frac{2}{3} f(x + l) - \\frac{1}{12} f(x + 2l) \\right] + \\mathcal{O}(l^4), \\end{equation}\\] <p>Then, we perform a linear interpolation to obtain the acceleration of the particles. Reusing the notations from the cloud-in-cell scheme, we have</p> \\[\\begin{align}     %\\label{eqn:eqlabel}     \\textbf{a}_p      &amp;= \\textbf{a}_{i, j, k} t_x t_y t_z     + \\textbf{a}_{i + 1, j, k} d_x t_y t_z     + \\textbf{a}_{i, j + 1, k} t_x d_y t_z     + \\textbf{a}_{i, j, k + 1} t_x t_y d_z \\nonumber \\\\     &amp;\\quad\\,+     \\textbf{a}_{i + 1, j + 1, k} d_x d_y t_z     + \\textbf{a}_{i + 1, j, k + 1} d_x t_y d_z     + \\textbf{a}_{i, j + 1, k + 1} t_x d_y d_z     + \\textbf{a}_{i + 1, j + 1, k + 1} d_x d_y d_z.  \\end{align}\\] <ol> <li> <p>W. Dehnen and J. I. Read. N-body simulations of gravitational dynamics. The European Physical Journal Plus, 126(5):55, May 2011. URL: http://link.springer.com/10.1140/epjp/i2011-11055-3 (visited on 2025-03-31), doi:10.1140/epjp/i2011-11055-3.\u00a0\u21a9</p> </li> <li> <p>Andrey Kravtsov. Writing a pm code. \\url https://astro.uchicago.edu/\u00a0andrey/Talks/PM/pm.pdf, March 2002. Accessed: 2025-04-13.\u00a0\u21a9</p> </li> </ol>"},{"location":"docs/documentations/reducing_round_off_error/","title":"Reducing rounding error with compensated summation","text":"<p>A method known as compensated summation<sup>1</sup> is implemented for all integrators in grav_sim except WHFast:</p> <p>When we advance our system by \\(\\Delta t\\), we have </p> <p>\\(x_{n+1} = x_n + \\delta x\\)</p> <p>Since \\(\\delta x\\) is very small compared to \\(x_n\\), many digits of precision will be lost. By compensated summation, we keep track of the losing digits using another variable, which allows us to effectively eliminates round off error with very little cost.</p> <p>The algorithm is as follows:</p> <ol> <li>Calculate \\(\\delta x\\)</li> <li>\\(x_0 \\leftarrow x\\)</li> <li>\\(e \\leftarrow  e + \\delta x\\)</li> <li>\\(x \\leftarrow  x_0 + e\\)</li> <li>\\(e \\leftarrow  e + (x_0 - x)\\)</li> </ol> <p>Example</p> <p>Consider </p> <p>\\(x_n\\)      = 1.3124125125124122</p> <p>\\(\\delta x\\) = 0.000000012412512412512</p> <p>\\(x_{n+1} = x_n + \\delta x\\) = 1.312412524924924612512</p> <p>Let us try to add them together in Python: <pre><code>&gt;&gt;&gt; x = 1.3124125125124122\n&gt;&gt;&gt; dx = 0.000000012412512412512\n&gt;&gt;&gt; x = x + dx\n&gt;&gt;&gt; print(f\"{x:.19f}\")\n1.3124125249249245506\n</code></pre></p> <p>The result is 1.3124125249249245506.</p> <p>Round off error \\(\\approx 6.1912 \\times 10^{-17}\\)</p> <p>Now we try compensated summation: <pre><code>&gt;&gt;&gt; x = 1.3124125125124122\n&gt;&gt;&gt; dx = 0.000000012412512412512\n&gt;&gt;&gt; e = 0.0\n&gt;&gt;&gt; x_0 = x\n&gt;&gt;&gt; e = e + dx\n&gt;&gt;&gt; x = x_0 + e\n&gt;&gt;&gt; e = e + (x_0 - x)\n&gt;&gt;&gt; e\n6.12222940391771e-17\n</code></pre> As we can see, the value of \\(e\\) is very close to the round off error! Therefore, the new variable \\(e\\) effectively keeps track of the lost digits.</p> <ol> <li> <p>(Ernst Hairer), Gerhard Wanner, and Christian Lubich. Geometric Numerical Integration, chapter VIII, pages 272\u2013274. Springer, Berlin, Heidelberg, 2002.\u00a0\u21a9</p> </li> </ol>"},{"location":"docs/documentations/why_c/","title":"Why C?","text":"<p>You may wonder why I chose C instead of Python. There are a few reasons:</p> <ol> <li> <p>Performance</p> <p>This one is obvious. As a low-level language, C is much faster than Python, and performance is essential for large-scale / long time scale simulations. Some may argue that Python could also be fast with the help of Cython or Numba, but it would never be as fast and as simple as just writing in plain C. Besides, it is tempting to write fast but obscure Python code, but readability is a priority for me.</p> <p>At the very beginning, the project is written in Python with NumPy. As I rewrote the code in C, I have achieved a 400x - 1000x speedup. The difference has shrunk to 50x - 100x after  vectorizing the acceleration function to avoid the overhead from Python for loops.</p> </li> <li> <p>Readability</p> <p>C is a small language with a small set of syntax. It doesn't have a lot of fancy features so it is easier to understand and maintain. In addition, everything is done explicitly in C, so there is no room for ambiguity.</p> </li> <li> <p>Strong typing</p> <p>C is a strongly typed language and I found it easier to work with. In Python, I sometimes  still find bugs caused by wrong data types, even though I am already using type hints and mypy.</p> </li> </ol> <p>Nevertheless, Python is still useful in many ways. I would argue that it is better to use Python when performance is not a concern. And it is really easy to plot graphs with Python.</p>"},{"location":"docs/documentations/CAPI/grav_sim/","title":"Grav sim","text":"<p>Coming soon! For now, you may read the examples C scripts to see how to use the C API. It should be similar to the Python API.</p>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/","title":"GravitySimulatorAPI","text":"<p>Gravity simulator API</p> Source code in <code>grav_sim/api.py</code> <pre><code>class GravitySimulatorAPI:\n    \"\"\"Gravity simulator API\"\"\"\n\n    def __init__(self, c_lib_path: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Initialize gravity simulator API\n\n        Parameters\n        ----------\n        c_lib_path : str, optional\n            Path to C library, by default None\n        \"\"\"\n        if c_lib_path is not None:\n            self.c_lib = utils.load_c_lib(Path(c_lib_path))\n        else:\n            self.c_lib = utils.load_c_lib()\n        utils.initialize_c_lib(self.c_lib)\n\n        # System\n        self.BUILT_IN_SYSTEMS = System.BUILT_IN_SYSTEMS\n\n        # Plotting\n        self.SOLAR_SYSTEM_COLORS = plotting.SOLAR_SYSTEM_COLORS\n        self.plot_quantity_against_time = plotting.plot_quantity_against_time\n        self.plot_2d_trajectory = plotting.plot_2d_trajectory\n        self.plot_3d_trajectory = plotting.plot_3d_trajectory\n\n        # Simulator\n        self.simulator = Simulator(c_lib=self.c_lib)\n        self.DAYS_PER_YEAR = self.simulator.DAYS_PER_YEAR\n        self.launch_simulation = self.simulator.launch_simulation\n        self.launch_cosmological_simulation = (\n            self.simulator.launch_cosmological_simulation\n        )\n\n        # Parameters\n        self.AVAILABLE_ACCELERATION_METHODS = (\n            parameters.AccelerationParam.AVAILABLE_ACCELERATION_METHODS\n        )\n        self.AVAILABLE_INTEGRATORS = parameters.IntegratorParam.AVAILABLE_INTEGRATORS\n        self.FIXED_STEP_SIZE_INTEGRATORS = (\n            parameters.IntegratorParam.FIXED_STEP_SIZE_INTEGRATORS\n        )\n        self.ADAPTIVE_STEP_SIZE_INTEGRATORS = (\n            parameters.IntegratorParam.ADAPTIVE_STEP_SIZE_INTEGRATORS\n        )\n        self.AVAILABLE_OUTPUT_METHODS = parameters.OutputParam.AVAILABLE_OUTPUT_METHODS\n        self.AVAILABLE_OUTPUT_DTYPE = parameters.OutputParam.AVAILABLE_OUTPUT_DTYPE\n\n    def get_new_system(self) -&gt; System:\n        \"\"\"Create a gravitational system\n\n        Returns\n        -------\n        System object\n        \"\"\"\n        return System(c_lib=self.c_lib)\n\n    def get_new_cosmological_system(self) -&gt; CosmologicalSystem:\n        \"\"\"Create a cosmological system\n\n        Returns\n        -------\n        CosmologicalSystem object\n        \"\"\"\n        return CosmologicalSystem(c_lib=self.c_lib)\n\n    def load_system(\n        self,\n        file_path: str | Path,\n    ) -&gt; System:\n        \"\"\"Load system from a CSV file\n\n        Parameters\n        ----------\n        file_path : str\n            File path to load the system from\n        \"\"\"\n        return System.load_system(self.c_lib, file_path)\n\n    def get_built_in_system(self, system_name: str) -&gt; System:\n        \"\"\"Get a built-in gravitational system\n\n        Parameters\n        ----------\n        system_name : str\n            Name of the built-in system to be loaded.\n        \"\"\"\n        return System.get_built_in_system(self.c_lib, system_name)\n\n    @staticmethod\n    def get_new_parameters() -&gt; Tuple[\n        parameters.AccelerationParam,\n        parameters.IntegratorParam,\n        parameters.OutputParam,\n        parameters.Settings,\n    ]:\n        \"\"\"Create new simulation parameters\n\n        Returns\n        -------\n        Tuple of acceleration, integrator, output, and settings parameters\n        \"\"\"\n        acceleration_param = parameters.AccelerationParam()\n        integrator_param = parameters.IntegratorParam()\n        output_param = parameters.OutputParam()\n        settings = parameters.Settings()\n\n        return acceleration_param, integrator_param, output_param, settings\n\n    def days_to_years(self, days: float | np.ndarray) -&gt; float | np.ndarray:\n        return days / self.simulator.DAYS_PER_YEAR\n\n    def years_to_days(self, years: float | np.ndarray) -&gt; float | np.ndarray:\n        return years * self.simulator.DAYS_PER_YEAR\n\n    @staticmethod\n    def read_csv_data(\n        output_dir: str | Path,\n    ) -&gt; Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Read CSV snapshots from the output directory,\n        assuming number of particles and particle_ids\n        stays the same\n\n        Parameters\n        ----------\n        output_dir : str | Path\n            Output directory path\n\n        Returns\n        -------\n        G : float\n            Gravitational constant\n        time : np.ndarray\n            Simulation time of each snapshot\n        dt : np.ndarray\n            Time step of each snapshot\n        particle_ids : np.ndarray\n            1D array of Particle IDs\n        sol_state : np.ndarray\n            3D array of solution state for each snapshot, with shape\n            (num_snapshots, num_particles, 7) being\n            [m, x, y, z, vx, vy, vz]\n        \"\"\"\n        output_dir = Path(output_dir)\n        if not output_dir.is_dir():\n            raise FileNotFoundError(f\"Output directory not found: {output_dir}\")\n\n        snapshot_files = sorted(output_dir.glob(\"snapshot_*.csv\"))\n        if len(snapshot_files) == 0:\n            raise FileNotFoundError(f\"No snapshot files found in: {output_dir}\")\n\n        G = -1.0\n        time = np.zeros(len(snapshot_files), dtype=np.float64)\n        dt = np.zeros(len(snapshot_files), dtype=np.float64)\n\n        for i, snapshot_file in enumerate(snapshot_files):\n            # Read the metadata\n            with open(snapshot_file, \"r\") as file:\n                read_metadata_num_particles = False\n                read_metadata_G = False\n                read_metadata_time = False\n                read_metadata_dt = False\n                for line in file:\n                    line = line.strip()\n\n                    if line.startswith(\"#\"):\n                        if line.startswith(\"# num_particles\"):\n                            if i == 0:\n                                num_particles = int(line.split(\":\")[1].strip())\n                            elif num_particles != int(line.split(\":\")[1].strip()):\n                                raise ValueError(\n                                    f\"Number of particles changed from {num_particles} to {int(line.split(':')[1].strip())}\"\n                                )\n                            read_metadata_num_particles = True\n                        elif line.startswith(\"# G\"):\n                            G = float(line.split(\":\")[1].strip())\n                            read_metadata_G = True\n                        elif line.startswith(\"# time\"):\n                            time[i] = float(line.split(\":\")[1].strip())\n                            read_metadata_time = True\n                        elif line.startswith(\"# dt\"):\n                            dt[i] = float(line.split(\":\")[1].strip())\n                            read_metadata_dt = True\n\n                    if (\n                        read_metadata_num_particles\n                        and read_metadata_G\n                        and read_metadata_time\n                        and read_metadata_dt\n                    ):\n                        break\n\n        # Read the data\n        particle_ids = np.zeros(num_particles, dtype=np.int32)\n        sol_state = np.zeros((len(snapshot_files), num_particles, 7), dtype=np.float64)\n        for i, snapshot_file in enumerate(snapshot_files):\n            data = np.genfromtxt(snapshot_file, delimiter=\",\", skip_header=5)\n            if i == 0:\n                particle_ids = data[:, 0].astype(np.int32)\n                particle_ids = np.sort(particle_ids)\n                _, num_duplicates = np.unique(particle_ids, return_counts=True)\n                if np.any(num_duplicates &gt; 1):\n                    raise ValueError(\n                        f\"Particle IDs are not unique. Particle IDs: {particle_ids}\"\n                    )\n\n            snapshot_particle_ids = data[:, 0].astype(np.int32)\n\n            # Sort the data by particle IDs\n            sorted_indices = np.argsort(snapshot_particle_ids)\n            data = data[sorted_indices]\n\n            # Check if the particle IDs match\n            if not np.array_equal(particle_ids, snapshot_particle_ids):\n                raise ValueError(\n                    f\"Particle IDs do not match in snapshot {i + 1}: {snapshot_file}\"\n                )\n\n            # Store the data\n            sol_state[i, :, :] = data[:, 1:]\n\n        return G, time, dt, particle_ids, sol_state\n\n    @staticmethod\n    def read_hdf5_data(\n        output_dir: str | Path,\n    ) -&gt; Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Read HDF5 snapshots from the output directory,\n        assuming number of particles and particle_ids\n        stays the same\n\n        Parameters\n        ----------\n        output_dir : str | Path\n            Output directory path\n\n        Returns\n        -------\n        G : float\n            Gravitational constant\n        time : np.ndarray\n            Simulation time of each snapshot\n        dt : np.ndarray\n            Time step of each snapshot\n        particle_ids : np.ndarray\n            1D array of Particle IDs\n        sol_state : np.ndarray\n            3D array of solution state for each snapshot, with shape\n            (num_snapshots, num_particles, 7) being\n            [m, x, y, z, vx, vy, vz]\n        \"\"\"\n        output_dir = Path(output_dir)\n        if not output_dir.is_dir():\n            raise FileNotFoundError(f\"Output directory not found: {output_dir}\")\n\n        snapshot_files = sorted(output_dir.glob(\"snapshot_*.hdf5\"))\n        if len(snapshot_files) == 0:\n            raise FileNotFoundError(f\"No snapshot files found in: {output_dir}\")\n\n        G = -1.0\n        time = np.zeros(len(snapshot_files), dtype=np.float64)\n        dt = np.zeros(len(snapshot_files), dtype=np.float64)\n\n        for i, snapshot_file in enumerate(snapshot_files):\n            # Read the metadata\n            with h5py.File(snapshot_file, \"r\") as file:\n                num_particles = file[\"Header\"].attrs[\"NumPart_Total\"][0]\n                G = file[\"Header\"].attrs[\"G\"][0]\n                time[i] = file[\"Header\"].attrs[\"Time\"][0]\n                dt[i] = file[\"Header\"].attrs[\"dt\"][0]\n\n        # Read the data\n        particle_ids = np.zeros(num_particles, dtype=np.int32)\n        sol_state = np.zeros((len(snapshot_files), num_particles, 7), dtype=np.float64)\n        for i, snapshot_file in enumerate(snapshot_files):\n            with h5py.File(snapshot_file, \"r\") as file:\n                particle_ids = file[\"PartType0\"][\"ParticleIDs\"][()]\n                m = file[\"PartType0\"][\"Masses\"][()]\n                x = file[\"PartType0\"][\"Coordinates\"][()]\n                v = file[\"PartType0\"][\"Velocities\"][()]\n\n                sol_state[i, :, 0] = m\n                sol_state[i, :, 1:4] = x\n                sol_state[i, :, 4:7] = v\n\n        return G, time, dt, particle_ids, sol_state\n\n    @staticmethod\n    def delete_snapshots(\n        output_dir: str | Path,\n    ):\n        \"\"\"Delete all snapshots in the output directory\n\n        Parameters\n        ----------\n        output_dir : str | Path\n            Output directory path\n        \"\"\"\n        output_dir = Path(output_dir)\n        if not output_dir.is_dir():\n            raise FileNotFoundError(f\"Output directory not found: {output_dir}\")\n\n        snapshot_files_csv = sorted(output_dir.glob(\"snapshot_*.csv\"))\n        for snapshot_file in snapshot_files_csv:\n            snapshot_file.unlink()\n\n        snapshot_files_hdf5 = sorted(output_dir.glob(\"snapshot_*.hdf5\"))\n        for snapshot_file in snapshot_files_hdf5:\n            snapshot_file.unlink()\n\n    def compute_energy(self, sol_state: np.ndarray, G: float) -&gt; np.ndarray:\n        \"\"\"Compute the total energy of the system\n\n        Parameters\n        ----------\n        sol_state : np.ndarray\n            3D array of solution state for each snapshot, with shape\n            (num_snapshots, num_particles, 7) being\n            [m, x, y, z, vx, vy, vz]\n        G : float\n            Gravitational constant\n\n        Returns\n        -------\n        energy : np.ndarray\n            1D array of total energy for each snapshot\n        \"\"\"\n        # Check the dimension and shape of sol_state\n        if len(sol_state.shape) != 3:\n            raise ValueError(\"sol_state must be a 3D array\")\n\n        if sol_state.shape[2] != 7:\n            raise ValueError(\n                \"sol_state must have shape (num_snapshots, num_particles, 7)\"\n            )\n\n        # Compute the total energy\n        energy = np.zeros(sol_state.shape[0], dtype=np.float64)\n        self.c_lib.compute_energy_python(\n            energy.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.c_double(G),\n            sol_state.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.c_int32(sol_state.shape[0]),\n            ctypes.c_int32(sol_state.shape[1]),\n        )\n\n        return energy\n\n    def compute_linear_momentum(\n        self,\n        sol_state: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"Compute the total linear_momentum of the system\n\n        Parameters\n        ----------\n        sol_state : np.ndarray\n            3D array of solution state for each snapshot, with shape\n            (num_snapshots, num_particles, 7) being\n            [m, x, y, z, vx, vy, vz]\n\n        Returns\n        -------\n        linear_momentum : np.ndarray\n            1D array of total linear_momentum for each snapshot\n        \"\"\"\n        # Check the dimension and shape of sol_state\n        if len(sol_state.shape) != 3:\n            raise ValueError(\"sol_state must be a 3D array\")\n\n        if sol_state.shape[2] != 7:\n            raise ValueError(\n                \"sol_state must have shape (num_snapshots, num_particles, 7)\"\n            )\n\n        # Compute the total energy\n        linear_momentum = np.zeros(sol_state.shape[0], dtype=np.float64)\n        self.c_lib.compute_linear_momentum_python(\n            linear_momentum.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            sol_state.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.c_int32(sol_state.shape[0]),\n            ctypes.c_int32(sol_state.shape[1]),\n        )\n\n        return linear_momentum\n\n    def compute_angular_momentum(\n        self,\n        sol_state: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"Compute the total angular_momentum of the system\n\n        Parameters\n        ----------\n        sol_state : np.ndarray\n            3D array of solution state for each snapshot, with shape\n            (num_snapshots, num_particles, 7) being\n            [m, x, y, z, vx, vy, vz]\n\n        Returns\n        -------\n        angular_momentum : np.ndarray\n            1D array of total angular_momentum for each snapshot\n        \"\"\"\n        # Check the dimension and shape of sol_state\n        if len(sol_state.shape) != 3:\n            raise ValueError(\"sol_state must be a 3D array\")\n\n        if sol_state.shape[2] != 7:\n            raise ValueError(\n                \"sol_state must have shape (num_snapshots, num_particles, 7)\"\n            )\n\n        # Compute the total energy\n        angular_momentum = np.zeros(sol_state.shape[0], dtype=np.float64)\n        self.c_lib.compute_angular_momentum_python(\n            angular_momentum.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            sol_state.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.c_int32(sol_state.shape[0]),\n            ctypes.c_int32(sol_state.shape[1]),\n        )\n\n        return angular_momentum\n\n    @staticmethod\n    def compute_eccentricity(\n        G: float,\n        sol_state: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"Compute the eccentricity using the sol_state array,\n        assuming that the first object is the central object\n\n        Parameters\n        ----------\n        G : float\n            Gravitational constant\n        sol_state : np.ndarray\n            Solution state of the system\n\n        Returns\n        -------\n        np.ndarray\n            Eccentricity of the system at each time step,\n            with shape (num_snapshots, num_particles - 1)\n\n        Notes\n        -----\n        - The function assumes that the first object is the central object.\n        - C library function is not used here since this can be done with\n            purely numpy vectorized operations. Nevertheless, we may consider\n            implementing this in C library in the future.\n        \"\"\"\n        num_snapshots = sol_state.shape[0]\n        m_0 = sol_state[0, 0, 0]\n        m = sol_state[0, 1:, 0]\n\n        eccentricity = np.zeros(num_snapshots)\n\n        x = sol_state[:, 1:, 1:4].copy() - sol_state[:, 0, 1:4].reshape(-1, 1, 3)\n        v = sol_state[:, 1:, 4:7].copy() - sol_state[:, 0, 4:7].reshape(-1, 1, 3)\n\n        denom = G * (m_0 + m)[np.newaxis, :, np.newaxis]\n        eccentricity = (\n            np.cross(v, np.cross(x, v)) / denom\n            - x / np.linalg.norm(x, axis=2)[:, :, np.newaxis]\n        )\n        eccentricity = np.linalg.norm(eccentricity, axis=2)\n\n        return eccentricity\n\n    @staticmethod\n    def compute_inclination(sol_state: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Compute the inclination using the sol_state array,\n        assuming that the first object is the central object\n\n        Parameters\n        ----------\n        sol_state : np.ndarray\n            Solution state of the system\n\n        Returns\n        -------\n        np.ndarray\n            Inclination of the system at each time step,\n            with shape (num_snapshots, num_particles - 1)\n\n        Notes\n        -----\n        - The function assumes that the first object is the central object.\n        - C library function is not used here since this can be done with\n          purely numpy vectorized operations. Nevertheless, we may consider\n          implementing this in C library in the future.\n        \"\"\"\n        num_snapshots = sol_state.shape[0]\n\n        inclination = np.zeros(num_snapshots)\n\n        x = sol_state[:, 1:, 1:4].copy() - sol_state[:, 0, 1:4].reshape(-1, 1, 3)\n        v = sol_state[:, 1:, 4:7].copy() - sol_state[:, 0, 4:7].reshape(-1, 1, 3)\n\n        unit_angular_momentum_vector = (\n            np.cross(x, v) / np.linalg.norm(np.cross(x, v), axis=2)[:, :, np.newaxis]\n        )\n        unit_z = np.array([0, 0, 1])\n\n        inclination = np.arccos(np.sum(unit_angular_momentum_vector * unit_z, axis=2))\n\n        return inclination\n\n    @staticmethod\n    def plot_rel_energy_error(\n        sol_energy: np.ndarray,\n        sol_time: np.ndarray,\n        is_log_y: bool = True,\n        title: Optional[str] = None,\n        xlabel: Optional[str] = \"Time\",\n        ylabel: Optional[str] = \"$(E_0 - E(t)) / E_0$\",\n        save_fig: bool = False,\n        save_fig_path: Optional[str | Path] = None,\n    ) -&gt; None:\n        if sol_energy[0] == 0.0:\n            warnings.warn(\"The initial energy is zero.\")\n        rel_energy_error = np.abs((sol_energy - sol_energy[0]) / sol_energy[0])\n        plotting.plot_quantity_against_time(\n            quantity=rel_energy_error,\n            sol_time=sol_time,\n            title=title,\n            xlabel=xlabel,\n            ylabel=ylabel,\n            is_log_y=is_log_y,\n            save_fig=save_fig,\n            save_fig_path=save_fig_path,\n        )\n\n    @staticmethod\n    def plot_rel_linear_momentum_error(\n        sol_linear_momentum: np.ndarray,\n        sol_time: np.ndarray,\n        is_log_y: bool = True,\n        title: Optional[str] = None,\n        xlabel: Optional[str] = \"Time\",\n        ylabel: Optional[str] = \"Relative linear momentum error\",\n        save_fig: bool = False,\n        save_fig_path: Optional[str | Path] = None,\n    ) -&gt; None:\n        if sol_linear_momentum[0] == 0.0:\n            warnings.warn(\"The initial linear momentum is zero.\")\n        rel_linear_momentum_error = np.abs(\n            (sol_linear_momentum - sol_linear_momentum[0]) / sol_linear_momentum[0]\n        )\n        plotting.plot_quantity_against_time(\n            quantity=rel_linear_momentum_error,\n            sol_time=sol_time,\n            title=title,\n            xlabel=xlabel,\n            ylabel=ylabel,\n            is_log_y=is_log_y,\n            save_fig=save_fig,\n            save_fig_path=save_fig_path,\n        )\n\n    @staticmethod\n    def plot_rel_angular_momentum_error(\n        sol_angular_momentum: np.ndarray,\n        sol_time: np.ndarray,\n        is_log_y: bool = True,\n        title: Optional[str] = None,\n        xlabel: Optional[str] = \"Time\",\n        ylabel: Optional[str] = \"$(L_0 - L(t)) / L_0$\",\n        save_fig: bool = False,\n        save_fig_path: Optional[str | Path] = None,\n    ) -&gt; None:\n        if sol_angular_momentum[0] == 0.0:\n            warnings.warn(\"The initial angular momentum is zero.\")\n        angular_momentum_error = np.abs(\n            (sol_angular_momentum - sol_angular_momentum[0]) / sol_angular_momentum[0]\n        )\n        plotting.plot_quantity_against_time(\n            quantity=angular_momentum_error,\n            sol_time=sol_time,\n            title=title,\n            xlabel=xlabel,\n            ylabel=ylabel,\n            is_log_y=is_log_y,\n            save_fig=save_fig,\n            save_fig_path=save_fig_path,\n        )\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.__init__","title":"<code>__init__(c_lib_path=None)</code>","text":"<p>Initialize gravity simulator API</p> <p>Parameters:</p> Name Type Description Default <code>c_lib_path</code> <code>str</code> <p>Path to C library, by default None</p> <code>None</code> Source code in <code>grav_sim/api.py</code> <pre><code>def __init__(self, c_lib_path: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Initialize gravity simulator API\n\n    Parameters\n    ----------\n    c_lib_path : str, optional\n        Path to C library, by default None\n    \"\"\"\n    if c_lib_path is not None:\n        self.c_lib = utils.load_c_lib(Path(c_lib_path))\n    else:\n        self.c_lib = utils.load_c_lib()\n    utils.initialize_c_lib(self.c_lib)\n\n    # System\n    self.BUILT_IN_SYSTEMS = System.BUILT_IN_SYSTEMS\n\n    # Plotting\n    self.SOLAR_SYSTEM_COLORS = plotting.SOLAR_SYSTEM_COLORS\n    self.plot_quantity_against_time = plotting.plot_quantity_against_time\n    self.plot_2d_trajectory = plotting.plot_2d_trajectory\n    self.plot_3d_trajectory = plotting.plot_3d_trajectory\n\n    # Simulator\n    self.simulator = Simulator(c_lib=self.c_lib)\n    self.DAYS_PER_YEAR = self.simulator.DAYS_PER_YEAR\n    self.launch_simulation = self.simulator.launch_simulation\n    self.launch_cosmological_simulation = (\n        self.simulator.launch_cosmological_simulation\n    )\n\n    # Parameters\n    self.AVAILABLE_ACCELERATION_METHODS = (\n        parameters.AccelerationParam.AVAILABLE_ACCELERATION_METHODS\n    )\n    self.AVAILABLE_INTEGRATORS = parameters.IntegratorParam.AVAILABLE_INTEGRATORS\n    self.FIXED_STEP_SIZE_INTEGRATORS = (\n        parameters.IntegratorParam.FIXED_STEP_SIZE_INTEGRATORS\n    )\n    self.ADAPTIVE_STEP_SIZE_INTEGRATORS = (\n        parameters.IntegratorParam.ADAPTIVE_STEP_SIZE_INTEGRATORS\n    )\n    self.AVAILABLE_OUTPUT_METHODS = parameters.OutputParam.AVAILABLE_OUTPUT_METHODS\n    self.AVAILABLE_OUTPUT_DTYPE = parameters.OutputParam.AVAILABLE_OUTPUT_DTYPE\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.compute_angular_momentum","title":"<code>compute_angular_momentum(sol_state)</code>","text":"<p>Compute the total angular_momentum of the system</p> <p>Parameters:</p> Name Type Description Default <code>sol_state</code> <code>ndarray</code> <p>3D array of solution state for each snapshot, with shape (num_snapshots, num_particles, 7) being [m, x, y, z, vx, vy, vz]</p> required <p>Returns:</p> Name Type Description <code>angular_momentum</code> <code>ndarray</code> <p>1D array of total angular_momentum for each snapshot</p> Source code in <code>grav_sim/api.py</code> <pre><code>def compute_angular_momentum(\n    self,\n    sol_state: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Compute the total angular_momentum of the system\n\n    Parameters\n    ----------\n    sol_state : np.ndarray\n        3D array of solution state for each snapshot, with shape\n        (num_snapshots, num_particles, 7) being\n        [m, x, y, z, vx, vy, vz]\n\n    Returns\n    -------\n    angular_momentum : np.ndarray\n        1D array of total angular_momentum for each snapshot\n    \"\"\"\n    # Check the dimension and shape of sol_state\n    if len(sol_state.shape) != 3:\n        raise ValueError(\"sol_state must be a 3D array\")\n\n    if sol_state.shape[2] != 7:\n        raise ValueError(\n            \"sol_state must have shape (num_snapshots, num_particles, 7)\"\n        )\n\n    # Compute the total energy\n    angular_momentum = np.zeros(sol_state.shape[0], dtype=np.float64)\n    self.c_lib.compute_angular_momentum_python(\n        angular_momentum.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n        sol_state.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n        ctypes.c_int32(sol_state.shape[0]),\n        ctypes.c_int32(sol_state.shape[1]),\n    )\n\n    return angular_momentum\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.compute_eccentricity","title":"<code>compute_eccentricity(G, sol_state)</code>  <code>staticmethod</code>","text":"<p>Compute the eccentricity using the sol_state array, assuming that the first object is the central object</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>float</code> <p>Gravitational constant</p> required <code>sol_state</code> <code>ndarray</code> <p>Solution state of the system</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Eccentricity of the system at each time step, with shape (num_snapshots, num_particles - 1)</p> Notes <ul> <li>The function assumes that the first object is the central object.</li> <li>C library function is not used here since this can be done with     purely numpy vectorized operations. Nevertheless, we may consider     implementing this in C library in the future.</li> </ul> Source code in <code>grav_sim/api.py</code> <pre><code>@staticmethod\ndef compute_eccentricity(\n    G: float,\n    sol_state: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Compute the eccentricity using the sol_state array,\n    assuming that the first object is the central object\n\n    Parameters\n    ----------\n    G : float\n        Gravitational constant\n    sol_state : np.ndarray\n        Solution state of the system\n\n    Returns\n    -------\n    np.ndarray\n        Eccentricity of the system at each time step,\n        with shape (num_snapshots, num_particles - 1)\n\n    Notes\n    -----\n    - The function assumes that the first object is the central object.\n    - C library function is not used here since this can be done with\n        purely numpy vectorized operations. Nevertheless, we may consider\n        implementing this in C library in the future.\n    \"\"\"\n    num_snapshots = sol_state.shape[0]\n    m_0 = sol_state[0, 0, 0]\n    m = sol_state[0, 1:, 0]\n\n    eccentricity = np.zeros(num_snapshots)\n\n    x = sol_state[:, 1:, 1:4].copy() - sol_state[:, 0, 1:4].reshape(-1, 1, 3)\n    v = sol_state[:, 1:, 4:7].copy() - sol_state[:, 0, 4:7].reshape(-1, 1, 3)\n\n    denom = G * (m_0 + m)[np.newaxis, :, np.newaxis]\n    eccentricity = (\n        np.cross(v, np.cross(x, v)) / denom\n        - x / np.linalg.norm(x, axis=2)[:, :, np.newaxis]\n    )\n    eccentricity = np.linalg.norm(eccentricity, axis=2)\n\n    return eccentricity\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.compute_energy","title":"<code>compute_energy(sol_state, G)</code>","text":"<p>Compute the total energy of the system</p> <p>Parameters:</p> Name Type Description Default <code>sol_state</code> <code>ndarray</code> <p>3D array of solution state for each snapshot, with shape (num_snapshots, num_particles, 7) being [m, x, y, z, vx, vy, vz]</p> required <code>G</code> <code>float</code> <p>Gravitational constant</p> required <p>Returns:</p> Name Type Description <code>energy</code> <code>ndarray</code> <p>1D array of total energy for each snapshot</p> Source code in <code>grav_sim/api.py</code> <pre><code>def compute_energy(self, sol_state: np.ndarray, G: float) -&gt; np.ndarray:\n    \"\"\"Compute the total energy of the system\n\n    Parameters\n    ----------\n    sol_state : np.ndarray\n        3D array of solution state for each snapshot, with shape\n        (num_snapshots, num_particles, 7) being\n        [m, x, y, z, vx, vy, vz]\n    G : float\n        Gravitational constant\n\n    Returns\n    -------\n    energy : np.ndarray\n        1D array of total energy for each snapshot\n    \"\"\"\n    # Check the dimension and shape of sol_state\n    if len(sol_state.shape) != 3:\n        raise ValueError(\"sol_state must be a 3D array\")\n\n    if sol_state.shape[2] != 7:\n        raise ValueError(\n            \"sol_state must have shape (num_snapshots, num_particles, 7)\"\n        )\n\n    # Compute the total energy\n    energy = np.zeros(sol_state.shape[0], dtype=np.float64)\n    self.c_lib.compute_energy_python(\n        energy.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n        ctypes.c_double(G),\n        sol_state.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n        ctypes.c_int32(sol_state.shape[0]),\n        ctypes.c_int32(sol_state.shape[1]),\n    )\n\n    return energy\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.compute_inclination","title":"<code>compute_inclination(sol_state)</code>  <code>staticmethod</code>","text":"<p>Compute the inclination using the sol_state array, assuming that the first object is the central object</p> <p>Parameters:</p> Name Type Description Default <code>sol_state</code> <code>ndarray</code> <p>Solution state of the system</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Inclination of the system at each time step, with shape (num_snapshots, num_particles - 1)</p> Notes <ul> <li>The function assumes that the first object is the central object.</li> <li>C library function is not used here since this can be done with   purely numpy vectorized operations. Nevertheless, we may consider   implementing this in C library in the future.</li> </ul> Source code in <code>grav_sim/api.py</code> <pre><code>@staticmethod\ndef compute_inclination(sol_state: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Compute the inclination using the sol_state array,\n    assuming that the first object is the central object\n\n    Parameters\n    ----------\n    sol_state : np.ndarray\n        Solution state of the system\n\n    Returns\n    -------\n    np.ndarray\n        Inclination of the system at each time step,\n        with shape (num_snapshots, num_particles - 1)\n\n    Notes\n    -----\n    - The function assumes that the first object is the central object.\n    - C library function is not used here since this can be done with\n      purely numpy vectorized operations. Nevertheless, we may consider\n      implementing this in C library in the future.\n    \"\"\"\n    num_snapshots = sol_state.shape[0]\n\n    inclination = np.zeros(num_snapshots)\n\n    x = sol_state[:, 1:, 1:4].copy() - sol_state[:, 0, 1:4].reshape(-1, 1, 3)\n    v = sol_state[:, 1:, 4:7].copy() - sol_state[:, 0, 4:7].reshape(-1, 1, 3)\n\n    unit_angular_momentum_vector = (\n        np.cross(x, v) / np.linalg.norm(np.cross(x, v), axis=2)[:, :, np.newaxis]\n    )\n    unit_z = np.array([0, 0, 1])\n\n    inclination = np.arccos(np.sum(unit_angular_momentum_vector * unit_z, axis=2))\n\n    return inclination\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.compute_linear_momentum","title":"<code>compute_linear_momentum(sol_state)</code>","text":"<p>Compute the total linear_momentum of the system</p> <p>Parameters:</p> Name Type Description Default <code>sol_state</code> <code>ndarray</code> <p>3D array of solution state for each snapshot, with shape (num_snapshots, num_particles, 7) being [m, x, y, z, vx, vy, vz]</p> required <p>Returns:</p> Name Type Description <code>linear_momentum</code> <code>ndarray</code> <p>1D array of total linear_momentum for each snapshot</p> Source code in <code>grav_sim/api.py</code> <pre><code>def compute_linear_momentum(\n    self,\n    sol_state: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Compute the total linear_momentum of the system\n\n    Parameters\n    ----------\n    sol_state : np.ndarray\n        3D array of solution state for each snapshot, with shape\n        (num_snapshots, num_particles, 7) being\n        [m, x, y, z, vx, vy, vz]\n\n    Returns\n    -------\n    linear_momentum : np.ndarray\n        1D array of total linear_momentum for each snapshot\n    \"\"\"\n    # Check the dimension and shape of sol_state\n    if len(sol_state.shape) != 3:\n        raise ValueError(\"sol_state must be a 3D array\")\n\n    if sol_state.shape[2] != 7:\n        raise ValueError(\n            \"sol_state must have shape (num_snapshots, num_particles, 7)\"\n        )\n\n    # Compute the total energy\n    linear_momentum = np.zeros(sol_state.shape[0], dtype=np.float64)\n    self.c_lib.compute_linear_momentum_python(\n        linear_momentum.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n        sol_state.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n        ctypes.c_int32(sol_state.shape[0]),\n        ctypes.c_int32(sol_state.shape[1]),\n    )\n\n    return linear_momentum\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.delete_snapshots","title":"<code>delete_snapshots(output_dir)</code>  <code>staticmethod</code>","text":"<p>Delete all snapshots in the output directory</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str | Path</code> <p>Output directory path</p> required Source code in <code>grav_sim/api.py</code> <pre><code>@staticmethod\ndef delete_snapshots(\n    output_dir: str | Path,\n):\n    \"\"\"Delete all snapshots in the output directory\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        Output directory path\n    \"\"\"\n    output_dir = Path(output_dir)\n    if not output_dir.is_dir():\n        raise FileNotFoundError(f\"Output directory not found: {output_dir}\")\n\n    snapshot_files_csv = sorted(output_dir.glob(\"snapshot_*.csv\"))\n    for snapshot_file in snapshot_files_csv:\n        snapshot_file.unlink()\n\n    snapshot_files_hdf5 = sorted(output_dir.glob(\"snapshot_*.hdf5\"))\n    for snapshot_file in snapshot_files_hdf5:\n        snapshot_file.unlink()\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.get_built_in_system","title":"<code>get_built_in_system(system_name)</code>","text":"<p>Get a built-in gravitational system</p> <p>Parameters:</p> Name Type Description Default <code>system_name</code> <code>str</code> <p>Name of the built-in system to be loaded.</p> required Source code in <code>grav_sim/api.py</code> <pre><code>def get_built_in_system(self, system_name: str) -&gt; System:\n    \"\"\"Get a built-in gravitational system\n\n    Parameters\n    ----------\n    system_name : str\n        Name of the built-in system to be loaded.\n    \"\"\"\n    return System.get_built_in_system(self.c_lib, system_name)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.get_new_cosmological_system","title":"<code>get_new_cosmological_system()</code>","text":"<p>Create a cosmological system</p> <p>Returns:</p> Type Description <code>CosmologicalSystem object</code> Source code in <code>grav_sim/api.py</code> <pre><code>def get_new_cosmological_system(self) -&gt; CosmologicalSystem:\n    \"\"\"Create a cosmological system\n\n    Returns\n    -------\n    CosmologicalSystem object\n    \"\"\"\n    return CosmologicalSystem(c_lib=self.c_lib)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.get_new_parameters","title":"<code>get_new_parameters()</code>  <code>staticmethod</code>","text":"<p>Create new simulation parameters</p> <p>Returns:</p> Type Description <code>Tuple of acceleration, integrator, output, and settings parameters</code> Source code in <code>grav_sim/api.py</code> <pre><code>@staticmethod\ndef get_new_parameters() -&gt; Tuple[\n    parameters.AccelerationParam,\n    parameters.IntegratorParam,\n    parameters.OutputParam,\n    parameters.Settings,\n]:\n    \"\"\"Create new simulation parameters\n\n    Returns\n    -------\n    Tuple of acceleration, integrator, output, and settings parameters\n    \"\"\"\n    acceleration_param = parameters.AccelerationParam()\n    integrator_param = parameters.IntegratorParam()\n    output_param = parameters.OutputParam()\n    settings = parameters.Settings()\n\n    return acceleration_param, integrator_param, output_param, settings\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.get_new_system","title":"<code>get_new_system()</code>","text":"<p>Create a gravitational system</p> <p>Returns:</p> Type Description <code>System object</code> Source code in <code>grav_sim/api.py</code> <pre><code>def get_new_system(self) -&gt; System:\n    \"\"\"Create a gravitational system\n\n    Returns\n    -------\n    System object\n    \"\"\"\n    return System(c_lib=self.c_lib)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.load_system","title":"<code>load_system(file_path)</code>","text":"<p>Load system from a CSV file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File path to load the system from</p> required Source code in <code>grav_sim/api.py</code> <pre><code>def load_system(\n    self,\n    file_path: str | Path,\n) -&gt; System:\n    \"\"\"Load system from a CSV file\n\n    Parameters\n    ----------\n    file_path : str\n        File path to load the system from\n    \"\"\"\n    return System.load_system(self.c_lib, file_path)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.read_csv_data","title":"<code>read_csv_data(output_dir)</code>  <code>staticmethod</code>","text":"<p>Read CSV snapshots from the output directory, assuming number of particles and particle_ids stays the same</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str | Path</code> <p>Output directory path</p> required <p>Returns:</p> Name Type Description <code>G</code> <code>float</code> <p>Gravitational constant</p> <code>time</code> <code>ndarray</code> <p>Simulation time of each snapshot</p> <code>dt</code> <code>ndarray</code> <p>Time step of each snapshot</p> <code>particle_ids</code> <code>ndarray</code> <p>1D array of Particle IDs</p> <code>sol_state</code> <code>ndarray</code> <p>3D array of solution state for each snapshot, with shape (num_snapshots, num_particles, 7) being [m, x, y, z, vx, vy, vz]</p> Source code in <code>grav_sim/api.py</code> <pre><code>@staticmethod\ndef read_csv_data(\n    output_dir: str | Path,\n) -&gt; Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Read CSV snapshots from the output directory,\n    assuming number of particles and particle_ids\n    stays the same\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        Output directory path\n\n    Returns\n    -------\n    G : float\n        Gravitational constant\n    time : np.ndarray\n        Simulation time of each snapshot\n    dt : np.ndarray\n        Time step of each snapshot\n    particle_ids : np.ndarray\n        1D array of Particle IDs\n    sol_state : np.ndarray\n        3D array of solution state for each snapshot, with shape\n        (num_snapshots, num_particles, 7) being\n        [m, x, y, z, vx, vy, vz]\n    \"\"\"\n    output_dir = Path(output_dir)\n    if not output_dir.is_dir():\n        raise FileNotFoundError(f\"Output directory not found: {output_dir}\")\n\n    snapshot_files = sorted(output_dir.glob(\"snapshot_*.csv\"))\n    if len(snapshot_files) == 0:\n        raise FileNotFoundError(f\"No snapshot files found in: {output_dir}\")\n\n    G = -1.0\n    time = np.zeros(len(snapshot_files), dtype=np.float64)\n    dt = np.zeros(len(snapshot_files), dtype=np.float64)\n\n    for i, snapshot_file in enumerate(snapshot_files):\n        # Read the metadata\n        with open(snapshot_file, \"r\") as file:\n            read_metadata_num_particles = False\n            read_metadata_G = False\n            read_metadata_time = False\n            read_metadata_dt = False\n            for line in file:\n                line = line.strip()\n\n                if line.startswith(\"#\"):\n                    if line.startswith(\"# num_particles\"):\n                        if i == 0:\n                            num_particles = int(line.split(\":\")[1].strip())\n                        elif num_particles != int(line.split(\":\")[1].strip()):\n                            raise ValueError(\n                                f\"Number of particles changed from {num_particles} to {int(line.split(':')[1].strip())}\"\n                            )\n                        read_metadata_num_particles = True\n                    elif line.startswith(\"# G\"):\n                        G = float(line.split(\":\")[1].strip())\n                        read_metadata_G = True\n                    elif line.startswith(\"# time\"):\n                        time[i] = float(line.split(\":\")[1].strip())\n                        read_metadata_time = True\n                    elif line.startswith(\"# dt\"):\n                        dt[i] = float(line.split(\":\")[1].strip())\n                        read_metadata_dt = True\n\n                if (\n                    read_metadata_num_particles\n                    and read_metadata_G\n                    and read_metadata_time\n                    and read_metadata_dt\n                ):\n                    break\n\n    # Read the data\n    particle_ids = np.zeros(num_particles, dtype=np.int32)\n    sol_state = np.zeros((len(snapshot_files), num_particles, 7), dtype=np.float64)\n    for i, snapshot_file in enumerate(snapshot_files):\n        data = np.genfromtxt(snapshot_file, delimiter=\",\", skip_header=5)\n        if i == 0:\n            particle_ids = data[:, 0].astype(np.int32)\n            particle_ids = np.sort(particle_ids)\n            _, num_duplicates = np.unique(particle_ids, return_counts=True)\n            if np.any(num_duplicates &gt; 1):\n                raise ValueError(\n                    f\"Particle IDs are not unique. Particle IDs: {particle_ids}\"\n                )\n\n        snapshot_particle_ids = data[:, 0].astype(np.int32)\n\n        # Sort the data by particle IDs\n        sorted_indices = np.argsort(snapshot_particle_ids)\n        data = data[sorted_indices]\n\n        # Check if the particle IDs match\n        if not np.array_equal(particle_ids, snapshot_particle_ids):\n            raise ValueError(\n                f\"Particle IDs do not match in snapshot {i + 1}: {snapshot_file}\"\n            )\n\n        # Store the data\n        sol_state[i, :, :] = data[:, 1:]\n\n    return G, time, dt, particle_ids, sol_state\n</code></pre>"},{"location":"docs/documentations/PythonAPI/GravitySimulatorAPI/#grav_sim.GravitySimulatorAPI.read_hdf5_data","title":"<code>read_hdf5_data(output_dir)</code>  <code>staticmethod</code>","text":"<p>Read HDF5 snapshots from the output directory, assuming number of particles and particle_ids stays the same</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str | Path</code> <p>Output directory path</p> required <p>Returns:</p> Name Type Description <code>G</code> <code>float</code> <p>Gravitational constant</p> <code>time</code> <code>ndarray</code> <p>Simulation time of each snapshot</p> <code>dt</code> <code>ndarray</code> <p>Time step of each snapshot</p> <code>particle_ids</code> <code>ndarray</code> <p>1D array of Particle IDs</p> <code>sol_state</code> <code>ndarray</code> <p>3D array of solution state for each snapshot, with shape (num_snapshots, num_particles, 7) being [m, x, y, z, vx, vy, vz]</p> Source code in <code>grav_sim/api.py</code> <pre><code>@staticmethod\ndef read_hdf5_data(\n    output_dir: str | Path,\n) -&gt; Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Read HDF5 snapshots from the output directory,\n    assuming number of particles and particle_ids\n    stays the same\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        Output directory path\n\n    Returns\n    -------\n    G : float\n        Gravitational constant\n    time : np.ndarray\n        Simulation time of each snapshot\n    dt : np.ndarray\n        Time step of each snapshot\n    particle_ids : np.ndarray\n        1D array of Particle IDs\n    sol_state : np.ndarray\n        3D array of solution state for each snapshot, with shape\n        (num_snapshots, num_particles, 7) being\n        [m, x, y, z, vx, vy, vz]\n    \"\"\"\n    output_dir = Path(output_dir)\n    if not output_dir.is_dir():\n        raise FileNotFoundError(f\"Output directory not found: {output_dir}\")\n\n    snapshot_files = sorted(output_dir.glob(\"snapshot_*.hdf5\"))\n    if len(snapshot_files) == 0:\n        raise FileNotFoundError(f\"No snapshot files found in: {output_dir}\")\n\n    G = -1.0\n    time = np.zeros(len(snapshot_files), dtype=np.float64)\n    dt = np.zeros(len(snapshot_files), dtype=np.float64)\n\n    for i, snapshot_file in enumerate(snapshot_files):\n        # Read the metadata\n        with h5py.File(snapshot_file, \"r\") as file:\n            num_particles = file[\"Header\"].attrs[\"NumPart_Total\"][0]\n            G = file[\"Header\"].attrs[\"G\"][0]\n            time[i] = file[\"Header\"].attrs[\"Time\"][0]\n            dt[i] = file[\"Header\"].attrs[\"dt\"][0]\n\n    # Read the data\n    particle_ids = np.zeros(num_particles, dtype=np.int32)\n    sol_state = np.zeros((len(snapshot_files), num_particles, 7), dtype=np.float64)\n    for i, snapshot_file in enumerate(snapshot_files):\n        with h5py.File(snapshot_file, \"r\") as file:\n            particle_ids = file[\"PartType0\"][\"ParticleIDs\"][()]\n            m = file[\"PartType0\"][\"Masses\"][()]\n            x = file[\"PartType0\"][\"Coordinates\"][()]\n            v = file[\"PartType0\"][\"Velocities\"][()]\n\n            sol_state[i, :, 0] = m\n            sol_state[i, :, 1:4] = x\n            sol_state[i, :, 4:7] = v\n\n    return G, time, dt, particle_ids, sol_state\n</code></pre>"},{"location":"docs/documentations/PythonAPI/Simulator/","title":"Simulator","text":"Source code in <code>grav_sim/simulator.py</code> <pre><code>class Simulator:\n    DAYS_PER_YEAR = 365.242189\n\n    def __init__(self, c_lib: ctypes.CDLL) -&gt; None:\n        self.c_lib = c_lib\n\n    def launch_simulation(\n        self,\n        system: System,\n        acceleration_param: AccelerationParam,\n        integrator_param: IntegratorParam,\n        output_param: OutputParam,\n        settings: Settings,\n        tf: float,\n    ) -&gt; None:\n        \"\"\"Launch simulation\n\n        Parameters\n        ----------\n        system : System\n            Gravitational system\n        acceleration_param : AccelerationParam\n            Acceleration parameters\n        integrator_param : IntegratorParam\n            Integrator parameters\n        output_param : OutputParam\n            Output parameters\n        settings : Settings\n            Simulation settings\n        tf : float\n            Simulation time\n\n        Raises\n        -------\n        RuntimeError\n            If simulation fails\n        \"\"\"\n        num_particles = ctypes.c_int32(system.num_particles)\n        new_particle_ids = ctypes.POINTER(ctypes.c_int32)()\n        new_x = ctypes.POINTER(ctypes.c_double)()\n        new_v = ctypes.POINTER(ctypes.c_double)()\n        new_m = ctypes.POINTER(ctypes.c_double)()\n\n        is_exit = ctypes.c_bool(False)\n\n        # Create a thread to stop the simulation if user sends KeyboardInterrupt\n        def simulation_wrapper(c_lib_launch_simulation_python, return_queue, *args):\n            return_queue.put(c_lib_launch_simulation_python(*args))\n\n        queue: Queue = Queue()\n        simulation_thread = threading.Thread(\n            target=simulation_wrapper,\n            args=(\n                self.c_lib.launch_simulation_python,\n                queue,\n                ctypes.byref(num_particles),\n                system.particle_ids.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),\n                system.x.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                system.v.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                system.m.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                ctypes.byref(new_particle_ids),\n                ctypes.byref(new_x),\n                ctypes.byref(new_v),\n                ctypes.byref(new_m),\n                ctypes.c_double(system.G),\n                ctypes.c_int32(integrator_param._integrator),\n                ctypes.c_double(integrator_param.dt),\n                ctypes.c_double(integrator_param.tolerance),\n                ctypes.c_double(integrator_param.initial_dt),\n                ctypes.c_bool(integrator_param.whfast_remove_invalid_particles),\n                ctypes.c_int32(acceleration_param._method),\n                ctypes.c_double(acceleration_param.opening_angle),\n                ctypes.c_double(acceleration_param.softening_length),\n                ctypes.c_int32(acceleration_param.max_num_particles_per_leaf),\n                ctypes.c_int32(output_param._method),\n                output_param.output_dir.encode(\"utf-8\"),\n                ctypes.c_bool(output_param.output_initial),\n                ctypes.c_double(output_param.output_interval),\n                ctypes.c_int32(output_param._coordinate_output_dtype),\n                ctypes.c_int32(output_param._velocity_output_dtype),\n                ctypes.c_int32(output_param._mass_output_dtype),\n                ctypes.c_int32(settings._verbose),\n                ctypes.c_bool(settings.enable_progress_bar),\n                ctypes.byref(is_exit),\n                ctypes.c_double(tf),\n            ),\n        )\n\n        ### Launch simulation ###\n        try:\n            simulation_thread.start()\n\n            while simulation_thread.is_alive():\n                time.sleep(0.05)\n\n        except KeyboardInterrupt:\n            print(\"\\nKeyboardInterrupt detected. Stopping simulation...\\n\")\n            is_exit.value = True\n            simulation_thread.join()\n            raise KeyboardInterrupt\n\n        # End simulation and get return value\n        simulation_thread.join()\n        ret_val = queue.get()\n        if ret_val != 0:\n            raise RuntimeError(\n                \"Simulation failed. Please check the C library traceback.\"\n            )\n\n        # Update system with new data (just to be safe since\n        # we don't know if the memory will be changed in the C library)\n        system.particle_ids = np.ctypeslib.as_array(\n            new_particle_ids,\n            shape=(num_particles.value,),\n        )\n        system.x = np.ctypeslib.as_array(\n            new_x,\n            shape=(num_particles.value, 3),\n        )\n        system.v = np.ctypeslib.as_array(\n            new_v,\n            shape=(num_particles.value, 3),\n        )\n        system.m = np.ctypeslib.as_array(\n            new_m,\n            shape=(num_particles.value,),\n        )\n        system.num_particles = num_particles.value\n\n    def launch_cosmological_simulation(\n        self,\n        system: CosmologicalSystem,\n        output_param: OutputParam,\n        settings: Settings,\n        a_final: float,\n        num_steps: int,\n        pm_grid_size: int,\n    ) -&gt; None:\n        \"\"\"Launch simulation\n\n        Parameters\n        ----------\n        system : CosmologicalSystem\n            Cosmological system\n        output_param : OutputParam\n            Output parameters\n        settings : Settings\n            Simulation settings\n        a_final : float\n            Final scale factor\n        num_steps : int\n            Number of steps to simulate\n        pm_grid_size : int\n            Size of the Particle-Mesh grid\n\n        Raises\n        -------\n        RuntimeError\n            If simulation fails\n        \"\"\"\n        num_particles = ctypes.c_int32(system.num_particles)\n        new_particle_ids = ctypes.POINTER(ctypes.c_int32)()\n        new_x = ctypes.POINTER(ctypes.c_double)()\n        new_v = ctypes.POINTER(ctypes.c_double)()\n        new_m = ctypes.POINTER(ctypes.c_double)()\n\n        is_exit = ctypes.c_bool(False)\n\n        # Create a thread to stop the simulation if user sends KeyboardInterrupt\n        def simulation_wrapper(c_lib_launch_simulation_python, return_queue, *args):\n            return_queue.put(c_lib_launch_simulation_python(*args))\n\n        queue: Queue = Queue()\n        simulation_thread = threading.Thread(\n            target=simulation_wrapper,\n            args=(\n                self.c_lib.launch_cosmological_simulation_python,\n                queue,\n                ctypes.byref(num_particles),\n                system.particle_ids.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),\n                system.x.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                system.v.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                system.m.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                ctypes.byref(new_particle_ids),\n                ctypes.byref(new_x),\n                ctypes.byref(new_v),\n                ctypes.byref(new_m),\n                ctypes.c_double(system.h),\n                ctypes.c_double(system.scale_factor),\n                ctypes.c_double(system.omega_m),\n                ctypes.c_double(system.omega_lambda),\n                system.box_center.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n                ctypes.c_double(system.box_width),\n                ctypes.c_double(system.unit_mass_in_cgs),\n                ctypes.c_double(system.unit_length_in_cgs),\n                ctypes.c_double(system.unit_time_in_cgs),\n                ctypes.c_int32(output_param._method),\n                output_param.output_dir.encode(\"utf-8\"),\n                ctypes.c_bool(output_param.output_initial),\n                ctypes.c_double(output_param.output_interval),\n                ctypes.c_int32(output_param._coordinate_output_dtype),\n                ctypes.c_int32(output_param._velocity_output_dtype),\n                ctypes.c_int32(output_param._mass_output_dtype),\n                ctypes.c_int32(settings._verbose),\n                ctypes.c_bool(settings.enable_progress_bar),\n                ctypes.byref(is_exit),\n                ctypes.c_double(a_final),\n                ctypes.c_int32(num_steps),\n                ctypes.c_int32(pm_grid_size),\n            ),\n        )\n\n        ### Launch simulation ###\n        try:\n            simulation_thread.start()\n\n            while simulation_thread.is_alive():\n                time.sleep(0.05)\n\n        except KeyboardInterrupt:\n            print(\"\\nKeyboardInterrupt detected. Stopping simulation...\\n\")\n            is_exit.value = True\n            simulation_thread.join()\n            raise KeyboardInterrupt\n\n        # End simulation and get return value\n        simulation_thread.join()\n        ret_val = queue.get()\n        if ret_val != 0:\n            raise RuntimeError(\n                \"Simulation failed. Please check the C library traceback.\"\n            )\n\n        # Update system with new data (just to be safe since\n        # we don't know if the memory will be changed in the C library)\n        system.particle_ids = np.ctypeslib.as_array(\n            new_particle_ids,\n            shape=(num_particles.value,),\n        )\n        system.x = np.ctypeslib.as_array(\n            new_x,\n            shape=(num_particles.value, 3),\n        )\n        system.v = np.ctypeslib.as_array(\n            new_v,\n            shape=(num_particles.value, 3),\n        )\n        system.m = np.ctypeslib.as_array(\n            new_m,\n            shape=(num_particles.value,),\n        )\n        system.num_particles = num_particles.value\n</code></pre>"},{"location":"docs/documentations/PythonAPI/Simulator/#grav_sim.simulator.Simulator.launch_cosmological_simulation","title":"<code>launch_cosmological_simulation(system, output_param, settings, a_final, num_steps, pm_grid_size)</code>","text":"<p>Launch simulation</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>CosmologicalSystem</code> <p>Cosmological system</p> required <code>output_param</code> <code>OutputParam</code> <p>Output parameters</p> required <code>settings</code> <code>Settings</code> <p>Simulation settings</p> required <code>a_final</code> <code>float</code> <p>Final scale factor</p> required <code>num_steps</code> <code>int</code> <p>Number of steps to simulate</p> required <code>pm_grid_size</code> <code>int</code> <p>Size of the Particle-Mesh grid</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If simulation fails</p> Source code in <code>grav_sim/simulator.py</code> <pre><code>def launch_cosmological_simulation(\n    self,\n    system: CosmologicalSystem,\n    output_param: OutputParam,\n    settings: Settings,\n    a_final: float,\n    num_steps: int,\n    pm_grid_size: int,\n) -&gt; None:\n    \"\"\"Launch simulation\n\n    Parameters\n    ----------\n    system : CosmologicalSystem\n        Cosmological system\n    output_param : OutputParam\n        Output parameters\n    settings : Settings\n        Simulation settings\n    a_final : float\n        Final scale factor\n    num_steps : int\n        Number of steps to simulate\n    pm_grid_size : int\n        Size of the Particle-Mesh grid\n\n    Raises\n    -------\n    RuntimeError\n        If simulation fails\n    \"\"\"\n    num_particles = ctypes.c_int32(system.num_particles)\n    new_particle_ids = ctypes.POINTER(ctypes.c_int32)()\n    new_x = ctypes.POINTER(ctypes.c_double)()\n    new_v = ctypes.POINTER(ctypes.c_double)()\n    new_m = ctypes.POINTER(ctypes.c_double)()\n\n    is_exit = ctypes.c_bool(False)\n\n    # Create a thread to stop the simulation if user sends KeyboardInterrupt\n    def simulation_wrapper(c_lib_launch_simulation_python, return_queue, *args):\n        return_queue.put(c_lib_launch_simulation_python(*args))\n\n    queue: Queue = Queue()\n    simulation_thread = threading.Thread(\n        target=simulation_wrapper,\n        args=(\n            self.c_lib.launch_cosmological_simulation_python,\n            queue,\n            ctypes.byref(num_particles),\n            system.particle_ids.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),\n            system.x.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            system.v.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            system.m.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.byref(new_particle_ids),\n            ctypes.byref(new_x),\n            ctypes.byref(new_v),\n            ctypes.byref(new_m),\n            ctypes.c_double(system.h),\n            ctypes.c_double(system.scale_factor),\n            ctypes.c_double(system.omega_m),\n            ctypes.c_double(system.omega_lambda),\n            system.box_center.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.c_double(system.box_width),\n            ctypes.c_double(system.unit_mass_in_cgs),\n            ctypes.c_double(system.unit_length_in_cgs),\n            ctypes.c_double(system.unit_time_in_cgs),\n            ctypes.c_int32(output_param._method),\n            output_param.output_dir.encode(\"utf-8\"),\n            ctypes.c_bool(output_param.output_initial),\n            ctypes.c_double(output_param.output_interval),\n            ctypes.c_int32(output_param._coordinate_output_dtype),\n            ctypes.c_int32(output_param._velocity_output_dtype),\n            ctypes.c_int32(output_param._mass_output_dtype),\n            ctypes.c_int32(settings._verbose),\n            ctypes.c_bool(settings.enable_progress_bar),\n            ctypes.byref(is_exit),\n            ctypes.c_double(a_final),\n            ctypes.c_int32(num_steps),\n            ctypes.c_int32(pm_grid_size),\n        ),\n    )\n\n    ### Launch simulation ###\n    try:\n        simulation_thread.start()\n\n        while simulation_thread.is_alive():\n            time.sleep(0.05)\n\n    except KeyboardInterrupt:\n        print(\"\\nKeyboardInterrupt detected. Stopping simulation...\\n\")\n        is_exit.value = True\n        simulation_thread.join()\n        raise KeyboardInterrupt\n\n    # End simulation and get return value\n    simulation_thread.join()\n    ret_val = queue.get()\n    if ret_val != 0:\n        raise RuntimeError(\n            \"Simulation failed. Please check the C library traceback.\"\n        )\n\n    # Update system with new data (just to be safe since\n    # we don't know if the memory will be changed in the C library)\n    system.particle_ids = np.ctypeslib.as_array(\n        new_particle_ids,\n        shape=(num_particles.value,),\n    )\n    system.x = np.ctypeslib.as_array(\n        new_x,\n        shape=(num_particles.value, 3),\n    )\n    system.v = np.ctypeslib.as_array(\n        new_v,\n        shape=(num_particles.value, 3),\n    )\n    system.m = np.ctypeslib.as_array(\n        new_m,\n        shape=(num_particles.value,),\n    )\n    system.num_particles = num_particles.value\n</code></pre>"},{"location":"docs/documentations/PythonAPI/Simulator/#grav_sim.simulator.Simulator.launch_simulation","title":"<code>launch_simulation(system, acceleration_param, integrator_param, output_param, settings, tf)</code>","text":"<p>Launch simulation</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>Gravitational system</p> required <code>acceleration_param</code> <code>AccelerationParam</code> <p>Acceleration parameters</p> required <code>integrator_param</code> <code>IntegratorParam</code> <p>Integrator parameters</p> required <code>output_param</code> <code>OutputParam</code> <p>Output parameters</p> required <code>settings</code> <code>Settings</code> <p>Simulation settings</p> required <code>tf</code> <code>float</code> <p>Simulation time</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If simulation fails</p> Source code in <code>grav_sim/simulator.py</code> <pre><code>def launch_simulation(\n    self,\n    system: System,\n    acceleration_param: AccelerationParam,\n    integrator_param: IntegratorParam,\n    output_param: OutputParam,\n    settings: Settings,\n    tf: float,\n) -&gt; None:\n    \"\"\"Launch simulation\n\n    Parameters\n    ----------\n    system : System\n        Gravitational system\n    acceleration_param : AccelerationParam\n        Acceleration parameters\n    integrator_param : IntegratorParam\n        Integrator parameters\n    output_param : OutputParam\n        Output parameters\n    settings : Settings\n        Simulation settings\n    tf : float\n        Simulation time\n\n    Raises\n    -------\n    RuntimeError\n        If simulation fails\n    \"\"\"\n    num_particles = ctypes.c_int32(system.num_particles)\n    new_particle_ids = ctypes.POINTER(ctypes.c_int32)()\n    new_x = ctypes.POINTER(ctypes.c_double)()\n    new_v = ctypes.POINTER(ctypes.c_double)()\n    new_m = ctypes.POINTER(ctypes.c_double)()\n\n    is_exit = ctypes.c_bool(False)\n\n    # Create a thread to stop the simulation if user sends KeyboardInterrupt\n    def simulation_wrapper(c_lib_launch_simulation_python, return_queue, *args):\n        return_queue.put(c_lib_launch_simulation_python(*args))\n\n    queue: Queue = Queue()\n    simulation_thread = threading.Thread(\n        target=simulation_wrapper,\n        args=(\n            self.c_lib.launch_simulation_python,\n            queue,\n            ctypes.byref(num_particles),\n            system.particle_ids.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),\n            system.x.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            system.v.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            system.m.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n            ctypes.byref(new_particle_ids),\n            ctypes.byref(new_x),\n            ctypes.byref(new_v),\n            ctypes.byref(new_m),\n            ctypes.c_double(system.G),\n            ctypes.c_int32(integrator_param._integrator),\n            ctypes.c_double(integrator_param.dt),\n            ctypes.c_double(integrator_param.tolerance),\n            ctypes.c_double(integrator_param.initial_dt),\n            ctypes.c_bool(integrator_param.whfast_remove_invalid_particles),\n            ctypes.c_int32(acceleration_param._method),\n            ctypes.c_double(acceleration_param.opening_angle),\n            ctypes.c_double(acceleration_param.softening_length),\n            ctypes.c_int32(acceleration_param.max_num_particles_per_leaf),\n            ctypes.c_int32(output_param._method),\n            output_param.output_dir.encode(\"utf-8\"),\n            ctypes.c_bool(output_param.output_initial),\n            ctypes.c_double(output_param.output_interval),\n            ctypes.c_int32(output_param._coordinate_output_dtype),\n            ctypes.c_int32(output_param._velocity_output_dtype),\n            ctypes.c_int32(output_param._mass_output_dtype),\n            ctypes.c_int32(settings._verbose),\n            ctypes.c_bool(settings.enable_progress_bar),\n            ctypes.byref(is_exit),\n            ctypes.c_double(tf),\n        ),\n    )\n\n    ### Launch simulation ###\n    try:\n        simulation_thread.start()\n\n        while simulation_thread.is_alive():\n            time.sleep(0.05)\n\n    except KeyboardInterrupt:\n        print(\"\\nKeyboardInterrupt detected. Stopping simulation...\\n\")\n        is_exit.value = True\n        simulation_thread.join()\n        raise KeyboardInterrupt\n\n    # End simulation and get return value\n    simulation_thread.join()\n    ret_val = queue.get()\n    if ret_val != 0:\n        raise RuntimeError(\n            \"Simulation failed. Please check the C library traceback.\"\n        )\n\n    # Update system with new data (just to be safe since\n    # we don't know if the memory will be changed in the C library)\n    system.particle_ids = np.ctypeslib.as_array(\n        new_particle_ids,\n        shape=(num_particles.value,),\n    )\n    system.x = np.ctypeslib.as_array(\n        new_x,\n        shape=(num_particles.value, 3),\n    )\n    system.v = np.ctypeslib.as_array(\n        new_v,\n        shape=(num_particles.value, 3),\n    )\n    system.m = np.ctypeslib.as_array(\n        new_m,\n        shape=(num_particles.value,),\n    )\n    system.num_particles = num_particles.value\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/","title":"System","text":"<p>Class to represent a gravitational system.</p> Source code in <code>grav_sim/system.py</code> <pre><code>class System:\n    \"\"\"\n    Class to represent a gravitational system.\n    \"\"\"\n\n    # Built-in systems\n    BUILT_IN_SYSTEMS = [\n        \"circular_binary_orbit\",\n        \"eccentric_binary_orbit\",\n        \"3d_helix\",\n        \"sun_earth_moon\",\n        \"figure-8\",\n        \"pyth-3-body\",\n        \"solar_system\",\n        \"solar_system_plus\",\n    ]\n\n    # Gravitational constant (AU^3 day^-2 M_sun^-1)\n    G_DEFAULT = 0.000295912208284119496676630\n\n    def __init__(self, c_lib: ctypes.CDLL) -&gt; None:\n        \"\"\"Initialize System object\"\"\"\n        self.c_lib = c_lib\n        self.num_particles = 0\n        self.particle_ids = np.zeros((0,), dtype=np.int32)\n        self.x = np.zeros((0, 3), dtype=np.float64)\n        self.v = np.zeros((0, 3), dtype=np.float64)\n        self.m = np.zeros((0,), dtype=np.float64)\n        self.G = self.G_DEFAULT\n\n    def add(\n        self,\n        x: list | np.ndarray,\n        v: list | np.ndarray,\n        m: float | list | np.ndarray,\n    ) -&gt; None:\n        \"\"\"Add one or multiple particle to the system\n\n        Parameters\n        ----------\n        x : list or np.ndarray\n            Position vector(s) of the object(s)\n        v : list or np.ndarray\n            Velocity vector(s) of the object(s)\n        m : float\n            Mass(es) of the object(s)\n        \"\"\"\n        self.x = np.vstack((self.x, np.array(x, dtype=np.float64)))\n        self.v = np.vstack((self.v, np.array(v, dtype=np.float64)))\n        self.m = np.hstack((self.m, m))\n\n        if isinstance(m, (list, np.ndarray)):\n            num_new_particles = len(m)\n        else:\n            num_new_particles = 1\n\n        max_id = self.particle_ids.max() if len(self.particle_ids) &gt; 0 else -1\n        new_ids = np.arange(max_id + 1, max_id + 1 + num_new_particles, dtype=np.int32)\n        self.particle_ids = np.hstack((self.particle_ids, new_ids))\n        self.num_particles += num_new_particles\n\n    def add_keplerian(\n        self,\n        semi_major_axis: float,\n        eccentricity: float,\n        inclination: float,\n        argument_of_periapsis: float,\n        longitude_of_ascending_node: float,\n        true_anomaly: float,\n        m: float,\n        primary_particle_id: int,\n    ):\n        \"\"\"\n        Add a celestial body to the system using Keplerian elements\n\n        Warning: This method use the G value from the system. Make sure\n                 to set the correct G value before using this method.\n\n        Parameters\n        ----------\n        semi_major_axis : float\n            Semi-major axis\n        eccentricity : float\n            Eccentricity\n        inclination : float\n            Inclination\n        argument_of_periapsis : float\n            Argument of periapsis\n        longitude_of_ascending_node : float\n            Longitude of ascending node\n        true_anomaly : float\n            True anomaly\n        m : float\n            Mass\n        primary_object_index : int\n            Particle id of the primary object\n\n        Raises\n        ------\n        ValueError\n            If particle_id is not found in the system\n        \"\"\"\n\n        primary_particle_idx = np.where(self.particle_ids == primary_particle_id)[0]\n        if len(primary_particle_idx) == 0:\n            raise ValueError(\n                f\"Particle ID {primary_particle_id} not found in the system\"\n            )\n        primary_particle_idx = primary_particle_idx[0]\n\n        x, v = utils.keplerian_to_cartesian(\n            self.c_lib,\n            semi_major_axis=semi_major_axis,\n            eccentricity=eccentricity,\n            inclination=inclination,\n            argument_of_periapsis=argument_of_periapsis,\n            longitude_of_ascending_node=longitude_of_ascending_node,\n            true_anomaly=true_anomaly,\n            total_mass=float(self.m[primary_particle_idx] + m),\n            G=self.G,\n        )\n        self.add(x + self.x[primary_particle_idx], v + self.v[primary_particle_idx], m)\n\n    def remove(\n        self,\n        particle_ids: int | list | np.ndarray,\n    ) -&gt; None:\n        \"\"\"Remove particle(s) from the system\n\n        Parameters\n        ----------\n        particle_ids : int, list or np.ndarray\n            particle_id(s) to remove\n\n        Raises\n        ------\n        TypeError\n            If indices is not an int, list or np.ndarray\n        \"\"\"\n        if isinstance(particle_ids, int):\n            particle_ids_arr = np.array([particle_ids])\n        elif isinstance(particle_ids, list):\n            particle_ids_arr = np.array(particle_ids)\n        elif not isinstance(particle_ids, np.ndarray):\n            raise TypeError(\"indices must be an int, list or np.ndarray\")\n        else:\n            particle_ids_arr = particle_ids\n\n        mask = np.isin(self.particle_ids, particle_ids_arr, invert=True)\n\n        self.particle_ids = self.particle_ids[mask]\n        self.x = self.x[mask]\n        self.v = self.v[mask]\n        self.m = self.m[mask]\n        self.num_particles = len(self.particle_ids)\n\n    def save(\n        self,\n        file_path: Optional[str | Path] = None,\n    ) -&gt; None:\n        \"\"\"Save system to a CSV file\n\n        Parameters\n        ----------\n        file_path : str, optional\n            File path to save the system, by default None\n\n        Note\n        ----\n        This function has the following side effects:\n        - Prints a message f\"System \\\"{self.name}\\\" successfully saved to \\\"{file_path}\\\"\"\n        \"\"\"\n        if file_path is None:\n            file_path = Path(__file__).parent / \"customized_systems.csv\"\n\n        with open(file_path, \"w\", newline=\"\") as file:\n            writer = csv.writer(file)\n\n            # Write header\n            writer.writerow([\"particle_id\", \"m\", \"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\"])\n\n            # Write data\n            for i in range(self.num_particles):\n                writer.writerow(\n                    [\n                        self.particle_ids[i],\n                        self.m[i],\n                        self.x[i, 0],\n                        self.x[i, 1],\n                        self.x[i, 2],\n                        self.v[i, 0],\n                        self.v[i, 1],\n                        self.v[i, 2],\n                    ]\n                )\n\n        print(f'System successfully saved to \"{file_path}\"')\n\n    @staticmethod\n    def load_system(\n        c_lib: ctypes.CDLL,\n        file_path: str | Path,\n    ) -&gt; \"System\":\n        \"\"\"Load system from a CSV file\n\n        Parameters\n        ----------\n        system_name : str\n            Name of the system to load\n        file_path : str\n            File path to load the system from\n\n        Raises\n        ------\n        FileNotFoundError\n            If the file is not found\n        \"\"\"\n        if file_path is not None:\n            if isinstance(file_path, str):\n                file_path = Path(file_path)\n\n            if not file_path.is_file():\n                raise FileNotFoundError(f\"File not found: {file_path}\")\n\n        with open(file_path, \"r\") as file:\n            reader = csv.reader(file)\n            next(reader)  # Skip header\n\n            system = System(c_lib)\n            particle_ids = []\n            for row in reader:\n                system.add(\n                    x=[float(row[2]), float(row[3]), float(row[4])],\n                    v=[float(row[5]), float(row[6]), float(row[7])],\n                    m=float(row[1]),\n                )\n                particle_ids.append(int(row[0]))\n            system.particle_ids = np.array(particle_ids, dtype=np.int32)\n\n        return system\n\n    def center_of_mass_correction(self) -&gt; None:\n        \"\"\"Set center of mass of position and velocity to zero\"\"\"\n        M = np.sum(self.m)\n        x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n        v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n        self.x -= x_cm\n        self.v -= v_cm\n\n    @staticmethod\n    def get_built_in_system(c_lib: ctypes.CDLL, system_name: str) -&gt; \"System\":\n        \"\"\"Get a built-in system from the C library\n\n        Parameters\n        ----------\n        c_lib : ctypes.CDLL\n            C dynamic-link library object\n        system_name : str\n            Name of the built-in system to be loaded.\n\n        Returns\n        -------\n        System\n            A System object with the loaded built-in system data.\n        \"\"\"\n        # if system_name not in System.BUILT_IN_SYSTEMS:\n        #     raise ValueError(\n        #         f\"Unknown system name: {system_name}. Available systems: {System.BUILT_IN_SYSTEMS}\"\n        #     )\n\n        new_system = System(c_lib)\n\n        num_particles = ctypes.c_int32()\n        particle_ids = ctypes.POINTER(ctypes.c_int32)()\n        x = ctypes.POINTER(ctypes.c_double)()\n        v = ctypes.POINTER(ctypes.c_double)()\n        m = ctypes.POINTER(ctypes.c_double)()\n        G = ctypes.c_double()\n        return_value = c_lib.load_built_in_system_python(\n            system_name.encode(\"utf-8\"),\n            ctypes.byref(num_particles),\n            ctypes.byref(particle_ids),\n            ctypes.byref(x),\n            ctypes.byref(v),\n            ctypes.byref(m),\n            ctypes.byref(G),\n        )\n\n        if return_value != 0:\n            raise RuntimeError(\n                f\"Failed to load built-in system '{system_name}' from C library\"\n            )\n\n        new_system.num_particles = num_particles.value\n        new_system.G = G.value\n\n        new_system.particle_ids = np.ctypeslib.as_array(\n            particle_ids, shape=(num_particles.value,)\n        ).copy()\n        new_system.x = np.ctypeslib.as_array(x, shape=(num_particles.value, 3)).copy()\n        new_system.v = np.ctypeslib.as_array(v, shape=(num_particles.value, 3)).copy()\n        new_system.m = np.ctypeslib.as_array(m, shape=(num_particles.value,)).copy()\n\n        c_lib.free_memory_int32(particle_ids)\n        c_lib.free_memory_double(x)\n        c_lib.free_memory_double(v)\n        c_lib.free_memory_double(m)\n\n        return new_system\n\n    def plot_2d_system(\n        self,\n        colors: Optional[list[str]] = None,\n        labels: Optional[list[str]] = None,\n        legend: bool = False,\n        xlabel: str = \"$x$\",\n        ylabel: str = \"$y$\",\n        title: Optional[str] = None,\n        marker: str = \"o\",\n        markersize: int = 6,\n        save_fig: bool = False,\n        save_fig_path: Optional[str | Path] = None,\n    ) -&gt; None:\n        initial_state = np.concatenate(\n            [\n                self.x.flatten(),\n                self.v.flatten(),\n            ]\n        )[np.newaxis, :]\n\n        plotting.plot_2d_trajectory(\n            initial_state,\n            colors,\n            labels,\n            legend,\n            xlabel,\n            ylabel,\n            title,\n            marker,\n            markersize,\n            save_fig,\n            save_fig_path,\n        )\n\n    def plot_3d_system(\n        self,\n        colors: Optional[list[str]] = None,\n        labels: Optional[list[str]] = None,\n        legend: bool = False,\n        xlabel: str = \"$x$\",\n        ylabel: str = \"$y$\",\n        zlabel: str = \"$z$\",\n        title: Optional[str] = None,\n        marker: str = \"o\",\n        markersize: int = 6,\n        save_fig: bool = False,\n        save_fig_path: Optional[str | Path] = None,\n    ) -&gt; None:\n        initial_state = np.concatenate(\n            [\n                self.x.flatten(),\n                self.v.flatten(),\n            ]\n        )[np.newaxis, :]\n\n        plotting.plot_3d_trajectory(\n            initial_state,\n            colors,\n            labels,\n            legend,\n            xlabel,\n            ylabel,\n            zlabel,\n            title,\n            marker,\n            markersize,\n            save_fig,\n            save_fig_path,\n        )\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.__init__","title":"<code>__init__(c_lib)</code>","text":"<p>Initialize System object</p> Source code in <code>grav_sim/system.py</code> <pre><code>def __init__(self, c_lib: ctypes.CDLL) -&gt; None:\n    \"\"\"Initialize System object\"\"\"\n    self.c_lib = c_lib\n    self.num_particles = 0\n    self.particle_ids = np.zeros((0,), dtype=np.int32)\n    self.x = np.zeros((0, 3), dtype=np.float64)\n    self.v = np.zeros((0, 3), dtype=np.float64)\n    self.m = np.zeros((0,), dtype=np.float64)\n    self.G = self.G_DEFAULT\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.add","title":"<code>add(x, v, m)</code>","text":"<p>Add one or multiple particle to the system</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list or ndarray</code> <p>Position vector(s) of the object(s)</p> required <code>v</code> <code>list or ndarray</code> <p>Velocity vector(s) of the object(s)</p> required <code>m</code> <code>float</code> <p>Mass(es) of the object(s)</p> required Source code in <code>grav_sim/system.py</code> <pre><code>def add(\n    self,\n    x: list | np.ndarray,\n    v: list | np.ndarray,\n    m: float | list | np.ndarray,\n) -&gt; None:\n    \"\"\"Add one or multiple particle to the system\n\n    Parameters\n    ----------\n    x : list or np.ndarray\n        Position vector(s) of the object(s)\n    v : list or np.ndarray\n        Velocity vector(s) of the object(s)\n    m : float\n        Mass(es) of the object(s)\n    \"\"\"\n    self.x = np.vstack((self.x, np.array(x, dtype=np.float64)))\n    self.v = np.vstack((self.v, np.array(v, dtype=np.float64)))\n    self.m = np.hstack((self.m, m))\n\n    if isinstance(m, (list, np.ndarray)):\n        num_new_particles = len(m)\n    else:\n        num_new_particles = 1\n\n    max_id = self.particle_ids.max() if len(self.particle_ids) &gt; 0 else -1\n    new_ids = np.arange(max_id + 1, max_id + 1 + num_new_particles, dtype=np.int32)\n    self.particle_ids = np.hstack((self.particle_ids, new_ids))\n    self.num_particles += num_new_particles\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.add_keplerian","title":"<code>add_keplerian(semi_major_axis, eccentricity, inclination, argument_of_periapsis, longitude_of_ascending_node, true_anomaly, m, primary_particle_id)</code>","text":"<p>Add a celestial body to the system using Keplerian elements</p> <p>Warning: This method use the G value from the system. Make sure          to set the correct G value before using this method.</p> <p>Parameters:</p> Name Type Description Default <code>semi_major_axis</code> <code>float</code> <p>Semi-major axis</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity</p> required <code>inclination</code> <code>float</code> <p>Inclination</p> required <code>argument_of_periapsis</code> <code>float</code> <p>Argument of periapsis</p> required <code>longitude_of_ascending_node</code> <code>float</code> <p>Longitude of ascending node</p> required <code>true_anomaly</code> <code>float</code> <p>True anomaly</p> required <code>m</code> <code>float</code> <p>Mass</p> required <code>primary_object_index</code> <code>int</code> <p>Particle id of the primary object</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If particle_id is not found in the system</p> Source code in <code>grav_sim/system.py</code> <pre><code>def add_keplerian(\n    self,\n    semi_major_axis: float,\n    eccentricity: float,\n    inclination: float,\n    argument_of_periapsis: float,\n    longitude_of_ascending_node: float,\n    true_anomaly: float,\n    m: float,\n    primary_particle_id: int,\n):\n    \"\"\"\n    Add a celestial body to the system using Keplerian elements\n\n    Warning: This method use the G value from the system. Make sure\n             to set the correct G value before using this method.\n\n    Parameters\n    ----------\n    semi_major_axis : float\n        Semi-major axis\n    eccentricity : float\n        Eccentricity\n    inclination : float\n        Inclination\n    argument_of_periapsis : float\n        Argument of periapsis\n    longitude_of_ascending_node : float\n        Longitude of ascending node\n    true_anomaly : float\n        True anomaly\n    m : float\n        Mass\n    primary_object_index : int\n        Particle id of the primary object\n\n    Raises\n    ------\n    ValueError\n        If particle_id is not found in the system\n    \"\"\"\n\n    primary_particle_idx = np.where(self.particle_ids == primary_particle_id)[0]\n    if len(primary_particle_idx) == 0:\n        raise ValueError(\n            f\"Particle ID {primary_particle_id} not found in the system\"\n        )\n    primary_particle_idx = primary_particle_idx[0]\n\n    x, v = utils.keplerian_to_cartesian(\n        self.c_lib,\n        semi_major_axis=semi_major_axis,\n        eccentricity=eccentricity,\n        inclination=inclination,\n        argument_of_periapsis=argument_of_periapsis,\n        longitude_of_ascending_node=longitude_of_ascending_node,\n        true_anomaly=true_anomaly,\n        total_mass=float(self.m[primary_particle_idx] + m),\n        G=self.G,\n    )\n    self.add(x + self.x[primary_particle_idx], v + self.v[primary_particle_idx], m)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.center_of_mass_correction","title":"<code>center_of_mass_correction()</code>","text":"<p>Set center of mass of position and velocity to zero</p> Source code in <code>grav_sim/system.py</code> <pre><code>def center_of_mass_correction(self) -&gt; None:\n    \"\"\"Set center of mass of position and velocity to zero\"\"\"\n    M = np.sum(self.m)\n    x_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.x) / M\n    v_cm = np.einsum(\"i,ij-&gt;j\", self.m, self.v) / M\n\n    self.x -= x_cm\n    self.v -= v_cm\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.get_built_in_system","title":"<code>get_built_in_system(c_lib, system_name)</code>  <code>staticmethod</code>","text":"<p>Get a built-in system from the C library</p> <p>Parameters:</p> Name Type Description Default <code>c_lib</code> <code>CDLL</code> <p>C dynamic-link library object</p> required <code>system_name</code> <code>str</code> <p>Name of the built-in system to be loaded.</p> required <p>Returns:</p> Type Description <code>System</code> <p>A System object with the loaded built-in system data.</p> Source code in <code>grav_sim/system.py</code> <pre><code>@staticmethod\ndef get_built_in_system(c_lib: ctypes.CDLL, system_name: str) -&gt; \"System\":\n    \"\"\"Get a built-in system from the C library\n\n    Parameters\n    ----------\n    c_lib : ctypes.CDLL\n        C dynamic-link library object\n    system_name : str\n        Name of the built-in system to be loaded.\n\n    Returns\n    -------\n    System\n        A System object with the loaded built-in system data.\n    \"\"\"\n    # if system_name not in System.BUILT_IN_SYSTEMS:\n    #     raise ValueError(\n    #         f\"Unknown system name: {system_name}. Available systems: {System.BUILT_IN_SYSTEMS}\"\n    #     )\n\n    new_system = System(c_lib)\n\n    num_particles = ctypes.c_int32()\n    particle_ids = ctypes.POINTER(ctypes.c_int32)()\n    x = ctypes.POINTER(ctypes.c_double)()\n    v = ctypes.POINTER(ctypes.c_double)()\n    m = ctypes.POINTER(ctypes.c_double)()\n    G = ctypes.c_double()\n    return_value = c_lib.load_built_in_system_python(\n        system_name.encode(\"utf-8\"),\n        ctypes.byref(num_particles),\n        ctypes.byref(particle_ids),\n        ctypes.byref(x),\n        ctypes.byref(v),\n        ctypes.byref(m),\n        ctypes.byref(G),\n    )\n\n    if return_value != 0:\n        raise RuntimeError(\n            f\"Failed to load built-in system '{system_name}' from C library\"\n        )\n\n    new_system.num_particles = num_particles.value\n    new_system.G = G.value\n\n    new_system.particle_ids = np.ctypeslib.as_array(\n        particle_ids, shape=(num_particles.value,)\n    ).copy()\n    new_system.x = np.ctypeslib.as_array(x, shape=(num_particles.value, 3)).copy()\n    new_system.v = np.ctypeslib.as_array(v, shape=(num_particles.value, 3)).copy()\n    new_system.m = np.ctypeslib.as_array(m, shape=(num_particles.value,)).copy()\n\n    c_lib.free_memory_int32(particle_ids)\n    c_lib.free_memory_double(x)\n    c_lib.free_memory_double(v)\n    c_lib.free_memory_double(m)\n\n    return new_system\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.load_system","title":"<code>load_system(c_lib, file_path)</code>  <code>staticmethod</code>","text":"<p>Load system from a CSV file</p> <p>Parameters:</p> Name Type Description Default <code>system_name</code> <code>str</code> <p>Name of the system to load</p> required <code>file_path</code> <code>str</code> <p>File path to load the system from</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found</p> Source code in <code>grav_sim/system.py</code> <pre><code>@staticmethod\ndef load_system(\n    c_lib: ctypes.CDLL,\n    file_path: str | Path,\n) -&gt; \"System\":\n    \"\"\"Load system from a CSV file\n\n    Parameters\n    ----------\n    system_name : str\n        Name of the system to load\n    file_path : str\n        File path to load the system from\n\n    Raises\n    ------\n    FileNotFoundError\n        If the file is not found\n    \"\"\"\n    if file_path is not None:\n        if isinstance(file_path, str):\n            file_path = Path(file_path)\n\n        if not file_path.is_file():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    with open(file_path, \"r\") as file:\n        reader = csv.reader(file)\n        next(reader)  # Skip header\n\n        system = System(c_lib)\n        particle_ids = []\n        for row in reader:\n            system.add(\n                x=[float(row[2]), float(row[3]), float(row[4])],\n                v=[float(row[5]), float(row[6]), float(row[7])],\n                m=float(row[1]),\n            )\n            particle_ids.append(int(row[0]))\n        system.particle_ids = np.array(particle_ids, dtype=np.int32)\n\n    return system\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.remove","title":"<code>remove(particle_ids)</code>","text":"<p>Remove particle(s) from the system</p> <p>Parameters:</p> Name Type Description Default <code>particle_ids</code> <code>(int, list or ndarray)</code> <p>particle_id(s) to remove</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If indices is not an int, list or np.ndarray</p> Source code in <code>grav_sim/system.py</code> <pre><code>def remove(\n    self,\n    particle_ids: int | list | np.ndarray,\n) -&gt; None:\n    \"\"\"Remove particle(s) from the system\n\n    Parameters\n    ----------\n    particle_ids : int, list or np.ndarray\n        particle_id(s) to remove\n\n    Raises\n    ------\n    TypeError\n        If indices is not an int, list or np.ndarray\n    \"\"\"\n    if isinstance(particle_ids, int):\n        particle_ids_arr = np.array([particle_ids])\n    elif isinstance(particle_ids, list):\n        particle_ids_arr = np.array(particle_ids)\n    elif not isinstance(particle_ids, np.ndarray):\n        raise TypeError(\"indices must be an int, list or np.ndarray\")\n    else:\n        particle_ids_arr = particle_ids\n\n    mask = np.isin(self.particle_ids, particle_ids_arr, invert=True)\n\n    self.particle_ids = self.particle_ids[mask]\n    self.x = self.x[mask]\n    self.v = self.v[mask]\n    self.m = self.m[mask]\n    self.num_particles = len(self.particle_ids)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/System/#grav_sim.system.System.save","title":"<code>save(file_path=None)</code>","text":"<p>Save system to a CSV file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File path to save the system, by default None</p> <code>None</code> Note <p>This function has the following side effects: - Prints a message f\"System \"{self.name}\" successfully saved to \"{file_path}\"\"</p> Source code in <code>grav_sim/system.py</code> <pre><code>def save(\n    self,\n    file_path: Optional[str | Path] = None,\n) -&gt; None:\n    \"\"\"Save system to a CSV file\n\n    Parameters\n    ----------\n    file_path : str, optional\n        File path to save the system, by default None\n\n    Note\n    ----\n    This function has the following side effects:\n    - Prints a message f\"System \\\"{self.name}\\\" successfully saved to \\\"{file_path}\\\"\"\n    \"\"\"\n    if file_path is None:\n        file_path = Path(__file__).parent / \"customized_systems.csv\"\n\n    with open(file_path, \"w\", newline=\"\") as file:\n        writer = csv.writer(file)\n\n        # Write header\n        writer.writerow([\"particle_id\", \"m\", \"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\"])\n\n        # Write data\n        for i in range(self.num_particles):\n            writer.writerow(\n                [\n                    self.particle_ids[i],\n                    self.m[i],\n                    self.x[i, 0],\n                    self.x[i, 1],\n                    self.x[i, 2],\n                    self.v[i, 0],\n                    self.v[i, 1],\n                    self.v[i, 2],\n                ]\n            )\n\n    print(f'System successfully saved to \"{file_path}\"')\n</code></pre>"},{"location":"docs/documentations/PythonAPI/parameters/","title":"Parameters","text":""},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.AccelerationParam","title":"<code>AccelerationParam</code>","text":"<p>Acceleration parameters for gravity simulation</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>Acceleration method</p> <code>softening_length</code> <code>float</code> <p>Softening length for acceleration</p> <code>pm_grid_size</code> <code>int</code> <p>Grid size for Particle Mesh method</p> <code>opening_angle</code> <code>float</code> <p>Opening angle for Barnes-Hut method</p> <code>max_num_particles_per_leaf</code> <code>int</code> <p>Maximum number of particles per leaf for Barnes-Hut method</p> Source code in <code>grav_sim/parameters.py</code> <pre><code>class AccelerationParam:\n    \"\"\"Acceleration parameters for gravity simulation\n\n    Attributes\n    ----------\n    method : str\n        Acceleration method\n    softening_length : float\n        Softening length for acceleration\n    pm_grid_size : int\n        Grid size for Particle Mesh method\n    opening_angle : float\n        Opening angle for Barnes-Hut method\n    max_num_particles_per_leaf : int\n        Maximum number of particles per leaf for Barnes-Hut method\n    \"\"\"\n\n    AVAILABLE_ACCELERATION_METHODS = [\n        \"pairwise\",\n        \"massless\",\n        \"barnes_hut\",\n        \"particle_mesh\",\n    ]\n    ACCELERATION_METHODS_TO_ENCODING = {\n        \"pairwise\": 1,\n        \"massless\": 2,\n        \"barnes_hut\": 3,\n        \"particle_mesh\": 4,\n    }\n    ACCELERATION_ENCODING_TO_METHODS = {\n        v: k for k, v in ACCELERATION_METHODS_TO_ENCODING.items()\n    }\n\n    def __init__(self) -&gt; None:\n        self.method = \"pairwise\"\n        self.opening_angle = 1.0\n        self.softening_length = 0.0\n        self.pm_grid_size = 128\n        self.max_num_particles_per_leaf = 1\n\n    @property\n    def method(self) -&gt; str:\n        \"\"\"Get the acceleration method\"\"\"\n        return self.ACCELERATION_ENCODING_TO_METHODS[self._method]\n\n    @method.setter\n    def method(self, value: str) -&gt; None:\n        \"\"\"Set the acceleration method\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_ACCELERATION_METHODS:\n            raise ValueError(\n                f\"Invalid acceleration method: {value}. Available methods: {self.AVAILABLE_ACCELERATION_METHODS}\"\n            )\n        self._method: int = self.ACCELERATION_METHODS_TO_ENCODING[value]\n\n    @property\n    def opening_angle(self) -&gt; float:\n        \"\"\"Get the opening angle for Barnes-Hut method\"\"\"\n        return self._opening_angle\n\n    @opening_angle.setter\n    def opening_angle(self, value: float) -&gt; None:\n        \"\"\"Set the opening angle for Barnes-Hut method\"\"\"\n        value = float(value)\n        if value &lt;= 0:\n            raise ValueError(f\"Invalid opening angle: {value}. Must be positive.\")\n        self._opening_angle = value\n\n    @property\n    def softening_length(self) -&gt; float:\n        \"\"\"Get the softening length\"\"\"\n        return self._softening_length\n\n    @softening_length.setter\n    def softening_length(self, value: float) -&gt; None:\n        \"\"\"Set the softening length\"\"\"\n        value = float(value)\n        if value &lt; 0:\n            raise ValueError(\n                f\"Invalid softening length: {value}. Must be non-negative.\"\n            )\n        self._softening_length = value\n\n    @property\n    def pm_grid_size(self) -&gt; int:\n        \"\"\"Get the grid size for Particle Mesh method\"\"\"\n        return self._pm_grid_size\n\n    @pm_grid_size.setter\n    def pm_grid_size(self, value: int) -&gt; None:\n        \"\"\"Set the grid size for Particle Mesh method\"\"\"\n        value = int(value)\n        if value &lt;= 0:\n            raise ValueError(f\"Invalid grid size: {value}. Must be positive.\")\n        self._pm_grid_size = value\n\n    @property\n    def max_num_particles_per_leaf(self) -&gt; int:\n        \"\"\"Get the maximum number of particles per leaf for Barnes-Hut method\"\"\"\n        return self._max_num_particles_per_leaf\n\n    @max_num_particles_per_leaf.setter\n    def max_num_particles_per_leaf(self, value: int) -&gt; None:\n        \"\"\"Set the maximum number of particles per leaf for Barnes-Hut method\"\"\"\n        value = int(value)\n        if value &lt;= 0:\n            raise ValueError(\n                f\"Invalid maximum number of particles per leaf: {value}. Must be positive.\"\n            )\n        self._max_num_particles_per_leaf = value\n</code></pre>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.AccelerationParam.max_num_particles_per_leaf","title":"<code>max_num_particles_per_leaf</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum number of particles per leaf for Barnes-Hut method</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.AccelerationParam.method","title":"<code>method</code>  <code>property</code> <code>writable</code>","text":"<p>Get the acceleration method</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.AccelerationParam.opening_angle","title":"<code>opening_angle</code>  <code>property</code> <code>writable</code>","text":"<p>Get the opening angle for Barnes-Hut method</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.AccelerationParam.pm_grid_size","title":"<code>pm_grid_size</code>  <code>property</code> <code>writable</code>","text":"<p>Get the grid size for Particle Mesh method</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.AccelerationParam.softening_length","title":"<code>softening_length</code>  <code>property</code> <code>writable</code>","text":"<p>Get the softening length</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.IntegratorParam","title":"<code>IntegratorParam</code>","text":"<p>Integrator parameters for gravity simulation</p> <p>Attributes:</p> Name Type Description <code>integrator</code> <code>str</code> <p>Integrator</p> <code>dt</code> <code>float</code> <p>Time step</p> <code>tolerance</code> <code>float</code> <p>Tolerance for adaptive step size integrators</p> <code>initial_dt</code> <code>float</code> <p>Initial time step for adaptive step size integrators</p> <code>whfast_remove_invalid_particles</code> <code>bool</code> <p>Flag to indicate whether to remove invalid particles in WHFast integrator</p> Source code in <code>grav_sim/parameters.py</code> <pre><code>class IntegratorParam:\n    \"\"\"Integrator parameters for gravity simulation\n\n    Attributes\n    ----------\n    integrator : str\n        Integrator\n    dt : float\n        Time step\n    tolerance : float\n        Tolerance for adaptive step size integrators\n    initial_dt : float\n        Initial time step for adaptive step size integrators\n    whfast_remove_invalid_particles : bool\n        Flag to indicate whether to remove invalid particles in WHFast integrator\n    \"\"\"\n\n    AVAILABLE_INTEGRATORS = [\n        \"euler\",\n        \"euler_cromer\",\n        \"rk4\",\n        \"leapfrog\",\n        \"rkf45\",\n        \"dopri\",\n        \"dverk\",\n        \"rkf78\",\n        \"ias15\",\n        \"whfast\",\n    ]\n    FIXED_STEP_SIZE_INTEGRATORS = [\"euler\", \"euler_cromer\", \"rk4\", \"leapfrog\", \"whfast\"]\n    ADAPTIVE_STEP_SIZE_INTEGRATORS = [\"rkf45\", \"dopri\", \"dverk\", \"rkf78\", \"ias15\"]\n\n    INTEGRATOR_TO_ENCODING = {\n        \"euler\": 1,\n        \"euler_cromer\": 2,\n        \"rk4\": 3,\n        \"leapfrog\": 4,\n        \"rkf45\": 5,\n        \"dopri\": 6,\n        \"dverk\": 7,\n        \"rkf78\": 8,\n        \"ias15\": 9,\n        \"whfast\": 10,\n    }\n    ENCODING_TO_INTEGRATORS = {k: v for v, k in INTEGRATOR_TO_ENCODING.items()}\n\n    # Recommended settings for built-in systems with IAS15 integrator\n    RECOMMENDED_IAS15_SETTINGS_BUILT_IN_SYSTEMS = {\n        # \"template\": [\"tf\", \"tf unit\", \"tolerance\", \"storing_freq\"],\n        \"circular_binary_orbit\": [50.0, \"days\", 1e-9, 1],\n        \"eccentric_binary_orbit\": [2.6, \"years\", 1e-9, 1],\n        \"3d_helix\": [20.0, \"days\", 1e-9, 1],\n        \"sun_earth_moon\": [1.0, \"years\", 1e-9, 1],\n        \"figure-8\": [20.0, \"days\", 1e-9, 1],\n        \"pyth-3-body\": [70.0, \"days\", 1e-9, 1],\n        \"solar_system\": [200.0, \"years\", 1e-9, 1],\n        \"solar_system_plus\": [250.0, \"years\", 1e-9, 1],\n    }\n\n    def __init__(self) -&gt; None:\n        self.integrator = \"euler\"\n        self.dt = -1.0\n        self.tolerance = -1.0\n        self.initial_dt = -1.0\n        self.whfast_remove_invalid_particles = True\n\n    @property\n    def integrator(self) -&gt; str:\n        \"\"\"Get the integrator\"\"\"\n        return self.ENCODING_TO_INTEGRATORS[self._integrator]\n\n    @integrator.setter\n    def integrator(self, value: str) -&gt; None:\n        \"\"\"Set the integrator\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_INTEGRATORS:\n            raise ValueError(\n                f\"Invalid integrator: {value}. Available integrators: {self.AVAILABLE_INTEGRATORS}\"\n            )\n        self._integrator: int = self.INTEGRATOR_TO_ENCODING[value]\n\n    @property\n    def dt(self) -&gt; float:\n        \"\"\"Get the time step size\"\"\"\n        return self._dt\n\n    @dt.setter\n    def dt(self, value: float) -&gt; None:\n        \"\"\"Set the time step size\"\"\"\n        self._dt = float(value)\n\n    @property\n    def tolerance(self) -&gt; float:\n        \"\"\"Get the tolerance for adaptive step size integrators\"\"\"\n        return self._tolerance\n\n    @tolerance.setter\n    def tolerance(self, value: float) -&gt; None:\n        \"\"\"Set the tolerance for adaptive step size integrators\"\"\"\n        self._tolerance = float(value)\n\n    @property\n    def initial_dt(self) -&gt; float:\n        \"\"\"Get the initial time step size for adaptive step size integrators\"\"\"\n        return self._initial_dt\n\n    @initial_dt.setter\n    def initial_dt(self, value: float) -&gt; None:\n        \"\"\"Set the initial time step size for adaptive step size integrators\"\"\"\n        self._initial_dt = float(value)\n\n    @property\n    def whfast_remove_invalid_particles(self) -&gt; bool:\n        \"\"\"Get the flag for removing invalid particles in WHFast integrator\"\"\"\n        return self._whfast_remove_invalid_particles\n\n    @whfast_remove_invalid_particles.setter\n    def whfast_remove_invalid_particles(self, value: bool) -&gt; None:\n        \"\"\"Set the flag for removing invalid particles in WHFast integrator\"\"\"\n        self._whfast_remove_invalid_particles = bool(value)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.IntegratorParam.dt","title":"<code>dt</code>  <code>property</code> <code>writable</code>","text":"<p>Get the time step size</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.IntegratorParam.initial_dt","title":"<code>initial_dt</code>  <code>property</code> <code>writable</code>","text":"<p>Get the initial time step size for adaptive step size integrators</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.IntegratorParam.integrator","title":"<code>integrator</code>  <code>property</code> <code>writable</code>","text":"<p>Get the integrator</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.IntegratorParam.tolerance","title":"<code>tolerance</code>  <code>property</code> <code>writable</code>","text":"<p>Get the tolerance for adaptive step size integrators</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.IntegratorParam.whfast_remove_invalid_particles","title":"<code>whfast_remove_invalid_particles</code>  <code>property</code> <code>writable</code>","text":"<p>Get the flag for removing invalid particles in WHFast integrator</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam","title":"<code>OutputParam</code>","text":"<p>Output parameters for gravity simulation</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>Output method</p> <code>output_dir</code> <code>str</code> <p>Output directory</p> <code>output_initial</code> <code>bool</code> <p>Flag to indicate whether to output initial state</p> <code>output_interval</code> <code>float</code> <p>Output interval</p> <code>coordinate_output_dtype</code> <code>str</code> <p>Data type for coordinate output</p> <code>velocity_output_dtype</code> <code>str</code> <p>Data type for velocity output</p> <code>mass_output_dtype</code> <code>str</code> <p>Data type for mass output</p> Source code in <code>grav_sim/parameters.py</code> <pre><code>class OutputParam:\n    \"\"\"Output parameters for gravity simulation\n\n    Attributes\n    ----------\n    method : str\n        Output method\n    output_dir : str\n        Output directory\n    output_initial : bool\n        Flag to indicate whether to output initial state\n    output_interval : float\n        Output interval\n    coordinate_output_dtype : str\n        Data type for coordinate output\n    velocity_output_dtype : str\n        Data type for velocity output\n    mass_output_dtype : str\n        Data type for mass output\n    \"\"\"\n\n    AVAILABLE_OUTPUT_METHODS = [\"disabled\", \"csv\", \"hdf5\"]\n    AVAILABLE_OUTPUT_DTYPE = [\"float\", \"double\"]\n\n    OUTPUT_METHODS_TO_ENCODING = {\n        \"disabled\": 1,\n        \"csv\": 2,\n        \"hdf5\": 3,\n    }\n    OUTPUT_ENCODING_TO_METHODS = {v: k for k, v in OUTPUT_METHODS_TO_ENCODING.items()}\n\n    OUTPUT_DTYPE_TO_ENCODING = {\n        \"float\": 1,\n        \"double\": 2,\n    }\n    OUTPUT_ENCODING_TO_DTYPE = {v: k for k, v in OUTPUT_DTYPE_TO_ENCODING.items()}\n\n    def __init__(self) -&gt; None:\n        self.method = \"disabled\"\n        self.output_dir = \"tmp/\"\n        self.output_initial = True\n        self.output_interval = 1.0\n        self.coordinate_output_dtype = \"double\"\n        self.velocity_output_dtype = \"double\"\n        self.mass_output_dtype = \"double\"\n\n    @property\n    def method(self) -&gt; str:\n        \"\"\"Get the output method\"\"\"\n        return self.OUTPUT_ENCODING_TO_METHODS[self._method]\n\n    @method.setter\n    def method(self, value: str) -&gt; None:\n        \"\"\"Set the output method\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_OUTPUT_METHODS:\n            raise ValueError(\n                f\"Invalid output method: {value}. Available methods: {self.AVAILABLE_OUTPUT_METHODS}\"\n            )\n        self._method: int = self.OUTPUT_METHODS_TO_ENCODING[value]\n\n    @property\n    def output_dir(self) -&gt; str:\n        \"\"\"Get the output directory\"\"\"\n        return self._output_dir\n\n    @output_dir.setter\n    def output_dir(self, value: str) -&gt; None:\n        \"\"\"Set the output directory\"\"\"\n        value = str(Path(value).resolve())\n        if not value.endswith(\"/\"):\n            value += \"/\"\n        self._output_dir = value\n\n    @property\n    def output_initial(self) -&gt; bool:\n        \"\"\"Get the flag for outputting initial state\"\"\"\n        return self._output_initial\n\n    @output_initial.setter\n    def output_initial(self, value: bool) -&gt; None:\n        \"\"\"Set the flag for outputting initial state\"\"\"\n        self._output_initial = bool(value)\n\n    @property\n    def output_interval(self) -&gt; float:\n        \"\"\"Get the output interval\"\"\"\n        return self._output_interval\n\n    @output_interval.setter\n    def output_interval(self, value: float) -&gt; None:\n        \"\"\"Set the output interval\"\"\"\n        self._output_interval = float(value)\n\n    @property\n    def coordinate_output_dtype(self) -&gt; str:\n        \"\"\"Get the data type for coordinate output\"\"\"\n        return self.OUTPUT_ENCODING_TO_DTYPE[self._coordinate_output_dtype]\n\n    @coordinate_output_dtype.setter\n    def coordinate_output_dtype(self, value: str) -&gt; None:\n        \"\"\"Set the data type for coordinate output\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_OUTPUT_DTYPE:\n            raise ValueError(\n                f\"Invalid coordinate output data type: {value}. Available types: {self.AVAILABLE_OUTPUT_DTYPE}\"\n            )\n        self._coordinate_output_dtype: int = self.OUTPUT_DTYPE_TO_ENCODING[value]\n\n    @property\n    def velocity_output_dtype(self) -&gt; str:\n        \"\"\"Get the data type for velocity output\"\"\"\n        return self.OUTPUT_ENCODING_TO_DTYPE[self._velocity_output_dtype]\n\n    @velocity_output_dtype.setter\n    def velocity_output_dtype(self, value: str) -&gt; None:\n        \"\"\"Set the data type for velocity output\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_OUTPUT_DTYPE:\n            raise ValueError(\n                f\"Invalid velocity output data type: {value}. Available types: {self.AVAILABLE_OUTPUT_DTYPE}\"\n            )\n        self._velocity_output_dtype: int = self.OUTPUT_DTYPE_TO_ENCODING[value]\n\n    @property\n    def mass_output_dtype(self) -&gt; str:\n        \"\"\"Get the data type for mass output\"\"\"\n        return self.OUTPUT_ENCODING_TO_DTYPE[self._mass_output_dtype]\n\n    @mass_output_dtype.setter\n    def mass_output_dtype(self, value: str) -&gt; None:\n        \"\"\"Set the data type for mass output\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_OUTPUT_DTYPE:\n            raise ValueError(\n                f\"Invalid mass output data type: {value}. Available types: {self.AVAILABLE_OUTPUT_DTYPE}\"\n            )\n        self._mass_output_dtype: int = self.OUTPUT_DTYPE_TO_ENCODING[value]\n</code></pre>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.coordinate_output_dtype","title":"<code>coordinate_output_dtype</code>  <code>property</code> <code>writable</code>","text":"<p>Get the data type for coordinate output</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.mass_output_dtype","title":"<code>mass_output_dtype</code>  <code>property</code> <code>writable</code>","text":"<p>Get the data type for mass output</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.method","title":"<code>method</code>  <code>property</code> <code>writable</code>","text":"<p>Get the output method</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.output_dir","title":"<code>output_dir</code>  <code>property</code> <code>writable</code>","text":"<p>Get the output directory</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.output_initial","title":"<code>output_initial</code>  <code>property</code> <code>writable</code>","text":"<p>Get the flag for outputting initial state</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.output_interval","title":"<code>output_interval</code>  <code>property</code> <code>writable</code>","text":"<p>Get the output interval</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.OutputParam.velocity_output_dtype","title":"<code>velocity_output_dtype</code>  <code>property</code> <code>writable</code>","text":"<p>Get the data type for velocity output</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.Settings","title":"<code>Settings</code>","text":"<p>Settings for gravity simulation</p> <p>Attributes:</p> Name Type Description <code>verbose</code> <code>str</code> <p>Verbosity level</p> <code>enable_progress_bar</code> <code>bool</code> <p>Flag to enable progress bar</p> Source code in <code>grav_sim/parameters.py</code> <pre><code>class Settings:\n    \"\"\"Settings for gravity simulation\n\n    Attributes\n    ----------\n    verbose : str\n        Verbosity level\n    enable_progress_bar : bool\n        Flag to enable progress bar\n    \"\"\"\n\n    AVAILABLE_VERBOSITY_LEVELS = [\"ignore_all\", \"ignore_info\", \"normal\", \"verbose\"]\n    VERBOSITY_TO_ENCODING = {\n        \"ignore_all\": 0,\n        \"ignore_info\": 1,\n        \"normal\": 2,\n        \"verbose\": 3,\n    }\n    ENCODING_TO_VERBOSITY = {v: k for k, v in VERBOSITY_TO_ENCODING.items()}\n\n    def __init__(self) -&gt; None:\n        self.verbose = \"normal\"\n        self.enable_progress_bar = True\n\n    @property\n    def verbose(self) -&gt; str:\n        \"\"\"Get the verbosity level\"\"\"\n        return self.ENCODING_TO_VERBOSITY[self._verbose]\n\n    @verbose.setter\n    def verbose(self, value: str) -&gt; None:\n        \"\"\"Set the verbosity level\"\"\"\n        value = value.lower().strip()\n        if value not in self.AVAILABLE_VERBOSITY_LEVELS:\n            raise ValueError(\n                f\"Invalid verbosity level: {value}. Available levels: {self.AVAILABLE_VERBOSITY_LEVELS}\"\n            )\n        self._verbose: int = self.VERBOSITY_TO_ENCODING[value]\n\n    @property\n    def enable_progress_bar(self) -&gt; bool:\n        \"\"\"Get the flag for enabling progress bar\"\"\"\n        return self._enable_progress_bar\n\n    @enable_progress_bar.setter\n    def enable_progress_bar(self, value: bool) -&gt; None:\n        \"\"\"Set the flag for enabling progress bar\"\"\"\n        self._enable_progress_bar = bool(value)\n</code></pre>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.Settings.enable_progress_bar","title":"<code>enable_progress_bar</code>  <code>property</code> <code>writable</code>","text":"<p>Get the flag for enabling progress bar</p>"},{"location":"docs/documentations/PythonAPI/parameters/#grav_sim.parameters.Settings.verbose","title":"<code>verbose</code>  <code>property</code> <code>writable</code>","text":"<p>Get the verbosity level</p>"},{"location":"docs/documentations/PythonAPI/plotting/","title":"Plotting","text":"<p>Plotting module for the grav_sim package.</p>"},{"location":"docs/documentations/PythonAPI/plotting/#grav_sim.plotting.plot_2d_trajectory","title":"<code>plot_2d_trajectory(sol_state, colors=None, labels=None, legend=False, xlabel='$x$', ylabel='$y$', title=None, marker='o', markersize=6, save_fig=False, save_fig_path=None)</code>","text":"<p>Plot 2D trajectory of objects</p> <p>Parameters:</p> Name Type Description Default <code>sol_state</code> <code>ndarray</code> <p>Solution state of the system</p> required <code>colors</code> <code>Optional[list[str]]</code> <p>Colors of the trajectories, by default None</p> <code>None</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels of the objects, used for legend, by default None</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Flag to check whether to show legend, by default False</p> <code>False</code> <code>xlabel</code> <code>str</code> <p>Label of x-axis, by default \"\\(x\\) (AU)\"</p> <code>'$x$'</code> <code>ylabel</code> <code>str</code> <p>Label of y-axis, by default \"\\(y\\) (AU)\"</p> <code>'$y$'</code> <code>marker</code> <code>str</code> <p>Marker for the last position, by default \"o\"</p> <code>'o'</code> <code>markersize</code> <code>int</code> <p>Marker size for the last position, by default 6</p> <code>6</code> <code>save_fig</code> <code>bool</code> <p>Flag to check whether to save the figure, by default False</p> <code>False</code> <code>save_fig_path</code> <code>Optional[str]</code> <p>Path to save the figure, by default None</p> <code>None</code> Source code in <code>grav_sim/plotting.py</code> <pre><code>def plot_2d_trajectory(\n    sol_state: np.ndarray,\n    colors: Optional[list[str]] = None,\n    labels: Optional[list[str]] = None,\n    legend: bool = False,\n    xlabel: str = \"$x$\",\n    ylabel: str = \"$y$\",\n    title: Optional[str] = None,\n    marker: str = \"o\",\n    markersize: int = 6,\n    save_fig: bool = False,\n    save_fig_path: Optional[str | Path] = None,\n) -&gt; None:\n    \"\"\"Plot 2D trajectory of objects\n\n    Parameters\n    ----------\n    sol_state : np.ndarray\n        Solution state of the system\n    colors : Optional[list[str]], optional\n        Colors of the trajectories, by default None\n    labels : Optional[list[str]], optional\n        Labels of the objects, used for legend, by default None\n    legend : bool, optional\n        Flag to check whether to show legend, by default False\n    xlabel : str, optional\n        Label of x-axis, by default \"$x$ (AU)\"\n    ylabel : str, optional\n        Label of y-axis, by default \"$y$ (AU)\"\n    marker : str, optional\n        Marker for the last position, by default \"o\"\n    markersize : int, optional\n        Marker size for the last position, by default 6\n    save_fig : bool, optional\n        Flag to check whether to save the figure, by default False\n    save_fig_path : Optional[str], optional\n        Path to save the figure, by default None\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect=\"equal\")\n\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n\n    for i in range(sol_state.shape[1]):\n        if colors is not None:\n            colors_i = colors[i]\n        else:\n            colors_i = None\n\n        if labels is not None:\n            labels_i = labels[i]\n        else:\n            labels_i = None\n\n        traj = ax.plot(\n            sol_state[:, i, 1],\n            sol_state[:, i, 2],\n            color=colors_i,\n        )\n        # Plot the last position with marker\n        ax.plot(\n            sol_state[-1, i, 1],\n            sol_state[-1, i, 2],\n            color=traj[0].get_color(),\n            label=labels_i,\n            marker=marker,\n            markersize=markersize,\n        )\n\n    if title is not None:\n        ax.set_title(title)\n\n    if legend:\n        fig.legend(loc=\"center right\", borderaxespad=0.2)\n        fig.tight_layout()\n\n    if save_fig:\n        plt.savefig(save_fig_path, dpi=300)\n    else:\n        plt.show()\n    plt.close(\"all\")\n</code></pre>"},{"location":"docs/documentations/PythonAPI/plotting/#grav_sim.plotting.plot_3d_trajectory","title":"<code>plot_3d_trajectory(sol_state, colors=None, labels=None, legend=False, xlabel='$x$', ylabel='$y$', zlabel='$z$', title=None, marker='o', markersize=6, save_fig=False, save_fig_path=None)</code>","text":"<p>Plot 3D trajectory of objects</p> <p>Parameters:</p> Name Type Description Default <code>sol_state</code> <code>ndarray</code> <p>Solution state of the system</p> required <code>colors</code> <code>Optional[list[str]]</code> <p>Colors of the trajectories, by default None</p> <code>None</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels of the objects, used for legend, by default None</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Flag to check whether to show legend, by default False</p> <code>False</code> <code>xlabel</code> <code>str</code> <p>Label of x-axis, by default \"\\(x\\) (AU)\"</p> <code>'$x$'</code> <code>ylabel</code> <code>str</code> <p>Label of y-axis, by default \"\\(y\\) (AU)\"</p> <code>'$y$'</code> <code>zlabel</code> <code>str</code> <p>Label of z-axis, by default \"\\(z\\) (AU)\"</p> <code>'$z$'</code> <code>marker</code> <code>str</code> <p>Marker for the last position, by default \"o\"</p> <code>'o'</code> <code>markersize</code> <code>int</code> <p>Marker size for the last position, by default 6</p> <code>6</code> <code>save_fig</code> <code>bool</code> <p>Flag to check whether to save the figure, by default False</p> <code>False</code> <code>save_fig_path</code> <code>Optional[str]</code> <p>Path to save the figure, by default None</p> <code>None</code> Source code in <code>grav_sim/plotting.py</code> <pre><code>def plot_3d_trajectory(\n    sol_state: np.ndarray,\n    colors: Optional[list[str]] = None,\n    labels: Optional[list[str]] = None,\n    legend: bool = False,\n    xlabel: str = \"$x$\",\n    ylabel: str = \"$y$\",\n    zlabel: str = \"$z$\",\n    title: Optional[str] = None,\n    marker: str = \"o\",\n    markersize: int = 6,\n    save_fig: bool = False,\n    save_fig_path: Optional[str | Path] = None,\n) -&gt; None:\n    \"\"\"Plot 3D trajectory of objects\n\n    Parameters\n    ----------\n    sol_state : np.ndarray\n        Solution state of the system\n    colors : Optional[list[str]], optional\n        Colors of the trajectories, by default None\n    labels : Optional[list[str]], optional\n        Labels of the objects, used for legend, by default None\n    legend : bool, optional\n        Flag to check whether to show legend, by default False\n    xlabel : str, optional\n        Label of x-axis, by default \"$x$ (AU)\"\n    ylabel : str, optional\n        Label of y-axis, by default \"$y$ (AU)\"\n    zlabel : str, optional\n        Label of z-axis, by default \"$z$ (AU)\"\n    marker : str, optional\n        Marker for the last position, by default \"o\"\n    markersize : int, optional\n        Marker size for the last position, by default 6\n    save_fig : bool, optional\n        Flag to check whether to save the figure, by default False\n    save_fig_path : Optional[str], optional\n        Path to save the figure, by default None\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_box_aspect([1.0, 1.0, 1.0])  # type: ignore\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_zlabel(zlabel)  # type: ignore\n\n    for i in range(sol_state.shape[1] // 6):\n        if colors is not None:\n            colors_i = colors[i]\n        else:\n            colors_i = None\n\n        if labels is not None:\n            labels_i = labels[i]\n        else:\n            labels_i = None\n\n        traj = ax.plot(\n            sol_state[:, i * 3],\n            sol_state[:, i * 3 + 1],\n            sol_state[:, i * 3 + 2],\n            color=colors_i,\n        )\n        # Plot the last position with marker\n        ax.plot(\n            sol_state[-1, i * 3],\n            sol_state[-1, i * 3 + 1],\n            sol_state[-1, i * 3 + 2],\n            color=traj[0].get_color(),\n            label=labels_i,\n            marker=marker,\n            markersize=markersize,\n        )\n\n    set_3d_axes_equal(ax)\n\n    if title is not None:\n        ax.set_title(title)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(\n            right=0.7\n        )  # Adjust the right boundary of the plot to make room for the legend\n\n    fig.tight_layout()\n\n    if save_fig:\n        plt.savefig(save_fig_path, dpi=300)\n    else:\n        plt.show()\n    plt.close(\"all\")\n</code></pre>"},{"location":"docs/documentations/PythonAPI/plotting/#grav_sim.plotting.plot_quantity_against_time","title":"<code>plot_quantity_against_time(quantity, sol_time, is_log_y=False, title=None, xlabel=None, ylabel=None, colors=None, labels=None, legend=False, save_fig=False, save_fig_path=None)</code>","text":"<p>Plot a quantity against time</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>ndarray</code> <p>Quantity to be plotted</p> required <code>sol_time</code> <code>ndarray</code> <p>Solution time</p> required <code>is_log_y</code> <code>bool</code> <p>Flag to check whether y-axis is in log scale, by default False</p> <code>False</code> <code>title</code> <code>Optional[str]</code> <p>Title of the plot, by default None</p> <code>None</code> <code>xlabel</code> <code>Optional[str]</code> <p>Label of x-axis, by default None</p> <code>None</code> <code>ylabel</code> <code>Optional[str]</code> <p>Label of y-axis, by default None</p> <code>None</code> <code>colors</code> <code>Optional[list[str]]</code> <p>Colors of the trajectories, by default None</p> <code>None</code> <code>labels</code> <code>Optional[list[str]]</code> <p>Labels of the objects, used for legend, by default None</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Flag to check whether to show legend, by default False</p> <code>False</code> <code>save_fig</code> <code>bool</code> <p>Flag to check whether to save the figure, by default False</p> <code>False</code> <code>save_fig_path</code> <code>Optional[str]</code> <p>Path to save the figure, by default None</p> <code>None</code> Source code in <code>grav_sim/plotting.py</code> <pre><code>def plot_quantity_against_time(\n    quantity: np.ndarray,\n    sol_time: np.ndarray,\n    is_log_y: bool = False,\n    title: Optional[str] = None,\n    xlabel: Optional[str] = None,\n    ylabel: Optional[str] = None,\n    colors: Optional[list[str]] = None,\n    labels: Optional[list[str]] = None,\n    legend: bool = False,\n    save_fig: bool = False,\n    save_fig_path: Optional[str | Path] = None,\n) -&gt; None:\n    \"\"\"Plot a quantity against time\n\n    Parameters\n    ----------\n    quantity : np.ndarray\n        Quantity to be plotted\n    sol_time : np.ndarray\n        Solution time\n    is_log_y : bool, optional\n        Flag to check whether y-axis is in log scale, by default False\n    title : Optional[str], optional\n        Title of the plot, by default None\n    xlabel : Optional[str], optional\n        Label of x-axis, by default None\n    ylabel : Optional[str], optional\n        Label of y-axis, by default None\n    colors : Optional[list[str]], optional\n        Colors of the trajectories, by default None\n    labels : Optional[list[str]], optional\n        Labels of the objects, used for legend, by default None\n    legend : bool, optional\n        Flag to check whether to show legend, by default False\n    save_fig : bool, optional\n        Flag to check whether to save the figure, by default False\n    save_fig_path : Optional[str], optional\n        Path to save the figure, by default None\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    if len(quantity.shape) == 1:\n        quantity = quantity.reshape(-1, 1)\n\n    for i in range(quantity.shape[1]):\n        if colors is not None:\n            colors_i = colors[i]\n        else:\n            colors_i = None\n\n        if labels is not None:\n            labels_i = labels[i]\n        else:\n            labels_i = None\n\n        ax.plot(sol_time, quantity[:, i], color=colors_i, label=labels_i)\n\n    if is_log_y:\n        ax.set_yscale(\"log\")\n    if title is not None:\n        ax.set_title(title)\n    if xlabel is not None:\n        ax.set_xlabel(xlabel)\n    if ylabel is not None:\n        ax.set_ylabel(ylabel)\n\n    if legend:\n        ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        fig.subplots_adjust(\n            right=0.7\n        )  # Adjust the right boundary of the plot to make room for the legend\n\n    if save_fig:\n        plt.savefig(save_fig_path, dpi=300)\n    else:\n        plt.show()\n    plt.close(\"all\")\n</code></pre>"},{"location":"docs/documentations/PythonAPI/plotting/#grav_sim.plotting.set_3d_axes_equal","title":"<code>set_3d_axes_equal(ax)</code>","text":"<p>Make axes of 3D plot have equal scale</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>matplotlib axis</code> <p>The axis to set equal scale</p> required Reference <p>karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z</p> Source code in <code>grav_sim/plotting.py</code> <pre><code>def set_3d_axes_equal(ax: plt.Axes) -&gt; None:\n    \"\"\"\n    Make axes of 3D plot have equal scale\n\n    Parameters\n    ----------\n    ax : matplotlib axis\n        The axis to set equal scale\n\n    Reference\n    ---------\n    karlo, https://stackoverflow.com/questions/13685386/how-to-set-the-equal-aspect-ratio-for-all-axes-x-y-z\n    \"\"\"\n\n    x_limits = ax.get_xlim3d()  # type: ignore\n    y_limits = ax.get_ylim3d()  # type: ignore\n    z_limits = ax.get_zlim3d()  # type: ignore\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5 * max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])  # type: ignore\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])  # type: ignore\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])  # type: ignore\n</code></pre>"},{"location":"docs/documentations/PythonAPI/utils/","title":"Utils","text":"<p>Utility functions for grav_sim API</p>"},{"location":"docs/documentations/PythonAPI/utils/#grav_sim.utils.initialize_c_lib","title":"<code>initialize_c_lib(c_lib)</code>","text":"<p>Initialize C library</p> <p>Parameters:</p> Name Type Description Default <code>c_lib</code> <code>CDLL</code> <p>C dynamic-link library object</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any C functions that should be available are not found in the C library</p> Source code in <code>grav_sim/utils.py</code> <pre><code>def initialize_c_lib(c_lib: ctypes.CDLL) -&gt; None:\n    \"\"\"Initialize C library\n\n    Parameters\n    ----------\n    c_lib : ctypes.CDLL\n        C dynamic-link library object\n\n    Raises\n    ------\n    ValueError\n        If any C functions that should be available are not found in the C library\n    \"\"\"\n    c_lib.launch_simulation_python.restype = int\n    c_lib.launch_cosmological_simulation_python.restype = int\n    c_lib.compute_energy_python.restype = None\n    c_lib.compute_linear_momentum_python.restype = None\n    c_lib.compute_angular_momentum_python.restype = None\n    c_lib.load_built_in_system_python.restype = int\n    c_lib.free_memory_int32.restype = None\n    c_lib.free_memory_double.restype = None\n    c_lib.keplerian_to_cartesian_python.restype = None\n</code></pre>"},{"location":"docs/documentations/PythonAPI/utils/#grav_sim.utils.keplerian_to_cartesian","title":"<code>keplerian_to_cartesian(c_lib, semi_major_axis, eccentricity, inclination, argument_of_periapsis, longitude_of_ascending_node, true_anomaly, total_mass, G)</code>","text":"<p>Convert Keplerian elements to Cartesian coordinates</p> <p>Parameters:</p> Name Type Description Default <code>semi_major_axis</code> <code>float</code> <p>Semi-major axis</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity</p> required <code>inclination</code> <code>float</code> <p>Inclination</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node</p> required <code>arg_periapsis</code> <code>float</code> <p>Argument of periapsis</p> required <code>true_anomaly</code> <code>float</code> <p>True anomaly</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the two bodies</p> required <code>G</code> <code>float</code> <p>Gravitational constant</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Position and velocity vectors in Cartesian coordinates</p> Source code in <code>grav_sim/utils.py</code> <pre><code>def keplerian_to_cartesian(\n    c_lib: ctypes.CDLL,\n    semi_major_axis: float,\n    eccentricity: float,\n    inclination: float,\n    argument_of_periapsis: float,\n    longitude_of_ascending_node: float,\n    true_anomaly: float,\n    total_mass: float,\n    G: float,\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert Keplerian elements to Cartesian coordinates\n\n    Parameters\n    ----------\n    semi_major_axis : float\n        Semi-major axis\n    eccentricity : float\n        Eccentricity\n    inclination : float\n        Inclination\n    raan : float\n        Right ascension of ascending node\n    arg_periapsis : float\n        Argument of periapsis\n    true_anomaly : float\n        True anomaly\n    total_mass : float\n        Total mass of the two bodies\n    G : float\n        Gravitational constant\n\n    Returns\n    -------\n    Tuple[np.ndarray, np.ndarray]\n        Position and velocity vectors in Cartesian coordinates\n    \"\"\"\n\n    x = ctypes.c_double()\n    y = ctypes.c_double()\n    z = ctypes.c_double()\n    v_x = ctypes.c_double()\n    v_y = ctypes.c_double()\n    v_z = ctypes.c_double()\n    c_lib.keplerian_to_cartesian_python(\n        ctypes.byref(x),\n        ctypes.byref(y),\n        ctypes.byref(z),\n        ctypes.byref(v_x),\n        ctypes.byref(v_y),\n        ctypes.byref(v_z),\n        ctypes.c_double(semi_major_axis),\n        ctypes.c_double(eccentricity),\n        ctypes.c_double(inclination),\n        ctypes.c_double(argument_of_periapsis),\n        ctypes.c_double(longitude_of_ascending_node),\n        ctypes.c_double(true_anomaly),\n        ctypes.c_double(total_mass),\n        ctypes.c_double(G),\n    )\n\n    return np.array([x.value, y.value, z.value]), np.array(\n        [v_x.value, v_y.value, v_z.value]\n    )\n</code></pre>"},{"location":"docs/documentations/PythonAPI/utils/#grav_sim.utils.load_c_lib","title":"<code>load_c_lib(c_lib_path=None)</code>","text":"<p>Load the C dynamic-link library</p> <p>Returns:</p> Name Type Description <code>c_lib</code> <code>CDLL</code> <p>C dynamic-link library object</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the platform is not supported</p> <code>FileNotFoundError</code> <p>If the C library is not found at the path</p> Source code in <code>grav_sim/utils.py</code> <pre><code>def load_c_lib(c_lib_path: Optional[str | Path] = None) -&gt; ctypes.CDLL:\n    \"\"\"Load the C dynamic-link library\n\n    Returns\n    -------\n    c_lib : ctypes.CDLL\n        C dynamic-link library object\n\n    Raises\n    ------\n    OSError\n        If the platform is not supported\n    FileNotFoundError\n        If the C library is not found at the path\n    \"\"\"\n    if not c_lib_path:\n        search_path = Path(__file__).parent.parent\n    else:\n        search_path = Path(c_lib_path).parent\n\n    c_lib_files = [str(p) for p in search_path.rglob(\"*libgrav_sim*\")]\n    if len(c_lib_files) == 0:\n        raise FileNotFoundError(f\"C library not found from path: {search_path}\")\n\n    c_lib_path = c_lib_files[0]\n\n    return ctypes.cdll.LoadLibrary(str(c_lib_path))\n</code></pre>"},{"location":"docs/getting_started/","title":"Getting started","text":"<p>grav_sim is a package written in C provided with a Python wrapper. Therefore, you can choose to install in either C or Python. The performance difference between the two is negligible.</p> <p>Here we provide a quick installation guide for Python. For a more detailed guide, please refer to Installation in C and Installation in Python.</p> MacOS / LinuxWindows <p>The package is available on PyPI, and could be installed directly using pip: <pre><code>pip install grav_sim\n</code></pre> To check whether it is successfully installed, run <pre><code>python -m grav_sim\n</code></pre></p> <p>You should see the compilation information and the path to the compiled library. If not, you may need to refer to Installation in Python. <pre><code>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.4\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: true\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: false\n\nBuild time: Apr 16 2025 13:12:32\nCompiler: GCC (version: 14)\n-----------------------------------------------------------------\nC library location: /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/libgrav_sim.dylib\n</code></pre></p> <p>Installation is a bit complicated on Windows. You will need to compile the C library and then install the Python wrapper. You may follow the instructions in Installation in Python.</p> <p>Personally, I recommend using WSL (Windows Subsystem for Linux) to run grav_sim directly.</p>"},{"location":"docs/getting_started/installation_in_c/","title":"Installation in C","text":"<p>Below are the dependencies for the package:</p> <ul> <li>C compiler, preferably GCC or Clang</li> <li>CMake</li> </ul> <p>Optional dependencies:</p> <ul> <li>HDF5 (For data storage. Optional but recommended)</li> <li>FFTW3 (Only required for cosmological simulations)</li> <li>OpenMP</li> </ul> <p>Below is an example for compiling a C program with grav_sim.</p> <ol> <li> <p>Clone the repository to your local machine: <pre><code>git clone https://github.com/alvinng4/grav_sim\n</code></pre></p> </li> <li> <p>Create a project directory. Lets call it <code>test/</code> <pre><code>mkdir test\ncd test\n</code></pre></p> </li> <li> <p>Create <code>test.c</code> and <code>CMakeLists.txt</code> in <code>test/</code>: test.c<pre><code>#include &lt;grav_sim.h&gt;\n\nint main(void)\n{\n    print_compilation_info();\n    return 0;\n}\n</code></pre> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.10)\nproject(test C)\n\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_STANDARD_REQUIRED ON)\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -O3 -Wall -Wextra -Wpedantic\")\n\n# Define source and library directories\nset(SRC_DIR ../grav_sim)    # &lt;-- Make sure the path is correct\ninclude_directories(${SRC_DIR})\n\n# Define the executable\nadd_executable(test test.c)\n\n# Link against the grav_sim library\nadd_subdirectory(${SRC_DIR} build)\ntarget_link_libraries(test PRIVATE grav_sim)\n</code></pre></p> </li> <li> <p>Create a build directory and compile the code: <pre><code>mkdir build\ncd build\ncmake [-DUSE_OPENMP=ON -DUSE_FFTW3=ON -DUSE_HDF5=ON] [-DCMAKE_C_COMPILER=gcc] ..\ncmake --build .\n</code></pre></p> <ul> <li><code>-DUSE_OPENMP=ON -DUSE_FFTW3=ON -DUSE_HDF5=ON</code>: optional flags for the dependencies.</li> <li><code>-DCMAKE_C_COMPILER=gcc</code>: optional flag to specify the C compiler.</li> </ul> </li> <li> <p>Run the code: <pre><code>./test\n</code></pre> You should see something like this: <pre><code>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.4\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: true\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: true\n    Version: fftw-3.3.10\n\nBuild time: Apr 16 2025 18:31:10\nCompiler: GCC (version: 14)\n-----------------------------------------------------------------\n</code></pre></p> </li> </ol> <p>Congrats!  Now you have successfully built a project with the grav_sim package in C.</p>"},{"location":"docs/getting_started/installation_in_python/","title":"Installation in Python","text":"<p>For basic install, follow the quick guide at Getting Started. Here we provide a more detailed installation guide for Python.</p> <p>Below are the dependencies for the package:</p> <ul> <li>C compiler, preferably GCC or Clang</li> <li>CMake</li> <li>Python version &gt;= 3.9</li> </ul> <p>Optional dependencies:</p> <ul> <li>HDF5 (For data storage. Optional but recommended)</li> <li>FFTW3 (Only required for cosmological simulations)</li> <li>OpenMP</li> </ul> <p>Python packages: (Check <code>requirements.txt</code> for the latest version)</p> <ul> <li>NumPy</li> <li>Matplotlib</li> <li>h5py</li> </ul> <p>There are multiple ways to install the package, depending on your use case.</p> Installing with pip and local compilation (MacOS / Linux)Compiling the C library directly from source <p>If you want to compile the package locally, you could run <pre><code>// Choose the options you want\nexport CMAKE_ARGS=\"-DUSE_HDF5=ON -DUSE_OPENMP=ON -DUSE_FFTW3=ON -DCMAKE_C_COMPILER=gcc ..\"\n\npip install grav_sim --no-binary grav_sim --no-cache-dir\n</code></pre></p> <ul> <li><code>-DUSE_OPENMP=ON -DUSE_FFTW3=ON -DUSE_HDF5=ON</code>: optional flags for the dependencies.</li> <li><code>-DCMAKE_C_COMPILER=gcc</code>: optional flag to specify the C compiler.</li> </ul> <p>To check whether it is successfully installed, run <pre><code>python -m grav_sim [--path=c_lib_path]\n</code></pre> where <code>--path=c_lib_path</code> is optional argument to specify the path to the compiled C library. You should see the compilation information and the path to the compiled library. <pre><code>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.4\n\nOperating System: MacOS\nCompilation Info:\nCompiled with OpenMP: true\nCompiled with HDF5: true\n    Version: 1.14.6\nCompiled with FFTW3: false\n\nBuild time: Apr 16 2025 13:12:32\nCompiler: GCC (version: 14)\n-----------------------------------------------------------------\nC library location: /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/libgrav_sim.dylib\n</code></pre></p> <p>This way should work on all platforms as long as you could get the C library compiled on your system.</p> <ol> <li>Clone the repository to your local machine and navigate to the directory: <pre><code>git clone https://github.com/alvinng4/grav_sim\ncd grav_sim\n</code></pre></li> <li>Create a build directory inside the repository: <pre><code>mkdir build\ncd build\n</code></pre></li> <li> <p>Compile the library with CMake <pre><code>cmake [-DUSE_OPENMP=ON -DUSE_FFTW3=ON -DUSE_HDF5=ON] [-DCMAKE_C_COMPILER=gcc] ..\ncmake --build .\n</code></pre></p> <ul> <li><code>-DUSE_OPENMP=ON -DUSE_FFTW3=ON -DUSE_HDF5=ON</code>: optional flags for the dependencies.</li> <li><code>-DCMAKE_C_COMPILER=gcc</code>: optional flag to specify the C compiler.</li> </ul> </li> <li> <p>Check the compilation. You should see one of the following files in the <code>build</code> directory. <pre><code>libgrav_sim.dylib\nlibgrav_sim.so\nlibgrav_sim.dll\n</code></pre> This is the compiled C library. You will need to keep track of the path to this file.</p> </li> <li> <p>Now you can install the Python wrapper either from PyPI or from source.</p> MacOS / LinuxWindows <ul> <li>To install from PyPI, run   <pre><code>SKIP_CMAKE=1 pip install grav_sim\n</code></pre></li> <li>To install from source, navigate to the parent directory and run   <pre><code>SKIP_CMAKE=1 pip install .\n</code></pre></li> </ul> <ul> <li>To install from PyPI, run   <pre><code>set SKIP_CMAKE=1\npip install grav_sim\n</code></pre></li> <li>To install from source, navigate to the parent directory and run   <pre><code>set SKIP_CMAKE=1\npip install .\n</code></pre></li> </ul> </li> <li> <p>To check whether it is successfully installed, run   <pre><code>python -m grav_sim --path=/path/to/compiled/c_lib\n</code></pre>   where <code>--path=/path/to/compiled/c_lib</code> is the path to the compiled C library.   You should see the compilation information and the path to the compiled library.</p> </li> </ol> <pre><code>-----------------------------------------------------------------\n                                            __                   \n  __   _ __    __     __  __           ____/\\_\\    ___ ___       \n/'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n/\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n\\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.5\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: false\n  Compiled with FFTW3: false\n\nBuild time: Apr 28 2025 17:06:18\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nC library location: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/build/lib.macosx-10.9-universal2-cpython-311/libgrav_sim.dylib\n</code></pre>"},{"location":"examples/","title":"Index","text":""},{"location":"examples/#evolving-the-solar-system-for-1-million-years","title":"Evolving the solar system for 1 million years","text":""},{"location":"examples/#asteroid-belt-animation","title":"Asteroid belt animation","text":""},{"location":"examples/#formation-of-kirkwood-gaps","title":"Formation of Kirkwood gaps","text":""},{"location":"examples/#galaxy-collision","title":"Galaxy collision","text":""},{"location":"examples/#cosmological-structure-formation","title":"Cosmological structure formation","text":""},{"location":"examples/solar_system_one_mil_yrs/","title":"Evolving Solar system simulation for one million years","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom grav_sim import GravitySimulatorAPI\n\ngs = GravitySimulatorAPI()\n\nprint()\nprint(\"Available built-in systems:\", gs.BUILT_IN_SYSTEMS)\nprint(\"Available acceleration methods:\", gs.AVAILABLE_ACCELERATION_METHODS)\nprint(\"Available integrators:\", gs.AVAILABLE_INTEGRATORS)\nprint(\"Fixed step size integrators:\", gs.FIXED_STEP_SIZE_INTEGRATORS)\nprint(\"Adaptive step size integrators:\", gs.ADAPTIVE_STEP_SIZE_INTEGRATORS)\nprint(\"Available output methods:\", gs.AVAILABLE_OUTPUT_METHODS)\nprint(\"Available output data types:\", gs.AVAILABLE_OUTPUT_DTYPE)\n\ncolors = [\n    \"orange\",\n    \"slategrey\",\n    \"wheat\",\n    \"skyblue\",\n    \"red\",\n    \"darkgoldenrod\",\n    \"gold\",\n    \"paleturquoise\",\n    \"blue\",\n]\nlabels = [\n    \"Sun\",\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n]\n</pre> import numpy as np from grav_sim import GravitySimulatorAPI  gs = GravitySimulatorAPI()  print() print(\"Available built-in systems:\", gs.BUILT_IN_SYSTEMS) print(\"Available acceleration methods:\", gs.AVAILABLE_ACCELERATION_METHODS) print(\"Available integrators:\", gs.AVAILABLE_INTEGRATORS) print(\"Fixed step size integrators:\", gs.FIXED_STEP_SIZE_INTEGRATORS) print(\"Adaptive step size integrators:\", gs.ADAPTIVE_STEP_SIZE_INTEGRATORS) print(\"Available output methods:\", gs.AVAILABLE_OUTPUT_METHODS) print(\"Available output data types:\", gs.AVAILABLE_OUTPUT_DTYPE)  colors = [     \"orange\",     \"slategrey\",     \"wheat\",     \"skyblue\",     \"red\",     \"darkgoldenrod\",     \"gold\",     \"paleturquoise\",     \"blue\", ] labels = [     \"Sun\",     \"Mercury\",     \"Venus\",     \"Earth\",     \"Mars\",     \"Jupiter\",     \"Saturn\",     \"Uranus\",     \"Neptune\", ] <pre>\nAvailable built-in systems: ['circular_binary_orbit', 'eccentric_binary_orbit', '3d_helix', 'sun_earth_moon', 'figure-8', 'pyth-3-body', 'solar_system', 'solar_system_plus']\nAvailable acceleration methods: ['pairwise', 'massless', 'barnes_hut', 'particle_mesh']\nAvailable integrators: ['euler', 'euler_cromer', 'rk4', 'leapfrog', 'rkf45', 'dopri', 'dverk', 'rkf78', 'ias15', 'whfast']\nFixed step size integrators: ['euler', 'euler_cromer', 'rk4', 'leapfrog', 'whfast']\nAdaptive step size integrators: ['rkf45', 'dopri', 'dverk', 'rkf78', 'ias15']\nAvailable output methods: ['disabled', 'csv', 'hdf5']\nAvailable output data types: ['float', 'double']\n</pre> In\u00a0[2]: Copied! <pre>system = gs.get_built_in_system(\"solar_system\")\n\n### Parameters ###\ntf = gs.years_to_days(1000000.0)  # One million years\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"whfast\"\nintegrator_param.dt = 5.0\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 1000.0\n</pre> system = gs.get_built_in_system(\"solar_system\")  ### Parameters ### tf = gs.years_to_days(1000000.0)  # One million years  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"whfast\" integrator_param.dt = 5.0  output_param.method = \"csv\" output_param.output_interval = tf / 1000.0 In\u00a0[3]: Copied! <pre>gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf)\n</pre> gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf) <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.3\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: false\n\nBuild time: Apr 12 2025 00:34:13\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 3.65242e+08\n\nSystem:\n  Number of particles: 9\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: WHFAST\n  dt: 5\n  WHFast remove invalid particles: true\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\n  Output initial condition: true\n  Output interval: 365242\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   0% \u2022 00:00:00 \u2022 --:--:--</pre> <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\".\n</pre> <pre>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:01:47 \u2022 00:00:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  14% \u2022 00:00:15 \u2022 00:01:26\n</pre> In\u00a0[4]: Copied! <pre>G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\n\nsol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir )  sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[5]: Copied! <pre>eccentricity = gs.compute_eccentricity(G, sol_state)\ngs.plot_quantity_against_time(\n    quantity=eccentricity,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"eccentricity\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n\ninclination = gs.compute_inclination(sol_state)\ngs.plot_quantity_against_time(\n    quantity=inclination,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"inclination\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n</pre> eccentricity = gs.compute_eccentricity(G, sol_state) gs.plot_quantity_against_time(     quantity=eccentricity,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"eccentricity\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, )  inclination = gs.compute_inclination(sol_state) gs.plot_quantity_against_time(     quantity=inclination,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"inclination\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, ) In\u00a0[6]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n\ndel system\ndel acc_param\ndel integrator_param\ndel output_param\ndel settings\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir)  del system del acc_param del integrator_param del output_param del settings In\u00a0[7]: Copied! <pre>system = gs.get_built_in_system(\"solar_system\")\n\n### Parameters ###\ntf = gs.years_to_days(1000000.0)  # One million years\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"ias15\"\nintegrator_param.tolerance = 1e-9\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 1000.0\n</pre> system = gs.get_built_in_system(\"solar_system\")  ### Parameters ### tf = gs.years_to_days(1000000.0)  # One million years  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"ias15\" integrator_param.tolerance = 1e-9  output_param.method = \"csv\" output_param.output_interval = tf / 1000.0 In\u00a0[8]: Copied! <pre>gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf)\n</pre> gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.3\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: false\n\nBuild time: Apr 12 2025 00:34:13\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 3.65242e+08\n\nSystem:\n  Number of particles: 9\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: IAS15\n  Tolerance: 1e-09\n  Initial dt (if applicable): -1\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\n  Output initial condition: true\n  Output interval: 365242\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 02:48:29 \u2022 00:00:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   1% \u2022 00:03:14 \u2022 02:53:46\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   2% \u2022 00:03:41 \u2022 03:13:18\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   4% \u2022 00:08:01 \u2022 03:15:06\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   8% \u2022 00:14:10 \u2022 04:52:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   8% \u2022 00:15:24 \u2022 07:05:43\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  11% \u2022 00:19:54 \u2022 02:37:13\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  14% \u2022 00:24:42 \u2022 02:49:17\u2501\u2501\u2501\u2501  16% \u2022 00:28:12 \u2022 02:15:01\u2501\u2501\u2501  17% \u2022 00:29:21 \u2022 03:00:34\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  20% \u2022 00:35:39 \u2022 04:07:08\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  24% \u2022 00:42:01 \u2022 02:09:29\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  27% \u2022 00:47:16 \u2022 03:04:27\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  29% \u2022 00:49:08 \u2022 01:54:33\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  36% \u2022 01:01:09 \u2022 03:19:07\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  46% \u2022 01:17:41 \u2022 01:31:30\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  47% \u2022 01:19:59 \u2022 02:23:34\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  74% \u2022 02:00:21 \u2022 00:47:57\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  77% \u2022 02:05:05 \u2022 00:43:59\u2501\u2501\u2501  78% \u2022 02:07:26 \u2022 00:40:19\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  78% \u2022 02:07:39 \u2022 00:44:45\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  79% \u2022 02:07:55 \u2022 00:53:09\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  82% \u2022 02:14:05 \u2022 00:33:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  83% \u2022 02:16:30 \u2022 00:27:14\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  84% \u2022 02:16:48 \u2022 00:25:56\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  86% \u2022 02:21:11 \u2022 00:29:44\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  91% \u2022 02:30:09 \u2022 00:19:02\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  92% \u2022 02:31:52 \u2022 00:38:49\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  93% \u2022 02:34:39 \u2022 00:22:43\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  97% \u2022 02:42:39 \u2022 00:09:01\n</pre> In\u00a0[9]: Copied! <pre>G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\n\nsol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir )  sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[10]: Copied! <pre>eccentricity = gs.compute_eccentricity(G, sol_state)\ngs.plot_quantity_against_time(\n    quantity=eccentricity,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"eccentricity\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n\ninclination = gs.compute_inclination(sol_state)\ngs.plot_quantity_against_time(\n    quantity=inclination,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"inclination\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n</pre> eccentricity = gs.compute_eccentricity(G, sol_state) gs.plot_quantity_against_time(     quantity=eccentricity,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"eccentricity\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, )  inclination = gs.compute_inclination(sol_state) gs.plot_quantity_against_time(     quantity=inclination,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"inclination\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, ) In\u00a0[11]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n\ndel system\ndel acc_param\ndel integrator_param\ndel output_param\ndel settings\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir)  del system del acc_param del integrator_param del output_param del settings In\u00a0[12]: Copied! <pre>system = gs.get_built_in_system(\"solar_system\")\n\n### Parameters ###\ntf = gs.years_to_days(1000000.0)  # One million years\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"leapfrog\"\nintegrator_param.dt = 0.5\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 1000.0\n</pre> system = gs.get_built_in_system(\"solar_system\")  ### Parameters ### tf = gs.years_to_days(1000000.0)  # One million years  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"leapfrog\" integrator_param.dt = 0.5  output_param.method = \"csv\" output_param.output_interval = tf / 1000.0 In\u00a0[13]: Copied! <pre>gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf)\n</pre> gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.3\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: false\n\nBuild time: Apr 12 2025 00:34:13\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 3.65242e+08\n\nSystem:\n  Number of particles: 9\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: Leapfrog\n  dt: 0.5\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\n  Output initial condition: true\n  Output interval: 365242\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:03:44 \u2022 00:00:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  29% \u2022 00:01:04 \u2022 00:09:07\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  30% \u2022 00:01:06 \u2022 00:05:06\n</pre> In\u00a0[14]: Copied! <pre>G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\n\nsol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n\neccentricity = gs.compute_eccentricity(G, sol_state)\ngs.plot_quantity_against_time(\n    quantity=eccentricity,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"eccentricity\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n\ninclination = gs.compute_inclination(sol_state)\ngs.plot_quantity_against_time(\n    quantity=inclination,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"inclination\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n</pre> G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir )  sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", )  eccentricity = gs.compute_eccentricity(G, sol_state) gs.plot_quantity_against_time(     quantity=eccentricity,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"eccentricity\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, )  inclination = gs.compute_inclination(sol_state) gs.plot_quantity_against_time(     quantity=inclination,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"inclination\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, ) In\u00a0[15]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n\ndel system\ndel acc_param\ndel integrator_param\ndel output_param\ndel settings\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir)  del system del acc_param del integrator_param del output_param del settings <p>Let's try a smaller $\\text{d}t = 0.1 \\text{ days}$ and see if the result improves.</p> In\u00a0[16]: Copied! <pre>system = gs.get_built_in_system(\"solar_system\")\n\n### Parameters ###\ntf = gs.years_to_days(1000000.0)  # One million years\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"leapfrog\"\nintegrator_param.dt = 0.1\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 1000.0\n</pre> system = gs.get_built_in_system(\"solar_system\")  ### Parameters ### tf = gs.years_to_days(1000000.0)  # One million years  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"leapfrog\" integrator_param.dt = 0.1  output_param.method = \"csv\" output_param.output_interval = tf / 1000.0 In\u00a0[17]: Copied! <pre>gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf)\n</pre> gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.3\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: false\n\nBuild time: Apr 12 2025 00:34:13\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 3.65242e+08\n\nSystem:\n  Number of particles: 9\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: Leapfrog\n  dt: 0.1\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\n  Output initial condition: true\n  Output interval: 365242\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:18:54 \u2022 00:00:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  25% \u2022 00:04:26 \u2022 00:16:42\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  36% \u2022 00:06:50 \u2022 00:21:03\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  48% \u2022 00:09:12 \u2022 00:10:34\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  58% \u2022 00:10:52 \u2022 00:07:41\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  60% \u2022 00:11:23 \u2022 00:18:28\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  78% \u2022 00:14:32 \u2022 00:06:23\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  78% \u2022 00:14:33 \u2022 00:10:14\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  96% \u2022 00:17:43 \u2022 00:00:41\n</pre> In\u00a0[18]: Copied! <pre>G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\n\nsol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n\neccentricity = gs.compute_eccentricity(G, sol_state)\ngs.plot_quantity_against_time(\n    quantity=eccentricity,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"eccentricity\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n\ninclination = gs.compute_inclination(sol_state)\ngs.plot_quantity_against_time(\n    quantity=inclination,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"inclination\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n</pre> G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir )  sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", )  eccentricity = gs.compute_eccentricity(G, sol_state) gs.plot_quantity_against_time(     quantity=eccentricity,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"eccentricity\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, )  inclination = gs.compute_inclination(sol_state) gs.plot_quantity_against_time(     quantity=inclination,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"inclination\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, ) In\u00a0[19]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n\ndel system\ndel acc_param\ndel integrator_param\ndel output_param\ndel settings\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir)  del system del acc_param del integrator_param del output_param del settings In\u00a0[20]: Copied! <pre>system = gs.get_built_in_system(\"solar_system\")\n\n### Parameters ###\ntf = gs.years_to_days(1000000.0)  # One million years\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"rk4\"\nintegrator_param.dt = 0.5\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 1000.0\n</pre> system = gs.get_built_in_system(\"solar_system\")  ### Parameters ### tf = gs.years_to_days(1000000.0)  # One million years  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"rk4\" integrator_param.dt = 0.5  output_param.method = \"csv\" output_param.output_interval = tf / 1000.0 In\u00a0[21]: Copied! <pre>gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf)\n</pre> gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.3\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: true\n    Version: 1.14.6\n  Compiled with FFTW3: false\n\nBuild time: Apr 12 2025 00:34:13\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 3.65242e+08\n\nSystem:\n  Number of particles: 9\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: RK4\n  dt: 0.5\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/grav_sim/examples/tmp/\n  Output initial condition: true\n  Output interval: 365242\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:13:55 \u2022 00:00:00\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  11% \u2022 00:02:06 \u2022 00:23:00\u2501\u2501\u2501\u2501\u2501  27% \u2022 00:04:20 \u2022 00:12:06\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  53% \u2022 00:07:31 \u2022 00:09:29\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  61% \u2022 00:08:38 \u2022 00:08:49\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501  96% \u2022 00:13:26 \u2022 00:00:25\n</pre> In\u00a0[22]: Copied! <pre>G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\n\nsol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n\neccentricity = gs.compute_eccentricity(G, sol_state)\ngs.plot_quantity_against_time(\n    quantity=eccentricity,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"eccentricity\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n\ninclination = gs.compute_inclination(sol_state)\ngs.plot_quantity_against_time(\n    quantity=inclination,\n    is_log_y=False,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n    ylabel=\"inclination\",\n    colors=colors[1:],  # Exclude the Sun\n    labels=labels[1:],  # Exclude the Sun\n    legend=True,\n)\n</pre> G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir )  sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", )  eccentricity = gs.compute_eccentricity(G, sol_state) gs.plot_quantity_against_time(     quantity=eccentricity,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"eccentricity\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, )  inclination = gs.compute_inclination(sol_state) gs.plot_quantity_against_time(     quantity=inclination,     is_log_y=False,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\",     ylabel=\"inclination\",     colors=colors[1:],  # Exclude the Sun     labels=labels[1:],  # Exclude the Sun     legend=True, ) In\u00a0[\u00a0]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n\ndel system\ndel acc_param\ndel integrator_param\ndel output_param\ndel settings\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir)  del system del acc_param del integrator_param del output_param del settings"},{"location":"examples/solar_system_one_mil_yrs/#evolving-solar-system-simulation-for-one-million-years","title":"Evolving Solar system simulation for one million years\u00b6","text":"<p>N-body simulations can help us understanding the evolution of our solar system. Let's try to simulate it with different algorithms and compare the secular evolution.</p> <p>If your system can't run or render this notebook, you could view it on github.</p>"},{"location":"examples/solar_system_one_mil_yrs/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/solar_system_one_mil_yrs/#whfast","title":"WHFast\u00b6","text":"<p>We will start with the WHFast algorithm. This algorithm is symplectic (conserves energy over long simulation period). It is suitable for stable systems like our solar system.</p> <p>We start with $\\text{d}t = 5.0 \\text{ days}$. For most computers, it should only take a few minutes.</p>"},{"location":"examples/solar_system_one_mil_yrs/#data-analysis","title":"Data analysis\u00b6","text":"<p>Let's plot the relative energy error. We can see that the error is bounded within $5 \\times 10^{-8}$ even over 1 million years!</p>"},{"location":"examples/solar_system_one_mil_yrs/#secular-evolution","title":"Secular evolution\u00b6","text":"<p>We can visualize the secular evolution of the solar system over 1 million years by plotting their eccentricity and inclination.</p>"},{"location":"examples/solar_system_one_mil_yrs/#comparison-between-algorithms","title":"Comparison between algorithms\u00b6","text":"<p>Now, we can compare WHFast with other algorithms.</p>"},{"location":"examples/solar_system_one_mil_yrs/#ias15","title":"IAS15\u00b6","text":"<p>IAS15 is a high order integrator with extreme accuracy. However, running this may take 2 hours - 10 hours, depending on your computer.</p>"},{"location":"examples/solar_system_one_mil_yrs/#data-analysis","title":"Data analysis\u00b6","text":"<p>Here, the energy error is not bounded like WHFast, but it is growing very slowly! After 1 million years, the error remains in the order of $10^{-14}$. This is due to the accuracy of IAS15 and the reduction of round-off error by using compensated summation.</p>"},{"location":"examples/solar_system_one_mil_yrs/#secular-evolution","title":"Secular evolution\u00b6","text":"<p>Comparing the secular evolution with WHFast, we can see that they agree extremely well with each other.</p>"},{"location":"examples/solar_system_one_mil_yrs/#leapfrog","title":"LeapFrog\u00b6","text":"<p>LeapFrog is a second order symplectic method that conserves energy and is very simple to implement. Let us try $\\text{d}t = 0.5 \\text{ days}$. The run time should be very close to WHFast with $\\text{d}t = 5.0 \\text{ days}$.</p>"},{"location":"examples/solar_system_one_mil_yrs/#data-analysis","title":"Data analysis\u00b6","text":"<p>Again, we can see the relative energy error is bounded! However, for the secular evolution, we can see that the eccentricity does not agree very well with IAS15 and WHFast. Inclination, on the other hand, agrees relatively well except for Mercury.</p>"},{"location":"examples/solar_system_one_mil_yrs/#data-analysis","title":"Data Analysis\u00b6","text":"<p>Unfortunately, the round-off error starts to build up as we used a very small $\\text{d}t$. The energy error is no longer bounded and the secular evolution became unstable for all planets.</p>"},{"location":"examples/solar_system_one_mil_yrs/#rk4","title":"RK4\u00b6","text":"<p>RK4 is another popular n-body algorithm, which has a good balance on computational cost and accuracy. Since it does not conserve energy, it is not suitable for long term simulations.</p> <p>We will use $\\text{d}t = 0.5 \\text{ days}$.</p>"},{"location":"examples/solar_system_one_mil_yrs/#data-analysis","title":"Data analysis\u00b6","text":"<p>We can see that the energy error goes up to $10^{-4}$, which is not ideal. Nevertheless, looking at the secular evolution, we can see that it performed a lot better than LeapFrog.</p>"},{"location":"examples/solar_system_one_mil_yrs/#end","title":"END\u00b6","text":""},{"location":"examples/tutorial/","title":"Tutorial (Python)","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom grav_sim import GravitySimulatorAPI\n\ngs = GravitySimulatorAPI()\n\n# If the program couldn't find the C library, you may specify it manually\n# gs = GravitySimulatorAPI(c_lib_path=\"path_to_your_c_lib.so\")\n\nprint()\nprint(\"Available built-in systems:\", gs.BUILT_IN_SYSTEMS)\nprint(\"Available acceleration methods:\", gs.AVAILABLE_ACCELERATION_METHODS)\nprint(\"Available integrators:\", gs.AVAILABLE_INTEGRATORS)\nprint(\"Fixed step size integrators:\", gs.FIXED_STEP_SIZE_INTEGRATORS)\nprint(\"Adaptive step size integrators:\", gs.ADAPTIVE_STEP_SIZE_INTEGRATORS)\nprint(\"Available output methods:\", gs.AVAILABLE_OUTPUT_METHODS)\nprint(\"Available output data types:\", gs.AVAILABLE_OUTPUT_DTYPE)\n</pre> import os from pathlib import Path  import numpy as np  from grav_sim import GravitySimulatorAPI  gs = GravitySimulatorAPI()  # If the program couldn't find the C library, you may specify it manually # gs = GravitySimulatorAPI(c_lib_path=\"path_to_your_c_lib.so\")  print() print(\"Available built-in systems:\", gs.BUILT_IN_SYSTEMS) print(\"Available acceleration methods:\", gs.AVAILABLE_ACCELERATION_METHODS) print(\"Available integrators:\", gs.AVAILABLE_INTEGRATORS) print(\"Fixed step size integrators:\", gs.FIXED_STEP_SIZE_INTEGRATORS) print(\"Adaptive step size integrators:\", gs.ADAPTIVE_STEP_SIZE_INTEGRATORS) print(\"Available output methods:\", gs.AVAILABLE_OUTPUT_METHODS) print(\"Available output data types:\", gs.AVAILABLE_OUTPUT_DTYPE) <pre>\nAvailable built-in systems: ['circular_binary_orbit', 'eccentric_binary_orbit', '3d_helix', 'sun_earth_moon', 'figure-8', 'pyth-3-body', 'solar_system', 'solar_system_plus']\nAvailable acceleration methods: ['pairwise', 'massless', 'barnes_hut', 'particle_mesh']\nAvailable integrators: ['euler', 'euler_cromer', 'rk4', 'leapfrog', 'rkf45', 'dopri', 'dverk', 'rkf78', 'ias15', 'whfast']\nFixed step size integrators: ['euler', 'euler_cromer', 'rk4', 'leapfrog', 'whfast']\nAdaptive step size integrators: ['rkf45', 'dopri', 'dverk', 'rkf78', 'ias15']\nAvailable output methods: ['disabled', 'csv', 'hdf5']\nAvailable output data types: ['float', 'double']\n</pre> In\u00a0[2]: Copied! <pre>system = gs.get_built_in_system(\"solar_system\")\nprint(system.num_particles)\nprint(system.particle_ids)\nprint(system.x)\nprint(system.v)\nprint(system.m)\n</pre> system = gs.get_built_in_system(\"solar_system\") print(system.num_particles) print(system.particle_ids) print(system.x) print(system.v) print(system.m) <pre>9\n[0 1 2 3 4 5 6 7 8]\n[[-7.96712825e-03 -2.90611166e-03  2.10213120e-04]\n [-2.82597500e-01  1.97456095e-01  4.17742433e-02]\n [-7.23209543e-01 -7.94829045e-02  4.04286220e-02]\n [-1.73818374e-01  9.66324671e-01  1.55297876e-04]\n [-3.01325412e-01 -1.45402922e+00 -2.30054066e-02]\n [ 3.48520330e+00  3.55213702e+00 -9.27104467e-02]\n [ 8.98810505e+00 -3.71906474e+00 -2.93193870e-01]\n [ 1.22630250e+01  1.52973880e+01 -1.02054995e-01]\n [ 2.98350154e+01 -1.79381284e+00 -6.50640206e-01]]\n[[ 4.87524241e-06 -7.05716139e-06 -4.57929038e-08]\n [-2.23216589e-02 -2.15720711e-02  2.85519283e-04]\n [ 2.03406835e-03 -2.02082863e-02 -3.94564043e-04]\n [-1.72300122e-02 -2.96772137e-03  6.38154172e-07]\n [ 1.42483227e-02 -1.57923621e-03 -3.82372338e-04]\n [-5.47097051e-03  5.64248731e-03  9.89618477e-05]\n [ 1.82201399e-03  5.14347040e-03 -1.61723649e-04]\n [-3.09761521e-03  2.27678190e-03  4.86042739e-05]\n [ 1.67653809e-04  3.15209870e-03 -6.87750693e-05]]\n[1.00000000e+00 1.66012083e-07 2.44783829e-06 3.00348962e-06\n 3.22715608e-07 9.54791910e-04 2.85885670e-04 4.36624961e-05\n 5.15138377e-05]\n</pre> In\u00a0[3]: Copied! <pre># Remove Jupiter\n# system.remove(particle_ids=5)\n\n# Add a new particle (you could also add multiple particles at once)\nx = np.array([-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02])\nv = np.array(\n    [\n        -1.017876585480054e-02,\n        -5.452367109338154e-04,\n        1.255870551153315e-03,\n    ]\n)\nm = 1.30268459e-10\nsystem.add(x, v, m)\n\n# Add a new particle using Keplerian elements\nsystem.add_keplerian(\n    semi_major_axis=4.2,\n    eccentricity=0.1,\n    inclination=0.1,\n    longitude_of_ascending_node=1.0,\n    argument_of_periapsis=1.0,\n    true_anomaly=1.0,\n    m=1.5e-9,\n    primary_particle_id=0,\n)\n\nsystem.center_of_mass_correction()\n\nprint(system.particle_ids)\nprint(system.x)\n</pre> # Remove Jupiter # system.remove(particle_ids=5)  # Add a new particle (you could also add multiple particles at once) x = np.array([-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02]) v = np.array(     [         -1.017876585480054e-02,         -5.452367109338154e-04,         1.255870551153315e-03,     ] ) m = 1.30268459e-10 system.add(x, v, m)  # Add a new particle using Keplerian elements system.add_keplerian(     semi_major_axis=4.2,     eccentricity=0.1,     inclination=0.1,     longitude_of_ascending_node=1.0,     argument_of_periapsis=1.0,     true_anomaly=1.0,     m=1.5e-9,     primary_particle_id=0, )  system.center_of_mass_correction()  print(system.particle_ids) print(system.x) <pre>[ 0  1  2  3  4  5  6  7  8  9 10]\n[[-7.96712240e-03 -2.90611281e-03  2.10212592e-04]\n [-2.82597494e-01  1.97456094e-01  4.17742427e-02]\n [-7.23209537e-01 -7.94829056e-02  4.04286214e-02]\n [-1.73818368e-01  9.66324670e-01  1.55297348e-04]\n [-3.01325406e-01 -1.45402922e+00 -2.30054072e-02]\n [ 3.48520330e+00  3.55213702e+00 -9.27104473e-02]\n [ 8.98810506e+00 -3.71906474e+00 -2.93193871e-01]\n [ 1.22630250e+01  1.52973880e+01 -1.02054996e-01]\n [ 2.98350154e+01 -1.79381284e+00 -6.50640206e-01]\n [-8.09254907e-02  2.55838143e+00 -6.69583620e-02]\n [-3.89826791e+00  5.44109952e-01  3.58317628e-01]]\n</pre> In\u00a0[4]: Copied! <pre>tmp_path = Path(os.getcwd()) / \"customized_systems.csv\"\n\nsystem.save(tmp_path)\n\n# You can also load customized system from csv files\nsystem = gs.load_system(tmp_path)\n</pre> tmp_path = Path(os.getcwd()) / \"customized_systems.csv\"  system.save(tmp_path)  # You can also load customized system from csv files system = gs.load_system(tmp_path) <pre>System successfully saved to \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/customized_systems.csv\"\n</pre> In\u00a0[5]: Copied! <pre>system.plot_3d_system()\n</pre> system.plot_3d_system() In\u00a0[6]: Copied! <pre>tf = gs.years_to_days(1000.0)  # The default units is AU, solar mass, and days\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"leapfrog\"\nintegrator_param.dt = 0.1\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 2000.0\n</pre> tf = gs.years_to_days(1000.0)  # The default units is AU, solar mass, and days  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"leapfrog\" integrator_param.dt = 0.1  output_param.method = \"csv\" output_param.output_interval = tf / 2000.0 In\u00a0[7]: Copied! <pre>gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf)\n</pre> gs.launch_simulation(system, acc_param, integrator_param, output_param, settings, tf) <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.1\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: false\n  Compiled with FFTW3: false\n\nBuild time: Apr 11 2025 11:49:33\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 365242\n\nSystem:\n  Number of particles: 11\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: Leapfrog\n  dt: 0.1\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\n  Output initial condition: true\n  Output interval: 182.621\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501   0% \u2022 00:00:00 \u2022 00:00:00</pre> <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\".\n</pre> <pre>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:00:02 \u2022 00:00:00\n</pre> In\u00a0[8]: Copied! <pre>G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\nprint(f\"Data size = {len(sol_state)}\")\nprint(G)\nprint(sol_time.shape)\nprint(sol_dt.shape)\nprint(sol_particle_ids.shape)\nprint(sol_state.shape)\n</pre> G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir ) print(f\"Data size = {len(sol_state)}\") print(G) print(sol_time.shape) print(sol_dt.shape) print(sol_particle_ids.shape) print(sol_state.shape) <pre>Data size = 2000\n0.0002959122082841195\n(2000,)\n(2000,)\n(11,)\n(2000, 11, 7)\n</pre> In\u00a0[9]: Copied! <pre>gs.plot_2d_trajectory(\n    sol_state,\n    colors=[\n        \"orange\",\n        \"slategrey\",\n        \"wheat\",\n        \"skyblue\",\n        \"red\",\n        \"darkgoldenrod\",\n        \"gold\",\n        \"paleturquoise\",\n        \"blue\",\n        None,\n        None,\n    ],\n    labels=[\n        \"Sun\",\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n        \"Custom1\",\n        \"Custom2\",\n    ],\n    legend=True,\n)\n</pre> gs.plot_2d_trajectory(     sol_state,     colors=[         \"orange\",         \"slategrey\",         \"wheat\",         \"skyblue\",         \"red\",         \"darkgoldenrod\",         \"gold\",         \"paleturquoise\",         \"blue\",         None,         None,     ],     labels=[         \"Sun\",         \"Mercury\",         \"Venus\",         \"Earth\",         \"Mars\",         \"Jupiter\",         \"Saturn\",         \"Uranus\",         \"Neptune\",         \"Custom1\",         \"Custom2\",     ],     legend=True, ) In\u00a0[10]: Copied! <pre>sol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[11]: Copied! <pre>sol_linear_momentum = gs.compute_linear_momentum(sol_state)\ngs.plot_rel_linear_momentum_error(\n    sol_linear_momentum=sol_linear_momentum,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> sol_linear_momentum = gs.compute_linear_momentum(sol_state) gs.plot_rel_linear_momentum_error(     sol_linear_momentum=sol_linear_momentum,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[12]: Copied! <pre>sol_angular_momentum = gs.compute_angular_momentum(sol_state)\ngs.plot_rel_angular_momentum_error(\n    sol_angular_momentum=sol_angular_momentum,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> sol_angular_momentum = gs.compute_angular_momentum(sol_state) gs.plot_rel_angular_momentum_error(     sol_angular_momentum=sol_angular_momentum,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[13]: Copied! <pre>gs.plot_quantity_against_time(\n    quantity=sol_dt[1:],\n    is_log_y=True,\n    sol_time=gs.days_to_years(sol_time[1:]),\n    xlabel=\"Time (years)\",\n    ylabel=\"dt\",\n)\n</pre> gs.plot_quantity_against_time(     quantity=sol_dt[1:],     is_log_y=True,     sol_time=gs.days_to_years(sol_time[1:]),     xlabel=\"Time (years)\",     ylabel=\"dt\", ) <p>Delete the snapshot data</p> In\u00a0[14]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir) In\u00a0[15]: Copied! <pre>### Crate system ###\nIAS15_system = gs.get_built_in_system(\"pyth-3-body\")\n\n\n### Set parameters ###\ntf = 70.0  # The default units is AU, solar mass, and days\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"ias15\"\nintegrator_param.tolerance = 1e-9\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 2000.0\n\n### Launch simulation ###\ngs.launch_simulation(\n    IAS15_system, acc_param, integrator_param, output_param, settings, tf\n)\n</pre> ### Crate system ### IAS15_system = gs.get_built_in_system(\"pyth-3-body\")   ### Set parameters ### tf = 70.0  # The default units is AU, solar mass, and days  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"ias15\" integrator_param.tolerance = 1e-9  output_param.method = \"csv\" output_param.output_interval = tf / 2000.0  ### Launch simulation ### gs.launch_simulation(     IAS15_system, acc_param, integrator_param, output_param, settings, tf ) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.1\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: false\n  Compiled with FFTW3: false\n\nBuild time: Apr 11 2025 11:49:33\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 70\n\nSystem:\n  Number of particles: 3\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: IAS15\n  Tolerance: 1e-09\n  Initial dt (if applicable): -1\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\n  Output initial condition: true\n  Output interval: 0.035\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:00:00 \u2022 00:00:00\n</pre> <p>Plot the results</p> In\u00a0[16]: Copied! <pre>### Read results ###\nG, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\nprint(f\"Data size = {len(sol_state)}\")\n\n### Plot results ###\nprint(\"Trajectory:\")\ngs.plot_2d_trajectory(sol_state)  # Trajectory\n\nprint(\"dt:\")\ngs.plot_quantity_against_time(\n    quantity=sol_dt[1:],\n    is_log_y=True,\n    sol_time=gs.days_to_years(sol_time[1:]),\n    xlabel=\"Time (years)\",\n    ylabel=\"dt\",\n)\n\n# Delete snapshots\ngs.delete_snapshots(output_dir=output_param.output_dir)\n</pre> ### Read results ### G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir ) print(f\"Data size = {len(sol_state)}\")  ### Plot results ### print(\"Trajectory:\") gs.plot_2d_trajectory(sol_state)  # Trajectory  print(\"dt:\") gs.plot_quantity_against_time(     quantity=sol_dt[1:],     is_log_y=True,     sol_time=gs.days_to_years(sol_time[1:]),     xlabel=\"Time (years)\",     ylabel=\"dt\", )  # Delete snapshots gs.delete_snapshots(output_dir=output_param.output_dir) <pre>Data size = 2001\nTrajectory:\n</pre> <pre>dt:\n</pre> <p>Let us try the solution again with RK4 with $\\textrm{d} t = 10^{-5}$.</p> <p>(As mentioned above, it would only work if $\\textrm{d} t = 2 \\times 10^{-8}$.)</p> In\u00a0[17]: Copied! <pre>### Crate system ###\nRK4_system = gs.get_built_in_system(\"pyth-3-body\")\n\n### Set parameters ###\ntf = 70.0  # The default units is AU, solar mass, and days\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"rk4\"\nintegrator_param.dt = 1e-5\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 2000.0\n\n### Launch simulation ###\ngs.launch_simulation(\n    RK4_system, acc_param, integrator_param, output_param, settings, tf\n)\n</pre> ### Crate system ### RK4_system = gs.get_built_in_system(\"pyth-3-body\")  ### Set parameters ### tf = 70.0  # The default units is AU, solar mass, and days  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"rk4\" integrator_param.dt = 1e-5  output_param.method = \"csv\" output_param.output_interval = tf / 2000.0  ### Launch simulation ### gs.launch_simulation(     RK4_system, acc_param, integrator_param, output_param, settings, tf ) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.1\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: false\n  Compiled with FFTW3: false\n\nBuild time: Apr 11 2025 11:49:33\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 70\n\nSystem:\n  Number of particles: 3\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: RK4\n  dt: 1e-05\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\n  Output initial condition: true\n  Output interval: 0.035\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:00:02 \u2022 00:00:00\n</pre> In\u00a0[18]: Copied! <pre>### Read results ###\nG, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\nprint(f\"Data size = {len(sol_state)}\")\n\n### Plot results ###\nprint(\"Trajectory:\")\ngs.plot_2d_trajectory(sol_state)  # Trajectory\n\nprint(\"dt:\")\ngs.plot_quantity_against_time(\n    quantity=sol_dt[1:],\n    is_log_y=True,\n    sol_time=gs.days_to_years(sol_time[1:]),\n    xlabel=\"Time (years)\",\n    ylabel=\"dt\",\n)\n\n# Delete snapshots\ngs.delete_snapshots(output_dir=output_param.output_dir)\n</pre> ### Read results ### G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir ) print(f\"Data size = {len(sol_state)}\")  ### Plot results ### print(\"Trajectory:\") gs.plot_2d_trajectory(sol_state)  # Trajectory  print(\"dt:\") gs.plot_quantity_against_time(     quantity=sol_dt[1:],     is_log_y=True,     sol_time=gs.days_to_years(sol_time[1:]),     xlabel=\"Time (years)\",     ylabel=\"dt\", )  # Delete snapshots gs.delete_snapshots(output_dir=output_param.output_dir) <pre>Data size = 2001\nTrajectory:\n</pre> <pre>dt:\n</pre> In\u00a0[19]: Copied! <pre>WHFast_system = gs.get_built_in_system(\"solar_system\")\n\ntf = gs.years_to_days(1000.0)  # The default units is AU, solar mass, and days\n\nacc_param, integrator_param, output_param, settings = gs.get_new_parameters()\nintegrator_param.integrator = \"whfast\"\nintegrator_param.dt = 5.0\n\noutput_param.method = \"csv\"\noutput_param.output_interval = tf / 2000.0\n\n### Launch simulation ###\ngs.launch_simulation(\n    WHFast_system, acc_param, integrator_param, output_param, settings, tf\n)\n</pre> WHFast_system = gs.get_built_in_system(\"solar_system\")  tf = gs.years_to_days(1000.0)  # The default units is AU, solar mass, and days  acc_param, integrator_param, output_param, settings = gs.get_new_parameters() integrator_param.integrator = \"whfast\" integrator_param.dt = 5.0  output_param.method = \"csv\" output_param.output_interval = tf / 2000.0  ### Launch simulation ### gs.launch_simulation(     WHFast_system, acc_param, integrator_param, output_param, settings, tf ) <pre>Warning: In \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/src/output.c\", line 231 in finalize_output_param:\n    Directory for storing snapshots already exists. The files will be overwritten. Directory: \"/Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\".\n</pre> <pre>-----------------------------------------------------------------\n                                              __                   \n    __   _ __    __     __  __           ____/\\_\\    ___ ___       \n  /'_ `\\/\\`'__\\/'__`\\  /\\ \\/\\ \\         /',__\\/\\ \\ /' __` __`\\     \n /\\ \\L\\ \\ \\ \\//\\ \\L\\.\\_\\ \\ \\_/ |       /\\__, `\\ \\ \\/\\ \\/\\ \\/\\ \\    \n \\ \\____ \\ \\_\\\\ \\__/.\\_\\\\ \\___/        \\/\\____/\\ \\_\\ \\_\\ \\_\\ \\_\\   \n  \\/___L\\ \\/_/ \\/__/\\/_/ \\/__/   _______\\/___/  \\/_/\\/_/\\/_/\\/_/   \n    /\\____/                     /\\______\\                          \n    \\_/__/                      \\/______/                          \n\n\ngrav_sim version 0.0.1\n\nOperating System: MacOS\nCompilation Info:\n  Compiled with OpenMP: false\n  Compiled with HDF5: false\n  Compiled with FFTW3: false\n\nBuild time: Apr 11 2025 11:49:33\nCompiler: Clang (version: 15)\n-----------------------------------------------------------------\nSimulation parameters:\n  tf: 365242\n\nSystem:\n  Number of particles: 9\n  Gravitational constant: 0.000295912\n\nIntegrator parameters:\n  Integrator: WHFAST\n  dt: 5\n  WHFast remove invalid particles: true\n\nAcceleration parameters:\n  Acceleration method: Pairwise\n  Softening length: 0\n\nOutput parameters:\n  Output method: CSV\n  Output directory: /Users/alvinng/Desktop/cuhk/gravity-simulator/Final Project/gravity-simulator/examples/tmp/\n  Output initial condition: true\n  Output interval: 182.621\n  Coordinate output data type: double\n  Velocity output data type: double\n  Mass output data type: double\n\nSettings:\n  Verbose: Normal\n  Enable progress bar: true\n-----------------------------------------------------------------\nLaunching simulation...\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% \u2022 00:00:00 \u2022 00:00:00\n</pre> In\u00a0[20]: Copied! <pre>### Read results ###\nG, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(\n    output_param.output_dir\n)\nprint(f\"Data size = {len(sol_state)}\")\n\n### Plot results ###\nprint(\"Trajectory:\")\ngs.plot_2d_trajectory(\n    sol_state,\n    colors=[\n        \"orange\",\n        \"slategrey\",\n        \"wheat\",\n        \"skyblue\",\n        \"red\",\n        \"darkgoldenrod\",\n        \"gold\",\n        \"paleturquoise\",\n        \"blue\",\n        None,\n        None,\n    ],\n    labels=[\n        \"Sun\",\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n        \"Custom1\",\n        \"Custom2\",\n    ],\n    legend=True,\n)  # Trajectory\n</pre> ### Read results ### G, sol_time, sol_dt, sol_particle_ids, sol_state = gs.read_csv_data(     output_param.output_dir ) print(f\"Data size = {len(sol_state)}\")  ### Plot results ### print(\"Trajectory:\") gs.plot_2d_trajectory(     sol_state,     colors=[         \"orange\",         \"slategrey\",         \"wheat\",         \"skyblue\",         \"red\",         \"darkgoldenrod\",         \"gold\",         \"paleturquoise\",         \"blue\",         None,         None,     ],     labels=[         \"Sun\",         \"Mercury\",         \"Venus\",         \"Earth\",         \"Mars\",         \"Jupiter\",         \"Saturn\",         \"Uranus\",         \"Neptune\",         \"Custom1\",         \"Custom2\",     ],     legend=True, )  # Trajectory <pre>Data size = 2000\nTrajectory:\n</pre> In\u00a0[21]: Copied! <pre>sol_energy = gs.compute_energy(sol_state, G)\ngs.plot_rel_energy_error(\n    sol_energy=sol_energy,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> sol_energy = gs.compute_energy(sol_state, G) gs.plot_rel_energy_error(     sol_energy=sol_energy,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[22]: Copied! <pre>sol_linear_momentum = gs.compute_linear_momentum(sol_state)\ngs.plot_rel_linear_momentum_error(\n    sol_linear_momentum=sol_linear_momentum,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> sol_linear_momentum = gs.compute_linear_momentum(sol_state) gs.plot_rel_linear_momentum_error(     sol_linear_momentum=sol_linear_momentum,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[23]: Copied! <pre>sol_angular_momentum = gs.compute_angular_momentum(sol_state)\ngs.plot_rel_angular_momentum_error(\n    sol_angular_momentum=sol_angular_momentum,\n    sol_time=gs.days_to_years(sol_time),\n    xlabel=\"Time (years)\",\n)\n</pre> sol_angular_momentum = gs.compute_angular_momentum(sol_state) gs.plot_rel_angular_momentum_error(     sol_angular_momentum=sol_angular_momentum,     sol_time=gs.days_to_years(sol_time),     xlabel=\"Time (years)\", ) In\u00a0[24]: Copied! <pre>gs.delete_snapshots(output_dir=output_param.output_dir)\n</pre> gs.delete_snapshots(output_dir=output_param.output_dir)"},{"location":"examples/tutorial/#tutorial","title":"Tutorial\u00b6","text":"<p>A simple tutorial for using the grav_sim API.</p>"},{"location":"examples/tutorial/#import-libraries","title":"Import libraries\u00b6","text":"<p>First, we import some libraries. If the path is wrong, please correct it manually.</p>"},{"location":"examples/tutorial/#getting-built-in-systems","title":"Getting built-in systems\u00b6","text":""},{"location":"examples/tutorial/#adding-removing-particles","title":"Adding / removing particles\u00b6","text":"<p>Note that the default units are solar masses, AU and days</p>"},{"location":"examples/tutorial/#save-load-system","title":"Save / Load system\u00b6","text":""},{"location":"examples/tutorial/#plotting-initial-conditions","title":"Plotting initial conditions\u00b6","text":""},{"location":"examples/tutorial/#launching-simulation","title":"Launching simulation\u00b6","text":""},{"location":"examples/tutorial/#plotting-trajectories","title":"Plotting trajectories\u00b6","text":""},{"location":"examples/tutorial/#more-plots","title":"More plots\u00b6","text":""},{"location":"examples/tutorial/#adaptive-step-size-integrators","title":"Adaptive step size integrators\u00b6","text":"<p>When using adaptive step size integrators, we provide tolerance rather than $\\text{d}t$ to control the step size.</p> Adaptive step size integrators Recommended tolerance* Runge\u2013Kutta\u2013Fehlberg 4(5) $10^{-8}$ to $10^{-14}$ Dormand\u2013Prince method (DOPRI) 5(4) $10^{-8}$ to $10^{-14}$ Verner's method (DVERK) 6(5) $10^{-8}$ to $10^{-14}$ Runge\u2013Kutta\u2013Fehlberg 7(8) $10^{-4}$ to $10^{-8}$ IAS15 $10^{-9}$ <p>*For reference only</p> <p>Using pyth-3-body, a highly chaotic system, we can easily see the difference between adaptive step size integrators and fixed step size integrators.</p> <p>For RK4, the largest $\\text{d}t$ we can use for this system is 2e-8.</p>"},{"location":"examples/tutorial/#whfast","title":"WHFast\u00b6","text":"<p>WHFast is a symplectic integrator. It is very useful for central mass systems, such as the solar system. Even when using a relatively large dt like 5 days, it can still return a adequate result, given that there are no close encounters and the eccentricities are low.</p>"},{"location":"examples/tutorial/#plot-the-results","title":"Plot the results\u00b6","text":""},{"location":"examples/tutorial/#end","title":"END\u00b6","text":"<p>This is the end of the tutorial. Enjoy building your own projects with grav_sim!</p>"},{"location":"examples/asteroid_belt_animation/asteroid_belt/","title":"Asteroid belt animation","text":"Source code (Click to expand) examples/asteroid_belt_animation/python/asteroid_belt.py<pre><code>\"\"\"\nDemonstration on using the gravity simulator to simulate the asteroid belt.\n\nNote:   1. You will need two more packages to run this script. The first one is Pillow,\n           which is used to create the gif. The second one is rich, which is used to show\n           the progress bar. You can avoid using rich simply by removing the \"track\" function\n           in the for loops.\n        2. Technically you can also create nice looking solar system animations by setting N = 0 and\n           expanding the axes limits.\n        3. We are using \"massless\" acceleration method because we are considering\n           a short time frame, so the gravitational effects from the asteroids are negligible.\n           (Even if you were to include the gravitational effect from the asteroids, it would be\n           smaller than the round-off error, so it is not worth the effort.)\n\nWarning: Do not run multiple instances of this program at the same time, unless you made copies\n         of the whole directory. Otherwise, the final data may overwrite each other.\n\nAuthor: Ching-Yin Ng\n\"\"\"\n\nimport glob\nfrom pathlib import Path\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport PIL\nfrom grav_sim import GravitySimulatorAPI\nfrom rich.progress import track\n\n\n# Option 0: asteroid belt\n# Option 1: add a star near the asteroid belt\n# Option 2: same as option 1 but different position\nOPTION = 1\n\nN = 50000\nFPS = 30\nDPI = 200\nN_FRAMES = 500\n\nTF = 5.0  # Number of years\nDT = 0.1  # Time step in days\n\nACC_METHOD = \"massless\"\nINTEGRATOR = \"rk4\"\n\nOUTPUT_INITIAL = False\nSNAPSHOTS_DIR = Path(\"snapshots/\")\nSNAPSHOTS_DIR.mkdir(parents=True, exist_ok=True)\n\nFRAMES_DIR = Path(\"frames/\")\nFRAMES_DIR.mkdir(parents=True, exist_ok=True)\n\nDELETE_SNAPSHOTS = True  # Delete snapshots after creating the gif\n\n\ndef main():\n    # ---------- Initialization ---------- #\n    print(\"Initializing the system...\", end=\"\")\n\n    gs = GravitySimulatorAPI()\n\n    system = gs.get_built_in_system(\"solar_system\")\n    system.remove([1, 7, 8])  # Remove Mercury, Uranus, and Neptune\n    objects_name = [\"Sun\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    colors = [gs.SOLAR_SYSTEM_COLORS[name] for name in objects_name]\n    marker_sizes = [6.0, 1.5, 2.0, 1.5, 4.0, 3.5]\n\n    #################################################\n    # Adding a star to the system\n\n    if OPTION == 1:\n        system.add_keplerian(\n            semi_major_axis=5.5,\n            eccentricity=0.7,\n            inclination=0.05,\n            argument_of_periapsis=0.07,\n            longitude_of_ascending_node=0.07,\n            true_anomaly=0.35,\n            m=1.0,\n            primary_particle_id=0,\n        )\n        objects_name.append(\"Star 1\")\n        colors.append(\"orange\")\n        marker_sizes.append(6.0)\n\n    elif OPTION == 2:\n        system.add_keplerian(\n            semi_major_axis=5.0,\n            eccentricity=0.7,\n            inclination=0.4,\n            argument_of_periapsis=4.0,\n            longitude_of_ascending_node=4.0,\n            true_anomaly=4.0,\n            m=1.0,\n            primary_particle_id=0,\n        )\n        objects_name.append(\"Star 1\")\n        colors.append(\"orange\")\n        marker_sizes.append(6.0)\n\n    #################################################\n\n    massive_objects_count = system.num_particles\n\n    rng = np.random.default_rng()\n    a = rng.uniform(2.1, 3.2, size=N)\n    ecc = np.abs(rng.normal(loc=0.0, scale=0.12, size=N))\n    inc = np.abs(rng.normal(loc=0.0, scale=0.3, size=N))\n    argument_of_periapsis = rng.uniform(0, 2 * np.pi, size=N)\n    long_asc_node = rng.uniform(0, 2 * np.pi, size=N)\n    true_anomaly = rng.uniform(0, 2 * np.pi, size=N)\n\n    # m = 0.0 if we assume asteroids are massless\n    for i in range(N):\n        system.add_keplerian(\n            semi_major_axis=a[i],\n            eccentricity=ecc[i],\n            inclination=inc[i],\n            argument_of_periapsis=argument_of_periapsis[i],\n            longitude_of_ascending_node=long_asc_node[i],\n            true_anomaly=true_anomaly[i],\n            m=0.0,\n            primary_particle_id=0,\n        )\n\n    system.center_of_mass_correction()\n    print(\"Done!\")\n\n    # ---------- Simulation ---------- #\n    tf = gs.years_to_days(TF)\n\n    acc_param, integrator_param, output_param, settings = gs.get_new_parameters()\n    acc_param.method = ACC_METHOD\n\n    integrator_param.integrator = INTEGRATOR\n    integrator_param.dt = 0.1\n\n    output_param.method = \"csv\"\n    output_param.output_interval = tf / N_FRAMES\n    output_param.output_initial = OUTPUT_INITIAL\n    output_param.output_dir = SNAPSHOTS_DIR\n\n    gs.launch_simulation(\n        system, acc_param, integrator_param, output_param, settings, tf\n    )\n\n    # ---------- Animation ---------- #\n    print(\"Drawing frames...\", end=\"\")\n\n    snapshot_files = sorted(glob.glob(str(SNAPSHOTS_DIR / \"snapshot_*.csv\")))\n    actual_n_frames = len(snapshot_files)\n    if actual_n_frames == 0:\n        raise ValueError(f\"No snapshot files found at {SNAPSHOTS_DIR}.\")\n    else:\n        print(f\"Found {actual_n_frames} snapshot files.\")\n\n    # We can't use the library function to read all\n    # data in the memory as it is too large.\n    # We have to read them manually one by one.\n    for i in track(range(actual_n_frames)):\n        snapshot_file = snapshot_files[i]\n        data = np.genfromtxt(snapshot_file, delimiter=\",\", skip_header=5)\n        x = data[:, 2:5]\n\n        fig = plt.figure()\n        plt.style.use(\"dark_background\")\n        ax = fig.add_subplot(111, projection=\"3d\")\n\n        xlim_min = -3\n        xlim_max = 3\n        ylim_min = -3\n        ylim_max = 3\n        zlim_min = -3\n        zlim_max = 3\n\n        ax.grid(False)\n        ax.xaxis.set_pane_color((0.0, 0.0, 0.0, 0.0))\n        ax.yaxis.set_pane_color((0.0, 0.0, 0.0, 0.0))\n        ax.zaxis.set_pane_color((0.0, 0.0, 0.0, 0.0))\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_zticks([])\n        ax.xaxis.set_visible(False)\n        ax.yaxis.set_visible(False)\n        ax.zaxis.set_visible(False)\n        ax.xaxis.line.set_color((1.0, 1.0, 1.0, 0.0))\n        ax.yaxis.line.set_color((1.0, 1.0, 1.0, 0.0))\n        ax.zaxis.line.set_color((1.0, 1.0, 1.0, 0.0))\n\n        # Plotting massive objects\n        for j in range(massive_objects_count):\n            ax.scatter(\n                x[j, 0],\n                x[j, 1],\n                x[j, 2],\n                marker=\"o\",\n                label=objects_name[j],\n                color=colors[j],\n                s=marker_sizes[j],\n            )\n\n        # Plotting massless objects\n        ax.scatter(\n            x[massive_objects_count:, 0],\n            x[massive_objects_count:, 1],\n            x[massive_objects_count:, 2],\n            color=\"white\",\n            marker=\".\",\n            s=0.1,\n            alpha=0.2,\n        )\n\n        # Add legend\n        legend = ax.legend(loc=\"center right\", bbox_to_anchor=(1.325, 0.5))\n        legend.facecolor = \"transparent\"\n\n        # Adjust figure for the legend\n        fig.subplots_adjust(right=0.7)\n        fig.tight_layout()\n\n        # Set axis labels and setting 3d axes scale before capturing the frame\n        # ax.set_xlabel(\"$x$ (AU)\")\n        # ax.set_ylabel(\"$y$ (AU)\")\n        # ax.set_zlabel(\"$z$ (AU)\")\n\n        ax.set_xlim3d([xlim_min, xlim_max])\n        ax.set_ylim3d([ylim_min, ylim_max])\n        ax.set_zlim3d([zlim_min, zlim_max])\n\n        # Set equal aspect ratio to prevent distortion\n        ax.set_aspect(\"equal\")\n\n        # Capture the frame\n        plt.savefig(FRAMES_DIR / f\"frames_{i:04d}.png\", dpi=DPI)\n        plt.close(\"all\")\n    plt.close(\"all\")\n\n    print()\n    print(\"Combining frames to gif...\")\n\n    def frames_generator():\n        for i in range(actual_n_frames):\n            yield PIL.Image.open(FRAMES_DIR / f\"frames_{i:04d}.png\")\n\n    frames = frames_generator()\n    next(frames).save(\n        FRAMES_DIR / \"asteroid_belt.gif\",\n        save_all=True,\n        append_images=frames,\n        loop=0,\n        duration=(1000 // FPS),\n    )\n\n    for i in range(actual_n_frames):\n        (FRAMES_DIR / f\"frames_{i:04d}.png\").unlink()\n\n    print(f\"Output completed! Please check {FRAMES_DIR / 'asteroid_belt.gif'}\")\n    print()\n\n    if DELETE_SNAPSHOTS:\n        gs.delete_snapshots(output_dir=SNAPSHOTS_DIR)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>In this project, we will simulate the asteroid belt in the solar system by adding 50000 particles using the <code>system.add_keplerian</code> method. We also provide 3 options:</p> <ul> <li><code>0</code>: asteroids only</li> <li><code>1</code>: Add a star near the asteroid belt</li> <li><code>2</code>: Same as <code>1</code> but different position</li> </ul> <p>Because the simulation only consider short time scale, </p> <ul> <li>RK4 is chosen for higher accuracy</li> <li>Gravity due to the asteroids are ignored</li> </ul> <p>To draw animation, we use matplotlib to draw the frames, then use PIL to convert the frames to a gif file.</p>"},{"location":"examples/asteroid_belt_animation/asteroid_belt/#gallery","title":"Gallery","text":""},{"location":"examples/cosmic_structure/cosmic_structure/","title":"Cosmic Structure Formation","text":"Source code in C (Click to expand) examples/cosmic_structure/c/cosmic_structure.c<pre><code>#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;hdf5.h&gt;\n\n#include \"grav_sim.h\"\n\n#define INIT_CONDITION_FILE \"../../ics_swift.hdf5\"\n#define A_FINAL 1.0 // Scale factor at the end of simulation\n#define NUM_STEPS 1000\n\nErrorStatus read_init_condition(\n    CosmologicalSystem *__restrict system,\n    int *__restrict pm_grid_size\n);\n\nint main(void)\n{\n    CosmologicalSystem system;\n    int pm_grid_size;\n    ErrorStatus error_status = WRAP_TRACEBACK(read_init_condition(\n        &amp;system,\n        &amp;pm_grid_size\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto error;\n    }\n\n    /* Output parameters */\n    OutputParam output_param = get_new_output_param();\n    output_param.method = OUTPUT_METHOD_HDF5;\n    output_param.output_dir = \"snapshots/\";\n    output_param.output_interval = (A_FINAL - system.scale_factor) / 100.0;\n    output_param.output_initial = true;\n    output_param.coordinate_output_dtype = OUTPUT_DTYPE_FLOAT;\n    output_param.velocity_output_dtype = OUTPUT_DTYPE_FLOAT;\n    output_param.mass_output_dtype = OUTPUT_DTYPE_FLOAT;\n\n    /* Simulation status */\n    SimulationStatus simulation_status;\n\n    /* Settings */\n    Settings settings = get_new_settings();\n    settings.verbose = GRAV_VERBOSITY_NORMAL;\n\n    int return_code = launch_cosmological_simulation(\n        &amp;system,\n        &amp;output_param,\n        &amp;simulation_status,\n        &amp;settings,\n        A_FINAL,\n        NUM_STEPS,\n        pm_grid_size\n    );\n    if (return_code != 0)\n    {\n        free_cosmological_system(&amp;system);\n        error_status = WRAP_RAISE_ERROR(\n            GRAV_FAILURE,\n            \"Simulation failed.\"\n        );\n        goto error;\n    }\n\n    /* Free memory */\n    free_cosmological_system(&amp;system);\n\n    return 0;\n\nerror:\n    print_and_free_traceback(&amp;error_status);\n    return 1;\n}\n\nErrorStatus read_init_condition(\n    CosmologicalSystem *__restrict system,\n    int *__restrict pm_grid_size\n)\n{\n    ErrorStatus error_status;\n\n    /* Open file */\n    hid_t file = H5Fopen(INIT_CONDITION_FILE, H5F_ACC_RDONLY, H5P_DEFAULT);\n    if (file == H5I_INVALID_HID)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open initial condition file\");\n        goto err_open_file;\n    }\n\n    /* Open groups */\n    hid_t header = H5Gopen(file, \"/Header\", H5P_DEFAULT);\n    hid_t units = H5Gopen(file, \"/Units\", H5P_DEFAULT);\n    hid_t part_type_1 = H5Gopen(file, \"/PartType1\", H5P_DEFAULT);\n    if (header == H5I_INVALID_HID\n        || units == H5I_INVALID_HID\n        || part_type_1 == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open groups in initial condition file\");\n        goto err_open_group;\n    }\n\n    /* Read header attributes */\n    hid_t num_particles_attr = H5Aopen(header, \"NumPart_ThisFile\", H5P_DEFAULT);\n    hid_t box_size_attr = H5Aopen(header, \"BoxSize\", H5P_DEFAULT);\n    hid_t grid_size_attr = H5Aopen(header, \"suggested_pmgrid\", H5P_DEFAULT);\n    hid_t omega_m_attr = H5Aopen(header, \"Omega0\", H5P_DEFAULT);\n    hid_t omega_lambda_attr = H5Aopen(header, \"OmegaLambda\", H5P_DEFAULT);\n    hid_t redshift_attr = H5Aopen(header, \"Redshift\", H5P_DEFAULT);\n    hid_t h_attr = H5Aopen(header, \"HubbleParam\", H5P_DEFAULT);\n    hid_t mass_table_attr = H5Aopen(header, \"MassTable\", H5P_DEFAULT);\n    if (\n        num_particles_attr == H5I_INVALID_HID\n        || box_size_attr == H5I_INVALID_HID\n        || grid_size_attr == H5I_INVALID_HID\n        || omega_m_attr == H5I_INVALID_HID\n        || omega_lambda_attr == H5I_INVALID_HID\n        || redshift_attr == H5I_INVALID_HID\n        || h_attr == H5I_INVALID_HID\n        || mass_table_attr == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open attributes in header\");\n        goto err_header_attr;\n    }\n\n    uint32_t temp_num_particles_arr[6];\n    if (H5Aread(num_particles_attr, H5T_NATIVE_UINT32, &amp;temp_num_particles_arr) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read number of particles from header\");\n        goto err_header_attr;\n    }\n    double box_size;\n    if (H5Aread(box_size_attr, H5T_NATIVE_DOUBLE, &amp;box_size) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read box size from header\");\n        goto err_header_attr;\n    }\n    uint32_t temp_grid_size;\n    if (H5Aread(grid_size_attr, H5T_NATIVE_UINT32, &amp;temp_grid_size) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read grid size from header\");\n        goto err_header_attr;\n    }\n    *pm_grid_size = temp_grid_size;\n\n    double omega_m;\n    if (H5Aread(omega_m_attr, H5T_NATIVE_DOUBLE, &amp;omega_m) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read omega_m from header\");\n        goto err_header_attr;\n    }\n    double omega_lambda;\n    if (H5Aread(omega_lambda_attr, H5T_NATIVE_DOUBLE, &amp;omega_lambda) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read omega_lambda from header\");\n        goto err_header_attr;\n    }\n    double redshift;\n    if (H5Aread(redshift_attr, H5T_NATIVE_DOUBLE, &amp;redshift) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read redshift from header\");\n        goto err_header_attr;\n    }\n    double h;\n    if (H5Aread(h_attr, H5T_NATIVE_DOUBLE, &amp;h) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read Hubble parameter from header\");\n        goto err_header_attr;\n    }\n\n    error_status = WRAP_TRACEBACK(get_initialized_cosmological_system(\n        system,\n        temp_num_particles_arr[1]\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto err_initialize_system;\n    }\n    system-&gt;box_width = box_size / 2.0;\n    system-&gt;box_center[0] = system-&gt;box_width;\n    system-&gt;box_center[1] = system-&gt;box_width;\n    system-&gt;box_center[2] = system-&gt;box_width;\n    system-&gt;scale_factor = 1.0 / (redshift + 1.0);\n    system-&gt;omega_m = omega_m;\n    system-&gt;omega_lambda = omega_lambda;\n    system-&gt;h = h;\n\n    /* Read units attributes */\n    hid_t unit_length_attr = H5Aopen(units, \"Unit length in cgs (U_L)\", H5P_DEFAULT);\n    hid_t unit_mass_attr = H5Aopen(units, \"Unit mass in cgs (U_M)\", H5P_DEFAULT);\n    hid_t unit_time_attr = H5Aopen(units, \"Unit time in cgs (U_t)\", H5P_DEFAULT);\n\n    if (\n        unit_length_attr == H5I_INVALID_HID\n        || unit_mass_attr == H5I_INVALID_HID\n        || unit_time_attr == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open attributes in units\");\n        goto err_units_attr;\n    }\n\n    if (H5Aread(unit_length_attr, H5T_NATIVE_DOUBLE, &amp;(system-&gt;unit_length)) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read unit length from units\");\n        goto err_units_attr;\n    }\n    if (H5Aread(unit_mass_attr, H5T_NATIVE_DOUBLE, &amp;(system-&gt;unit_mass)) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read unit mass from units\");\n        goto err_units_attr;\n    }\n    if (H5Aread(unit_time_attr, H5T_NATIVE_DOUBLE, &amp;(system-&gt;unit_time)) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read unit time from units\");\n        goto err_units_attr;\n    }\n\n    /* Open particle datasets */\n    hid_t part_type_1_masses = H5Dopen(part_type_1, \"Masses\", H5P_DEFAULT);\n    hid_t part_type_1_coordinates = H5Dopen(part_type_1, \"Coordinates\", H5P_DEFAULT);\n    hid_t part_type_1_velocities = H5Dopen(part_type_1, \"Velocities\", H5P_DEFAULT);\n    if (\n        part_type_1_masses == H5I_INVALID_HID\n        || part_type_1_coordinates == H5I_INVALID_HID\n        || part_type_1_velocities == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open datasets in PartType1\");\n        goto err_open_particle_dataset;\n    }\n\n    /* Read particle data */\n    if (H5Dread(part_type_1_masses, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, system-&gt;m) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read masses from PartType1\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_1_coordinates, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, system-&gt;x) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read coordinates from PartType1\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_1_velocities, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, system-&gt;v) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read velocities from PartType1\");\n        goto err_read_particle_data;\n    }\n\n    /* Close HDF5 objects */\n    H5Dclose(part_type_1_masses);\n    H5Dclose(part_type_1_coordinates);\n    H5Dclose(part_type_1_velocities);\n\n    H5Aclose(unit_length_attr);\n    H5Aclose(unit_mass_attr);\n    H5Aclose(unit_time_attr);\n\n    H5Aclose(num_particles_attr);\n    H5Aclose(box_size_attr);\n    H5Aclose(grid_size_attr);\n    H5Aclose(omega_m_attr);\n    H5Aclose(omega_lambda_attr);\n    H5Aclose(redshift_attr);\n    H5Aclose(h_attr);\n    H5Aclose(mass_table_attr);\n\n    H5Gclose(header);\n    H5Gclose(units);\n    H5Gclose(part_type_1);\n\n    H5Fclose(file);\n\n    return make_success_error_status();\n\nerr_read_particle_data:\nerr_open_particle_dataset:\n    H5Dclose(part_type_1_masses);\n    H5Dclose(part_type_1_coordinates);\n    H5Dclose(part_type_1_velocities);\nerr_units_attr:\n    H5Aclose(unit_length_attr);\n    H5Aclose(unit_mass_attr);\n    H5Aclose(unit_time_attr);\n    free_cosmological_system(system);\nerr_initialize_system:\nerr_header_attr:\n    H5Aclose(num_particles_attr);\n    H5Aclose(box_size_attr);\n    H5Aclose(grid_size_attr);\n    H5Aclose(omega_m_attr);\n    H5Aclose(omega_lambda_attr);\n    H5Aclose(redshift_attr);\n    H5Aclose(h_attr);\n    H5Aclose(mass_table_attr);\nerr_open_group:\n    H5Gclose(header);\n    H5Gclose(units);\n    H5Gclose(part_type_1);\nerr_open_file:\n    H5Fclose(file);\n\n    return error_status;\n}\n</code></pre> Source code in Python (Click to expand) examples/cosmic_structure/python/cosmic_structure.py<pre><code>from pathlib import Path\n\nimport h5py\nimport numpy as np\nfrom grav_sim import GravitySimulatorAPI\n\nINIT_CONDITION_FILE = Path(__file__).parent.parent / \"ics_swift.hdf5\"\nA_FINAL = 1.0  # Scale factor at the end of simulation\nNUM_STEPS = 1000\n\n\ndef main() -&gt; None:\n    gs = GravitySimulatorAPI()\n\n    system = gs.get_new_cosmological_system()\n    pm_grid_size = read_init_condition(system)\n\n    _, _, output_param, settings = gs.get_new_parameters()\n    output_param.method = \"hdf5\"\n    output_param.output_dir = Path(__file__).parent / \"snapshots/\"\n    output_param.output_interval = (A_FINAL - system.scale_factor) / 100\n    output_param.output_initial = True\n    output_param.coordinate_output_dtype = \"float\"\n    output_param.velocity_output_dtype = \"float\"\n    output_param.mass_output_dtype = \"float\"\n\n    settings.verbose = \"normal\"\n\n    gs.launch_cosmological_simulation(\n        system,\n        output_param,\n        settings,\n        A_FINAL,\n        NUM_STEPS,\n        pm_grid_size,\n    )\n\n\ndef read_init_condition(system) -&gt; int:\n    with h5py.File(INIT_CONDITION_FILE, \"r\") as f:\n        header = f[\"/Header\"]\n        units = f[\"/Units\"]\n        part_type_1 = f[\"/PartType1\"]\n\n        # Read header attributes\n        num_particles = int(header.attrs[\"NumPart_ThisFile\"][1])\n        box_size = float(header.attrs[\"BoxSize\"])\n        pm_grid_size = int(header.attrs[\"suggested_pmgrid\"])\n        omega_m = float(header.attrs[\"Omega0\"])\n        omega_lambda = float(header.attrs[\"OmegaLambda\"])\n        redshift = float(header.attrs[\"Redshift\"])\n        h_param = float(header.attrs[\"HubbleParam\"])\n\n        system.box_width = box_size / 2.0\n        system.box_center = np.array(\n            [system.box_width, system.box_width, system.box_width], dtype=np.float64\n        )\n        system.scale_factor = 1.0 / (redshift + 1.0)\n        system.omega_m = omega_m\n        system.omega_lambda = omega_lambda\n        system.h = h_param\n\n        # Read unit attributes\n        system.unit_length_in_cgs = float(units.attrs[\"Unit length in cgs (U_L)\"])\n        system.unit_mass_in_cgs = float(units.attrs[\"Unit mass in cgs (U_M)\"])\n        system.unit_time_in_cgs = float(units.attrs[\"Unit time in cgs (U_t)\"])\n\n        # Read particle datasets\n        system.add(\n            part_type_1[\"Coordinates\"][:],\n            part_type_1[\"Velocities\"][:],\n            part_type_1[\"Masses\"][:],\n        )\n\n        return pm_grid_size\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Related topics: </p> <ul> <li>Comoving coordinates</li> <li>Particle mesh algorithm</li> </ul> <p>In this example, we will simulate the formation of cosmological structures in a universe with \\(\\Lambda\\)CDM model.</p> <p>The initial conditions were generated with MUSIC v2<sup>1</sup> at \\(z = 50\\), with a resolution of \\(128^3 \\sim 2\\) million particles in a 30 Mpc \\(/ h\\) box. The MUSIC configuration file and initial conditions are provided in the repository, but with a smaller particles count of \\(64^3\\) to reduce the repository size.</p> <p>To run the simulation, we used the LeapFrog integrator in comoving coordinates, with a particle mesh algorithm with mesh size = \\(256^3 \\sim 16\\) million cells (following the suggestions from the MUSIC initial conditions).</p>"},{"location":"examples/cosmic_structure/cosmic_structure/#gallery","title":"Gallery","text":"<p>The simulation was done on Macbook Air M1. The simulation ran surprisingly fast and is finished in less than 10 minutes. The visualization was done with gadgetviewer as it is  directly compatible with our HDF5 output format.</p> <ol> <li> <p>Oliver Hahn and Tom Abel. Multi-scale initial conditions for cosmological simulations. Mon. Not. Roy. Astron. Soc., 415:2101\u20132121, 2011. arXiv:1103.6031, doi:10.1111/j.1365-2966.2011.18820.x.\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/galaxy_collision/galaxy_collision/","title":"Galaxy collision","text":"Source code in C (Click to expand) examples/galaxy_collision/c/galaxy_collision.c<pre><code>#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;hdf5.h&gt;\n\n#include \"grav_sim.h\"\n\n#define INIT_CONDITION_FILE \"../../galaxy_collision_IC.hdf5\"\n\n#define G_cgs 6.67430e-8  // cm^3 g^-1 s^-2\n\n#define ACC_METHOD ACCELERATION_METHOD_BARNES_HUT\n#define OPENING_ANGLE 0.5\n#define SOFTENING_LENGTH 0.0\n\n#define TF 4000000000 * 365.24 * 24 * 3600 // 4 billion years\n\n#define INTEGRATOR INTEGRATOR_LEAPFROG\n#define DT TF / 2000\n\n#define OUTPUT_METHOD OUTPUT_METHOD_HDF5\n#define OUTPUT_INTERVAL TF / 500 // 500 snapshots\n#define OUTPUT_DIR \"snapshots/\"\n#define OUTPUT_INITIAL true\n#define COORDINATE_OUTPUT_DTYPE OUTPUT_DTYPE_FLOAT\n#define VELOCITY_OUTPUT_DTYPE OUTPUT_DTYPE_FLOAT\n#define MASS_OUTPUT_DTYPE OUTPUT_DTYPE_FLOAT\n\nErrorStatus read_init_condition(\n    System *__restrict system,\n    double *__restrict unit_length,\n    double *__restrict unit_mass,\n    double *__restrict unit_time\n);\n\nint main(void)\n{\n    /* Acceleration parameters */\n    AccelerationParam acceleration_param = get_new_acceleration_param();\n    acceleration_param.method = ACCELERATION_METHOD_BARNES_HUT;\n    acceleration_param.opening_angle = OPENING_ANGLE;\n    acceleration_param.softening_length = SOFTENING_LENGTH;\n\n    System system;\n    double unit_length;\n    double unit_mass;\n    double unit_time;\n    ErrorStatus error_status = WRAP_TRACEBACK(read_init_condition(\n        &amp;system, &amp;unit_length, &amp;unit_mass, &amp;unit_time\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto error;\n    }\n\n    /* Convert units */\n    system.G = G_cgs * (\n        unit_mass\n        * unit_time * unit_time\n        / (unit_length * unit_length * unit_length)\n    );\n\n    /* Integrator parameters */\n    IntegratorParam integrator_param = get_new_integrator_param();\n    integrator_param.integrator = INTEGRATOR;\n    integrator_param.dt = DT / unit_time;\n\n    /* Output parameters */\n    OutputParam output_param = get_new_output_param();\n    output_param.method = OUTPUT_METHOD;\n    output_param.output_dir = OUTPUT_DIR;\n    output_param.output_interval = OUTPUT_INTERVAL  / unit_time;\n    output_param.output_initial = OUTPUT_INITIAL;\n    output_param.coordinate_output_dtype = COORDINATE_OUTPUT_DTYPE;\n    output_param.velocity_output_dtype = VELOCITY_OUTPUT_DTYPE;\n    output_param.mass_output_dtype = MASS_OUTPUT_DTYPE;\n\n    /* Simulation status */\n    SimulationStatus simulation_status;\n\n    /* Settings */\n    Settings settings = get_new_settings();\n    settings.verbose = GRAV_VERBOSITY_NORMAL;\n\n    int return_code = launch_simulation(\n        &amp;system,\n        &amp;integrator_param,\n        &amp;acceleration_param,\n        &amp;output_param,\n        &amp;simulation_status,\n        &amp;settings,\n        TF / unit_time\n    );\n    if (return_code != 0)\n    {\n        free_system(&amp;system);\n        error_status = WRAP_RAISE_ERROR(\n            GRAV_FAILURE,\n            \"Simulation failed.\"\n        );\n        goto error;\n    }\n\n    /* Free memory */\n    free_system(&amp;system);\n\n    return 0;\n\nerror:\n    print_and_free_traceback(&amp;error_status);\n    return 1;\n}\n\nErrorStatus read_init_condition(\n    System *__restrict system,\n    double *__restrict unit_length,\n    double *__restrict unit_mass,\n    double *__restrict unit_time\n)\n{\n    ErrorStatus error_status;\n\n    /* Open file */\n    hid_t file = H5Fopen(INIT_CONDITION_FILE, H5F_ACC_RDONLY, H5P_DEFAULT);\n    if (file == H5I_INVALID_HID)    \n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open initial condition file\");\n        goto err_open_file;\n    }\n\n    /* Open groups */\n    hid_t header = H5Gopen(file, \"/Header\", H5P_DEFAULT);\n    hid_t units = H5Gopen(file, \"/Units\", H5P_DEFAULT);\n    hid_t part_type_1 = H5Gopen(file, \"/PartType1\", H5P_DEFAULT);\n    hid_t part_type_2 = H5Gopen(file, \"/PartType2\", H5P_DEFAULT);\n    if (header == H5I_INVALID_HID \n        || units == H5I_INVALID_HID\n        || part_type_1 == H5I_INVALID_HID\n        || part_type_2 == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open groups in initial condition file\");\n        goto err_open_group;\n    }\n\n    /* Read header attributes */\n    hid_t num_particles_attr = H5Aopen(header, \"NumPart_ThisFile\", H5P_DEFAULT);\n    if (num_particles_attr == H5I_INVALID_HID)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open attributes in header\");\n        goto err_header_attr;\n    }\n\n    uint32_t temp_num_particles_arr[6];\n    if (H5Aread(num_particles_attr, H5T_NATIVE_UINT32, &amp;temp_num_particles_arr) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read number of particles from header\");\n        goto err_header_attr;\n    }\n\n    error_status = WRAP_TRACEBACK(get_initialized_system(\n        system,\n        temp_num_particles_arr[1] + temp_num_particles_arr[2]\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto err_initialize_system;\n    }\n\n    /* Read units attributes */\n    hid_t unit_length_attr = H5Aopen(units, \"Unit length in cgs (U_L)\", H5P_DEFAULT);\n    hid_t unit_mass_attr = H5Aopen(units, \"Unit mass in cgs (U_M)\", H5P_DEFAULT);\n    hid_t unit_time_attr = H5Aopen(units, \"Unit time in cgs (U_t)\", H5P_DEFAULT);\n\n    if (\n        unit_length_attr == H5I_INVALID_HID\n        || unit_mass_attr == H5I_INVALID_HID\n        || unit_time_attr == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open attributes in units\");\n        goto err_units_attr;\n    }\n\n    if (H5Aread(unit_length_attr, H5T_NATIVE_DOUBLE, unit_length) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read unit length from units\");\n        goto err_units_attr;\n    }\n    if (H5Aread(unit_mass_attr, H5T_NATIVE_DOUBLE, unit_mass) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read unit mass from units\");\n        goto err_units_attr;\n    }\n    if (H5Aread(unit_time_attr, H5T_NATIVE_DOUBLE, unit_time) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read unit time from units\");\n        goto err_units_attr;\n    }\n\n    /* Open particle datasets */\n    hid_t part_type_1_masses = H5Dopen(part_type_1, \"Masses\", H5P_DEFAULT);\n    hid_t part_type_1_coordinates = H5Dopen(part_type_1, \"Coordinates\", H5P_DEFAULT);\n    hid_t part_type_1_velocities = H5Dopen(part_type_1, \"Velocities\", H5P_DEFAULT);\n    hid_t part_type_2_masses = H5Dopen(part_type_2, \"Masses\", H5P_DEFAULT);\n    hid_t part_type_2_coordinates = H5Dopen(part_type_2, \"Coordinates\", H5P_DEFAULT);\n    hid_t part_type_2_velocities = H5Dopen(part_type_2, \"Velocities\", H5P_DEFAULT);\n    if (\n        part_type_1_masses == H5I_INVALID_HID\n        || part_type_1_coordinates == H5I_INVALID_HID\n        || part_type_1_velocities == H5I_INVALID_HID\n        || part_type_2_masses == H5I_INVALID_HID\n        || part_type_2_coordinates == H5I_INVALID_HID\n        || part_type_2_velocities == H5I_INVALID_HID\n    )\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to open datasets in PartType1\");\n        goto err_open_particle_dataset;\n    }\n\n    /* Read particle data */\n    if (H5Dread(part_type_1_masses, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, system-&gt;m) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read masses from PartType1\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_1_coordinates, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, system-&gt;x) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read coordinates from PartType1\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_1_velocities, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, system-&gt;v) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read velocities from PartType1\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_2_masses, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &amp;(system-&gt;m[temp_num_particles_arr[1]])) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read masses from PartType2\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_2_coordinates, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &amp;(system-&gt;x[temp_num_particles_arr[1] * 3])) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read coordinates from PartType2\");\n        goto err_read_particle_data;\n    }\n    if (H5Dread(part_type_2_velocities, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &amp;(system-&gt;v[temp_num_particles_arr[1] * 3])) &lt; 0)\n    {\n        error_status = WRAP_RAISE_ERROR(GRAV_OS_ERROR, \"Failed to read velocities from PartType2\");\n        goto err_read_particle_data;\n    }\n\n    /* Close HDF5 objects */\n    H5Dclose(part_type_1_masses);\n    H5Dclose(part_type_1_coordinates);\n    H5Dclose(part_type_1_velocities);\n    H5Dclose(part_type_2_masses);\n    H5Dclose(part_type_2_coordinates);\n    H5Dclose(part_type_2_velocities);\n\n    H5Aclose(unit_length_attr);\n    H5Aclose(unit_mass_attr);\n    H5Aclose(unit_time_attr);\n\n    H5Aclose(num_particles_attr);\n\n    H5Gclose(header);\n    H5Gclose(units);\n    H5Gclose(part_type_1);\n    H5Gclose(part_type_2);\n\n    H5Fclose(file);\n\n    return make_success_error_status();\n\nerr_read_particle_data:\nerr_open_particle_dataset:\n    H5Dclose(part_type_1_masses);\n    H5Dclose(part_type_1_coordinates);\n    H5Dclose(part_type_1_velocities);\nerr_units_attr:\n    H5Aclose(unit_length_attr);\n    H5Aclose(unit_mass_attr);\n    H5Aclose(unit_time_attr);\n    free_system(system);\nerr_initialize_system:\nerr_header_attr:\n    H5Aclose(num_particles_attr);\nerr_open_group:\n    H5Gclose(header);\n    H5Gclose(units);\n    H5Gclose(part_type_1);\n    H5Gclose(part_type_2);\nerr_open_file:\n    H5Fclose(file);\n\n    return error_status;\n}\n</code></pre> Source code in Python (Click to expand) examples/galaxy_collision/python/galaxy_collision.py<pre><code>from pathlib import Path\n\nimport h5py\nimport numpy as np\nfrom grav_sim import GravitySimulatorAPI\n\nIC_path = Path(__file__).parent.parent / \"galaxy_collision_IC.hdf5\"\n\nG_cgs = 6.67430e-8  # cm^3 g^-1 s^-2\n\nACC_METHOD = \"Barnes_Hut\"\nOPENING_ANGLE = 0.5\nSOFTENING_LENGTH = 0.0\n\nTF = 4000000000 * 365.24 * 24 * 3600  # 4 billion years\n\nINTEGRATOR = \"Leapfrog\"\nDT = TF / 2000\n\nOUTPUT_METHOD = \"hdf5\"\nOUTPUT_INTERVAL = TF / 500  # 500 snapshots\nOUTPUT_DIR = Path(__file__).parent / \"snapshots/\"\n\n\ndef main():\n    # Load the simulation data\n    with h5py.File(IC_path, \"r\") as file:\n        type_1_particle_IDs = file[\"PartType1\"][\"ParticleIDs\"][:]\n        type_2_particle_IDs = file[\"PartType2\"][\"ParticleIDs\"][:]\n\n        type_1_mass = file[\"PartType1\"][\"Masses\"][:]\n        type_1_position = file[\"PartType1\"][\"Coordinates\"][:]\n        type_1_velocity = file[\"PartType1\"][\"Velocities\"][:]\n\n        type_2_mass = file[\"PartType2\"][\"Masses\"][:]\n        type_2_position = file[\"PartType2\"][\"Coordinates\"][:]\n        type_2_velocity = file[\"PartType2\"][\"Velocities\"][:]\n\n        unit_length_in_cgs = file[\"Units\"].attrs[\"Unit length in cgs (U_L)\"]\n        unit_mass_in_cgs = file[\"Units\"].attrs[\"Unit mass in cgs (U_M)\"]\n        unit_time_in_cgs = file[\"Units\"].attrs[\"Unit time in cgs (U_t)\"]\n\n    # Combine the data into a single array\n    particle_IDs = np.concatenate((type_1_particle_IDs, type_2_particle_IDs))\n    masses = np.concatenate((type_1_mass, type_2_mass))\n    positions = np.concatenate((type_1_position, type_2_position))\n    velocities = np.concatenate((type_1_velocity, type_2_velocity))\n\n    # Create the simulator\n    gs = GravitySimulatorAPI()\n\n    system = gs.get_new_system()\n    system.add(\n        x=positions,\n        v=velocities,\n        m=masses,\n    )\n\n    system.G = G_cgs * unit_mass_in_cgs * unit_time_in_cgs**2 / unit_length_in_cgs**3\n    # Convert the units\n    global TF, DT, OUTPUT_INTERVAL\n    TF /= unit_time_in_cgs\n    DT /= unit_time_in_cgs\n    OUTPUT_INTERVAL /= unit_time_in_cgs\n\n    # Parameters\n    acc_param, integrator_param, output_param, settings = gs.get_new_parameters()\n\n    acc_param.method = ACC_METHOD\n    acc_param.opening_angle = OPENING_ANGLE\n    acc_param.softening_length = SOFTENING_LENGTH\n\n    integrator_param.integrator = INTEGRATOR\n    integrator_param.dt = DT\n\n    output_param.method = OUTPUT_METHOD\n    output_param.output_interval = OUTPUT_INTERVAL\n    output_param.output_dir = OUTPUT_DIR\n    output_param.coordinate_output_dtype = \"float\"\n    output_param.velocity_output_dtype = \"float\"\n    output_param.mass_output_dtype = \"float\"\n\n    gs.launch_simulation(\n        system, acc_param, integrator_param, output_param, settings, TF\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Related topics: </p> <ul> <li>Barnes-Hut algorithm</li> </ul> <p>In this example, we will simulate the collision of two galaxies with 60000 particles using the initial conditions from Gadget-2<sup>1</sup>. The initial conditions is preprocessed into a HDF5 file and is included in the repository.</p> <p>To deal with the large number of particles, we used the Barnes-Hut algorithm to compute the gravitational force. On Macbook Air M1, the simulation can be done in 5 minutes for \\(\\theta = 1.0\\) and 30 minutes for \\(\\theta = 0.5\\).</p>"},{"location":"examples/galaxy_collision/galaxy_collision/#gallery","title":"Gallery","text":"<p>The visualization is done with gadgetviewer, which is compatible with our HDF5 output format.</p> <ol> <li> <p>Volker Springel. The cosmological simulation code gadget-2. Monthly Notices of the Royal Astronomical Society, 364(4):1105\u20131134, 12 2005. doi:10.1111/j.1365-2966.2005.09655.x.\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/kirkwood_gaps/kirkwood_gaps/","title":"Formation of Kirkwood gaps","text":"Source code (Python) (Click to expand) examples/kirkwood_gaps/python/kirkwood_gaps.py<pre><code>\"\"\"\nDemonstration on using the gravity simulator API to simulate the formation of Kirkwood gaps.\n\"\"\"\n\nimport numpy as np\n\nfrom grav_sim import GravitySimulatorAPI\n\ngs = GravitySimulatorAPI()\n\nNUM_PARTICLES = 100\nDT = 180.0\nTF = 5000000.0 * 365.24\nOUTPUT_INTERVAL = 2500 * 365.24  # Stores 2000 snapshots\nOUTPUT_METHOD = \"hdf5\"\nOUTPUT_DIR = \"../snapshots/\"\n\n\ndef main():\n    # ---------- Initialization ---------- #\n    gs = GravitySimulatorAPI()\n    system = gs.get_built_in_system(\"solar_system\")\n\n    # Remove Mercury, Venus, Earth, Uranus, and Neptune\n    system.remove([1, 2, 3, 7, 8])\n\n    rng = np.random.default_rng()\n    a = rng.uniform(2.0, 3.35, size=NUM_PARTICLES)\n    ecc = np.abs(rng.normal(loc=0.0, scale=0.12, size=NUM_PARTICLES))\n    inc = np.abs(rng.normal(loc=0.0, scale=0.3, size=NUM_PARTICLES))\n    argument_of_periapsis = rng.uniform(0, 2 * np.pi, size=NUM_PARTICLES)\n    long_asc_node = rng.uniform(0, 2 * np.pi, size=NUM_PARTICLES)\n    true_anomaly = rng.uniform(0, 2 * np.pi, size=NUM_PARTICLES)\n\n    for i in range(NUM_PARTICLES):\n        system.add_keplerian(\n            semi_major_axis=a[i],\n            eccentricity=ecc[i],\n            inclination=inc[i],\n            argument_of_periapsis=argument_of_periapsis[i],\n            longitude_of_ascending_node=long_asc_node[i],\n            true_anomaly=true_anomaly[i],\n            m=0.0,\n            primary_particle_id=0,\n        )\n    system.center_of_mass_correction()\n\n    # ---------- Simulation ---------- #\n    acc_param, integrator_param, output_param, settings = gs.get_new_parameters()\n\n    acc_param.method = \"massless\"\n\n    integrator_param.integrator = \"whfast\"\n    integrator_param.dt = DT\n    integrator_param.whfast_remove_invalid_particles = True\n\n    output_param.method = OUTPUT_METHOD\n    output_param.output_interval = OUTPUT_INTERVAL\n    output_param.output_dir = OUTPUT_DIR\n    output_param.coordinate_output_dtype = \"float\"\n    output_param.velocity_output_dtype = \"float\"\n    output_param.mass_output_dtype = \"float\"\n\n    gs.launch_simulation(\n        system, acc_param, integrator_param, output_param, settings, TF\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Source code (C) (Click to expand) examples/kirkwood_gaps/c/kirkwood_gaps.c<pre><code>#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\n#include \"grav_sim.h\"\n\n#define NUM_PARTICLES 25000\n#define DT 180.0\n#define TF 5000000 * 365.24\n#define OUTPUT_INTERVAL 2500 * 365.24 // Store 2000 snapshots\n#define OUTPUT_METHOD OUTPUT_METHOD_HDF5\n\nint main(void)\n{\n    ErrorStatus error_status;\n\n    /* Initialize system */\n    System system;\n    error_status = WRAP_TRACEBACK(get_initialized_system(&amp;system, NUM_PARTICLES));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto error;\n    }\n\n    error_status = WRAP_TRACEBACK(initialize_built_in_system(\n        &amp;system,\n        \"solar_system\",\n        true\n    ));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto error;\n    }\n\n    /* Sun, Mars, Jupiter, Saturn (1 &lt;- 4, 2 &lt;- 5, 3 &lt;- 6) */\n    const int num_massive_objects = 4;\n    for (int i = 1, j = 4; i &lt; 4; i++, j++)\n    {\n        system.m[i] = system.m[j];\n        system.x[i * 3 + 0] = system.x[j * 3 + 0];\n        system.x[i * 3 + 1] = system.x[j * 3 + 1];\n        system.x[i * 3 + 2] = system.x[j * 3 + 2];\n        system.v[i * 3 + 0] = system.v[j * 3 + 0];\n        system.v[i * 3 + 1] = system.v[j * 3 + 1];\n        system.v[i * 3 + 2] = system.v[j * 3 + 2];\n    }\n\n    /* Asteroids */\n    pcg32_random_t rng = init_pcg_rng();\n    for (int i = num_massive_objects; i &lt; NUM_PARTICLES; i++)\n    {\n        system.m[i] = 0.0;\n\n        const double semi_major_axis = grav_randrange(2.0, 3.35, &amp;rng);\n        const double eccentricity = grav_randrange(-0.12, 0.12, &amp;rng);\n        const double inclination = grav_randrange(-0.3, 0.3, &amp;rng);\n        const double argument_of_periapsis = grav_randrange(0.0, 2.0 * M_PI, &amp;rng);\n        const double longitude_of_ascending_node = grav_randrange(0.0, 2.0 * M_PI, &amp;rng);\n        const double true_anomaly = grav_randrange(0.0, 2.0 * M_PI, &amp;rng);\n\n        keplerian_to_cartesian(\n            &amp;system.x[i * 3],\n            &amp;system.v[i * 3],\n            semi_major_axis,\n            eccentricity,\n            inclination,\n            argument_of_periapsis,\n            longitude_of_ascending_node,\n            true_anomaly,\n            system.m[0],\n            system.G\n        );\n\n        system.x[i * 3 + 0] += system.x[0];\n        system.x[i * 3 + 1] += system.x[1];\n        system.x[i * 3 + 2] += system.x[2];\n        system.v[i * 3 + 0] += system.v[0];\n        system.v[i * 3 + 1] += system.v[1];\n        system.v[i * 3 + 2] += system.v[2];\n    }\n    error_status = WRAP_TRACEBACK(system_set_center_of_mass_zero(&amp;system));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto error;\n    }\n    error_status = WRAP_TRACEBACK(system_set_total_momentum_zero(&amp;system));\n    if (error_status.return_code != GRAV_SUCCESS)\n    {\n        goto error;\n    }\n\n    /* Acceleration parameters */\n    AccelerationParam acceleration_param = get_new_acceleration_param();\n    acceleration_param.method = ACCELERATION_METHOD_MASSLESS;\n\n    /* Integrator parameters */\n    IntegratorParam integrator_param = get_new_integrator_param();\n    integrator_param.integrator = INTEGRATOR_WHFAST;\n    integrator_param.dt = DT;\n\n    /* Output parameters */\n    OutputParam output_param = get_new_output_param();\n    output_param.method = OUTPUT_METHOD;\n    output_param.output_dir = \"../snapshots/\";\n    output_param.output_interval = OUTPUT_INTERVAL;\n    output_param.output_initial = true;\n    output_param.coordinate_output_dtype = OUTPUT_DTYPE_FLOAT;\n    output_param.velocity_output_dtype = OUTPUT_DTYPE_FLOAT;\n    output_param.mass_output_dtype = OUTPUT_DTYPE_FLOAT;\n\n    /* Simulation status */\n    SimulationStatus simulation_status;\n\n    /* Settings */\n    Settings settings = get_new_settings();\n    settings.verbose = GRAV_VERBOSITY_VERBOSE;\n\n    int return_code = launch_simulation(\n        &amp;system,\n        &amp;integrator_param,\n        &amp;acceleration_param,\n        &amp;output_param,\n        &amp;simulation_status,\n        &amp;settings,\n        TF\n    );\n    if (return_code != 0)\n    {\n        free_system(&amp;system);\n        error_status = WRAP_RAISE_ERROR(\n            GRAV_FAILURE,\n            \"Simulation failed.\"\n        );\n        goto error;\n    }\n\n    /* Free memory */\n    free_system(&amp;system);\n\n    return 0;\n\nerror:\n    print_and_free_traceback(&amp;error_status);\n    return 1;\n}\n</code></pre> Source code (Animation) (Click to expand) examples/kirkwood_gaps/animate_kirkwood_gaps.py<pre><code>\"\"\"\nAnimation of Kirkwood gaps using the snapshots generated from the simulation.\n\nTODO: Calculations for the 2D scatter plot is not vectorized and is extremely slow.\n\nAuthor: Ching-Yin Ng\n\"\"\"\n\nimport glob\nfrom pathlib import Path\n\nimport h5py\nimport numpy as np\nimport PIL\nimport matplotlib.pyplot as plt\nfrom rich.progress import track\n\nFPS = 30\nDPI = 200\n\nG = 0.00029591220828411956\nM = 1.0\n\nSNAPSHOT_FOLDER = Path(\"snapshots/\")\nFRAMES_FOLDER = Path(\"frames/\")\nOUTPUT_FOLDER = Path(\"output/\")\n\nFRAMES_FOLDER.mkdir(exist_ok=True)\nOUTPUT_FOLDER.mkdir(exist_ok=True)\n\n\ndef main():\n    if not SNAPSHOT_FOLDER.exists():\n        print(f'Snapshot folder \"{SNAPSHOT_FOLDER}\" not found!')\n        print(\"Please run the simulation first.\")\n        return\n\n    labels = [\"Sun\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    colors = [\"orange\", \"red\", \"darkgoldenrod\", \"gold\"]\n    marker_sizes = [6.0, 1.5, 4.0, 3.5]\n\n    def natural_sort_key(s):\n        \"\"\"Sort strings with embedded numbers naturally.\"\"\"\n        return [int(Path(s).stem.strip(\"snapshot_\"))]\n\n    snapshot_file_paths = sorted(\n        glob.glob(str(SNAPSHOT_FOLDER / \"snapshot_*.hdf5\")), key=natural_sort_key\n    )\n    num_snapshots = len(snapshot_file_paths)\n\n    if num_snapshots &lt;= 0:\n        print(f'No snapshot files found in \"{SNAPSHOT_FOLDER}\"!')\n        print(\"Please run the simulation first.\")\n        return\n\n    print()\n    print(\"Drawing frames for semi-major-axes plots...\")\n    fig1, ax1 = plt.subplots()\n    ax1_xlim_min = 1.8\n    ax1_xlim_max = 3.5\n    ax1_ylim_min = 0.0\n    ax1_ylim_max = 1.0\n    for i in track(range(num_snapshots)):\n        snapshot_file_path = snapshot_file_paths[i]\n        with h5py.File(snapshot_file_path, \"r\") as f:\n            year = f[\"Header\"].attrs[\"Time\"][0] / 365.242189 / 1e6\n            x = f[\"PartType0/Coordinates\"][:]\n            v = f[\"PartType0/Velocities\"][:]\n\n            eccentricity = calculate_eccentricity(x[0:] - x[0], v[0:] - v[0], 0.0, G, M)\n            semi_major_axes = calculate_semi_major_axis(\n                x[0:] - x[0], v[0:] - v[0], 0.0, G, M\n            )\n\n            # Scatter plot\n            ax1.scatter(\n                semi_major_axes,\n                eccentricity,\n                s=2,\n                marker=\".\",\n                color=\"black\",\n                alpha=0.5,\n            )\n\n            # Annotate time\n            ax1.annotate(\n                f\"{year:.2f} Myr\",\n                xy=(0.95, 0.95),\n                xycoords=\"axes fraction\",\n                fontsize=12,\n                ha=\"right\",\n                va=\"top\",\n            )\n\n            # Draw dashed lines indicating the gaps\n            # fmt: off\n            ax1.axvline(x=2.065, color=\"black\", linestyle=\"--\", linewidth=0.5, alpha=0.2, zorder=0)\n            ax1.axvline(x=2.502, color=\"black\", linestyle=\"--\", linewidth=0.5, alpha=0.2, zorder=0)\n            ax1.axvline(x=2.825, color=\"black\", linestyle=\"--\", linewidth=0.5, alpha=0.2, zorder=0)\n            ax1.axvline(x=2.958, color=\"black\", linestyle=\"--\", linewidth=0.5, alpha=0.2, zorder=0)\n            ax1.axvline(x=3.279, color=\"black\", linestyle=\"--\", linewidth=0.5, alpha=0.2, zorder=0)\n\n            # Annotate resonance ratios\n            ax1.text(2.065, ax1_ylim_max, '4:1', color='black', ha='center', va='bottom', fontsize=10)\n            ax1.text(2.502, ax1_ylim_max, '3:1', color='black', ha='center', va='bottom', fontsize=10)\n            ax1.text(2.825, ax1_ylim_max, '5:2', color='black', ha='center', va='bottom', fontsize=10)\n            ax1.text(2.958, ax1_ylim_max, '7:3', color='black', ha='center', va='bottom', fontsize=10)\n            ax1.text(3.279, ax1_ylim_max, '2:1', color='black', ha='center', va='bottom', fontsize=10)\n\n            # Set labels\n            ax1.set_xlabel(\"Semi-major axis (AU)\")\n            ax1.set_ylabel(\"Eccentricity\")\n\n            # Set axes\n            ax1.set_xlim(ax1_xlim_min, ax1_xlim_max)\n            ax1.set_ylim(ax1_ylim_min, ax1_ylim_max)\n\n            fig1.tight_layout()\n\n            # Capture the frame\n            plt.savefig(FRAMES_FOLDER / f\"semi_major_axes_frames_{i:04d}.png\", dpi=DPI)\n\n            # Clear the plot to prepare for the next frame\n            ax1.clear()\n\n    plt.close(\"all\")\n\n    print()\n    print(\"Drawing frames for visualization plots...\")\n    fig2, ax2 = plt.subplots(figsize=(4.8, 4.8))\n    ax2.set_facecolor(\"black\")\n    ax2_xlim_min = -3.5\n    ax2_xlim_max = 3.5\n    ax2_ylim_min = -3.5\n    ax2_ylim_max = 3.5\n    for i in track(range(num_snapshots)):\n        snapshot_file_path = snapshot_file_paths[i]\n        with h5py.File(snapshot_file_path, \"r\") as f:\n            year = f[\"Header\"].attrs[\"Time\"][0] / 365.242189 / 1e6\n            num_particles = f[\"Header\"].attrs[\"NumPart_Total\"][0]\n            x = f[\"PartType0/Coordinates\"][:]\n            v = f[\"PartType0/Velocities\"][:]\n\n            new_x = np.zeros((num_particles - 1, 3))\n            for j in range(1, num_particles):\n                semi_major_axis, _, true_anomaly, _, arg_per, long_asc_nodes = (\n                    cartesian_to_orbital_elements(0.0, M, x[j] - x[0], v[j] - v[0], G=G)\n                )\n                new_x[j - 1] = keplerian_to_cartesian(\n                    semi_major_axis=semi_major_axis,\n                    eccentricity=0.0,\n                    inclination=0.0,\n                    argument_of_periapsis=arg_per,\n                    longitude_of_ascending_node=long_asc_nodes,\n                    true_anomaly=true_anomaly,\n                )\n\n            # Plotting the sun\n            ax2.plot(\n                x[0, 0],\n                x[0, 1],\n                \"o\",\n                label=labels[0],\n                color=colors[0],\n                markersize=marker_sizes[0],\n            )\n\n            # Plotting the asteroids\n            ax2.scatter(\n                new_x[:, 0],\n                new_x[:, 1],\n                color=\"white\",\n                marker=\".\",\n                s=0.1,\n                alpha=0.4,\n            )\n\n            # Annotate time\n            ax2.annotate(\n                f\"{year:.2f} Myr\",\n                xy=(0.95, 0.95),\n                xycoords=\"axes fraction\",\n                fontsize=12,\n                ha=\"right\",\n                va=\"top\",\n                color=\"white\",\n            )\n\n            # Set labels\n            ax2.set_xlabel(\"$x$ (AU)\")\n            ax2.set_ylabel(\"$y$ (AU)\")\n\n            # Set axes\n            ax2.set_xlim(ax2_xlim_min, ax2_xlim_max)\n            ax2.set_ylim(ax2_ylim_min, ax2_ylim_max)\n\n            # Set equal aspect ratio to prevent distortion\n            ax2.set_aspect(\"equal\")\n\n            ax2.set_title(\n                \"2D scatter plot with correction\\n(eccentricity = inclination = 0)\"\n            )\n\n            fig2.tight_layout()\n\n            # Capture the frame\n            plt.savefig(\n                FRAMES_FOLDER / f\"visualization_frames_{i:04d}.png\",\n                dpi=DPI,\n            )\n\n            # Clear the plot to prepare for the next frame\n            ax2.clear()\n\n    plt.close(\"all\")\n\n    print()\n    print(\"Combining frames to gif...\")\n\n    def frames_generator(num_frames, file_prefix: str) -&gt; PIL.Image:\n        for i in range(num_frames):\n            yield PIL.Image.open(f\"{file_prefix}_{i:04d}.png\")\n\n    semi_major_axes_frames = frames_generator(\n        num_snapshots, str(FRAMES_FOLDER / \"semi_major_axes_frames\")\n    )\n    next(semi_major_axes_frames).save(\n        OUTPUT_FOLDER / \"Kirkwood_gap_semi_major_axes.gif\",\n        save_all=True,\n        append_images=semi_major_axes_frames,\n        loop=0,\n        duration=(1000 // FPS),\n    )\n\n    visualization_frames = frames_generator(\n        num_snapshots, str(FRAMES_FOLDER / \"visualization_frames\")\n    )\n    next(visualization_frames).save(\n        OUTPUT_FOLDER / \"Kirkwood_gap_visualization.gif\",\n        save_all=True,\n        append_images=visualization_frames,\n        loop=0,\n        duration=(1000 // FPS),\n    )\n\n    print(\n        f'Output completed! Please check \"{OUTPUT_FOLDER / \"Kirkwood_gap_semi_major_axes.gif\"}\" and \"{OUTPUT_FOLDER / \"Kirkwood_gap_visualization.gif\"}\"'\n    )\n    print()\n\n    for i in range(num_snapshots):\n        (FRAMES_FOLDER / f\"semi_major_axes_frames_{i:04d}.png\").unlink()\n\n    for i in range(num_snapshots):\n        (FRAMES_FOLDER / f\"visualization_frames_{i:04d}.png\").unlink()\n\n    print(\"Done! Exiting the program...\")\n\n\ndef calculate_eccentricity(x, v, m, G, M):\n    ecc_vec = (\n        np.cross(v, np.cross(x, v)) / (G * (m + M))\n        - x / np.linalg.norm(x, axis=1)[:, np.newaxis]\n    )\n    ecc = np.linalg.norm(ecc_vec, axis=1)\n\n    return ecc\n\n\ndef calculate_semi_major_axis(x, v, m, G, M):\n    E_sp = 0.5 * np.linalg.norm(v, axis=1) ** 2 - G * (m + M) / np.linalg.norm(\n        x, axis=1\n    )\n    a = -0.5 * G * (m + M) / E_sp\n\n    return a\n\n\ndef cartesian_to_orbital_elements(\n    mp,\n    ms,\n    position,\n    velocity,\n    G,\n):\n    \"\"\"\n\n    Function that computes orbital elements from cartesian coordinates.\n    Return values are: mass1, mass2, semimajor axis, eccentricity,\n    true anomaly, inclination, longitude of the ascending nodes and the\n    argument of pericenter. All angles are returned in radians.\n    In case of a perfectly circular orbit the true anomaly\n    and argument of pericenter cannot be determined; in this case, the\n    return values are 0.0 for both angles.\n\n    Reference: copied from ABIE with slight modification\n    https://github.com/MovingPlanetsAround/ABIE/blob/master/abie/tools.py\n    \"\"\"\n\n    total_mass = mp + ms\n\n    ### specific energy ###\n    v_sq = np.dot(velocity, velocity)\n    r_sq = np.dot(position, position)\n    r = np.sqrt(r_sq)\n\n    specific_energy = (1.0 / 2.0) * v_sq - G * total_mass / r\n    # if specific_energy &gt;= 0.0:\n    #     print 'Not a bound orbit!'\n\n    semimajor_axis = -G * total_mass / (2.0 * specific_energy)\n\n    ### specific angular momentum ###\n    specific_angular_momentum = np.cross(position, velocity)\n    specific_angular_momentum_norm = np.sqrt(\n        np.dot(specific_angular_momentum, specific_angular_momentum)\n    )\n    specific_angular_momentum_unit = (\n        specific_angular_momentum / specific_angular_momentum_norm\n    )\n\n    maximum_specific_angular_momentum_norm = (\n        G * total_mass / (np.sqrt(-2.0 * specific_energy))\n    )\n    ell = (\n        specific_angular_momentum_norm / maximum_specific_angular_momentum_norm\n    )  ### specific AM in units of maximum AM\n\n    ### for e = 0 or e nearly 0, ell can be slightly larger than unity due to numerical reasons ###\n    ell_epsilon = 1e-15\n\n    completely_or_nearly_circular = False\n\n    if ell &gt; 1.0:\n        if 1.0 &lt; ell &lt;= ell + ell_epsilon:  ### still unity within numerical precision\n            print(\n                \"orbit is completely or nearly circular; in this case the LRL vector cannot be used to reliably obtain the argument of pericenter and true anomaly; the output values of the latter will be set to zero; output e will be e = 0\"\n            )\n            ell = 1.0\n            completely_or_nearly_circular = True\n        else:  ### larger than unity within numerical precision\n            raise Exception(\n                \"angular momentum larger than maximum angular momentum for bound orbit\"\n            )\n\n    eccentricity = np.sqrt(1.0 - ell**2)\n\n    ### Orbital inclination ###\n    z_vector = np.array([0.0, 0.0, 1.0])\n    inclination = np.arccos(np.dot(z_vector, specific_angular_momentum_unit))\n\n    ### Longitude of ascending nodes, with reference direction along x-axis ###\n    ascending_node_vector = np.cross(z_vector, specific_angular_momentum)\n    ascending_node_vector_norm = np.sqrt(\n        np.dot(ascending_node_vector, ascending_node_vector)\n    )\n    if ascending_node_vector_norm == 0:\n        ascending_node_vector_unit = np.array([1.0, 0.0, 0.0])\n    else:\n        ascending_node_vector_unit = ascending_node_vector / ascending_node_vector_norm\n\n    long_asc_nodes = np.arctan2(\n        ascending_node_vector_unit[1], ascending_node_vector_unit[0]\n    )\n\n    ### Argument of periapsis and true anomaly, using eccentricity a.k.a. Laplace-Runge-Lenz (LRL) vector ###\n    mu = G * total_mass\n    position_unit = position / r\n    e_vector = (1.0 / mu) * np.cross(\n        velocity, specific_angular_momentum\n    ) - position_unit  ### Laplace-Runge-Lenz vector\n\n    if completely_or_nearly_circular:  ### orbit is completely or nearly circular; in this case the LRL vector cannot be used to reliably obtain the argument of pericenter and true anomaly; the output values of the latter will be set to zero; output e will be e = 0\n        arg_per = 0.0\n        true_anomaly = 0.0\n    else:\n        e_vector_norm = np.sqrt(np.dot(e_vector, e_vector))\n        e_vector_unit = e_vector / e_vector_norm\n\n        e_vector_unit_cross_AM_unit = np.cross(\n            e_vector_unit, specific_angular_momentum_unit\n        )\n        sin_arg_per = np.dot(ascending_node_vector_unit, e_vector_unit_cross_AM_unit)\n        cos_arg_per = np.dot(e_vector_unit, ascending_node_vector_unit)\n        arg_per = np.arctan2(sin_arg_per, cos_arg_per)\n\n        sin_true_anomaly = np.dot(position_unit, -1.0 * e_vector_unit_cross_AM_unit)\n        cos_true_anomaly = np.dot(position_unit, e_vector_unit)\n        true_anomaly = np.arctan2(sin_true_anomaly, cos_true_anomaly)\n\n    return (\n        semimajor_axis,\n        eccentricity,\n        true_anomaly,\n        inclination,\n        arg_per,\n        long_asc_nodes,\n    )\n\n\ndef keplerian_to_cartesian(\n    semi_major_axis: float,\n    eccentricity: float,\n    inclination: float,\n    argument_of_periapsis: float,\n    longitude_of_ascending_node: float,\n    true_anomaly: float,\n):\n    \"\"\"\n    Convert keplerian elements to cartesian coordinates,\n    modified to calculate position only.\n\n    Reference\n    ---------\n    Moving Planets Around: An Introduction to N-Body\n    Simulations Applied to Exoplanetary Systems, Chapter 2\n    \"\"\"\n\n    cos_inc = np.cos(inclination)\n    sin_inc = np.sin(inclination)\n\n    cos_arg_periapsis = np.cos(argument_of_periapsis)\n    sin_arg_periapsis = np.sin(argument_of_periapsis)\n\n    cos_long_asc_node = np.cos(longitude_of_ascending_node)\n    sin_long_asc_node = np.sin(longitude_of_ascending_node)\n\n    cos_true_anomaly = np.cos(true_anomaly)\n    sin_true_anomaly = np.sin(true_anomaly)\n\n    # ecc_unit_vec is the unit vector pointing towards periapsis\n    ecc_unit_vec = np.zeros(3)\n    ecc_unit_vec[0] = (\n        cos_long_asc_node * cos_arg_periapsis\n        - sin_long_asc_node * sin_arg_periapsis * cos_inc\n    )\n    ecc_unit_vec[1] = (\n        sin_long_asc_node * cos_arg_periapsis\n        + cos_long_asc_node * sin_arg_periapsis * cos_inc\n    )\n    ecc_unit_vec[2] = sin_arg_periapsis * sin_inc\n\n    # q_unit_vec is the unit vector that is perpendicular to ecc_unit_vec and orbital angular momentum vector\n    q_unit_vec = np.zeros(3)\n    q_unit_vec[0] = (\n        -cos_long_asc_node * sin_arg_periapsis\n        - sin_long_asc_node * cos_arg_periapsis * cos_inc\n    )\n    q_unit_vec[1] = (\n        -sin_long_asc_node * sin_arg_periapsis\n        + cos_long_asc_node * cos_arg_periapsis * cos_inc\n    )\n    q_unit_vec[2] = cos_arg_periapsis * sin_inc\n\n    # Calculate the position vector\n    x = (\n        semi_major_axis\n        * (1.0 - eccentricity**2)\n        / (1.0 + eccentricity * cos_true_anomaly)\n        * (cos_true_anomaly * ecc_unit_vec + sin_true_anomaly * q_unit_vec)\n    )\n\n    if np.isnan(x).any():\n        return np.array([np.nan, np.nan, np.nan])\n\n    return x\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Due to gravitational resonance of Jupiter and other planets, gaps are formed in the asteroid belt at certain ratio of the semi-major axis \\(a\\). These gaps are called Kirkwood gaps. To simulate its formation, we use the same initial conditions as the Asteroid belt animation example, where the initial value of \\(a\\) are sampled with \\(a \\sim \\text{Uniform}(2.0, 3.5)\\).</p> <p>For the simulation, we chose the WHFast integrator with \\(\\Delta t = 180\\) days and \\(t_f = 5\\) million years. The large time step is chosen after a convergence test done without the asteroids, as the secular evolutions seems to be fairly accurate even with this time step. Note that this time step is only possible for the WHFast integrator, but not other integrators like RK4 or LeapFrog.</p> <p>Although the time scales are quite long, we assume the asteroids to be massless for performance reasons. So, just keep in mind that this is not a very accurate simulation. Furthermore, even if we tries to include the gravity due to the asteroids, their contribution would likely be smaller than the round off error, so we can't really include them even if we wanted to.</p>"},{"location":"examples/kirkwood_gaps/kirkwood_gaps/#results","title":"Results","text":"<p>The results seems to be quite successful. The simulation is done on Macbook Air M1 and it only took 24 hours. About 7500 asteroids are removed from the simulation due to failure to converge in the Kepler's solver.</p>"}]}